#!/usr/bin/perl -w

use strict;
use warnings;

use Getopt::Long;
use AppConfig;

use lib "/usr/share/baracus/perl";

use SqlTFTPd qw(%OPCODES);
use SqlFS;

my $debug = 0;

my $sysconfigfile = '/etc/sysconfig/baracus';
my $sysconfig = AppConfig->new( {CREATE => 1} );
$sysconfig->define( 'baracusdir=s' );
$sysconfig->define( 'baracus_options=s' );
$sysconfig->file($sysconfigfile);
my $baracusdir = $sysconfig->get( 'baracusdir' ); # ~baracus is default
my $baracus_options=$sysconfig->get( 'baracus_options' );

$debug = 1 if ( defined $baracus_options and $baracus_options =~ m|debug| );

print "\$baracusdir after : $baracusdir EOL\n" if $debug;
if ( $baracusdir =~ m|^~([^/]*)| ) {
  my $prepath="";
  if ( "$1" eq "" ) {
    $prepath = $ENV{HOME}
  } else {
    unless ($prepath = (getpwnam($1))[7]) {
      die "BARACUSDIR has bad use of ~ or non-existent user in $sysconfigfile\n";
    }
  }
  $baracusdir =~ s|^~([^/]*)|$prepath|;
}
# remove trailing slash or spaces
$baracusdir =~ s|/*\s*$||;
print "\$baracusdir after : $baracusdir EOL\n" if $debug;

# store baracus well know directories in global hash
our %bdir = (
	    'root' => "$baracusdir",
	    'conf' => "/etc/baracus.d",
	    'data' => "/usr/share/baracus",
	   );
my @bdirs = qw( builds isos templates modules hooks logs );
foreach my $bd (@bdirs) {
  $bdir{ $bd } = "$baracusdir/$bd";
}
if ($debug) {
  print "Baracus directories:\n";
  while ( my ($key,$value) = each ( %bdir ) ) {
    print "\t$key => $value\n" if ( defined $value );
  }
}

open(STDOUT, ">>$bdir{'logs'}/baracusd")
    or die "Unable to open log file: $!\n";
open(STDERR, ">>$bdir{'logs'}/baracusd")
    or die "Unable to open log file: $!\n";

my $dovalidate = 1;
our $validatefile = "$bdir{'hooks'}/verify_client_build";
our $validatepass = "$bdir{'hooks'}/verify_client_build_passed";
our $validatefail = "$bdir{'hooks'}/verify_client_build_failed";
&checkdovalidate();

my $dopxehook = 1;
my $dopxehookpass = 1;
my $dopxehookfail = 1;
our $pxehookpass = "$bdir{'hooks'}/post_pxe_delivery_passed";
our $pxehookfail = "$bdir{'hooks'}/post_pxe_delivery_failed";
&checkdopxehook();

# get baracus id information
my $user = "baracus";
my $uid;
unless ($uid = (getpwnam($user))[2]) {
    die "Attempt to run server as non-existent or super user\n";
}

# create instance of TFTP server
my $listener = SqlTFTPd->new( 'Timeout' => 10 )
    or die SqlTFTPd->error;

unless( $listener->open() ) {
    print STDOUT "baracusd unable to listen on tftp port: ", $@, "\n";
    print STDOUT "Try shutting down other possible tftp servers first:\n\n",
        "\tservice atftpd stop\n",
        "\tchkconfig atftpd off\n\n",
        "Or disabling the xinetd based 'tftp' service:\n\n",
        "\tchkconfig tftp off\n\tservice xinetd restart\n\n";
    die "Unable to open port for TFTP connections: ", $@, "\n",
        "please refer to $bdir{'logs'}/baracusd for details.\n";
}

print STDOUT "baracusd launched with uid: $>\n";

# set the effective id to baracus
$> = $uid;

# delayed printing to switch to non-root asap
printf STDOUT "SqlTFTPd listener is bound to %s:%d\n",
    $listener->{'LocalAddr'} ? $listener->{'LocalAddr'} : "'any address'",
    $listener->{'LocalPort'};

print STDOUT "baracusd now running with uid: $>\n";

# create and/or connect to our database to serve up TFTP files
my $dbname = "sqltftp";
my $dbsource = "DBI:Pg:dbname=$dbname";
print STDOUT "dbsource   $dbsource\n";

my $sqlfsOBJ = SqlFS->new( 'DataSource' => "$dbsource",
                           'User' => "baracus",
                           'debug' => $debug )
    or die "Unable to create new instance of SqlFS\n";

$listener->setSqlFSHandle( $sqlfsOBJ );

# load any missing required files
my @requiredfiles = ( "$bdir{'data'}/pxelinux.0",
                      "$bdir{'data'}/data/dban.bzi",
                      "$bdir{'data'}/data/dban.initrd",
                      "$bdir{'data'}/templates/pxetemplate-autowipe.dban",
                      "$bdir{'data'}/templates/pxetemplate-noautowipe.dban",
                     );

foreach my $requiredfile ( @requiredfiles ) {
    unless ( $sqlfsOBJ->find( $requiredfile ) ) {
        if (not -f $requiredfile) {
            print STDOUT "required file not found: $requiredfile";
            exit 2;
        }
        print STDOUT "missing required - adding $requiredfile\n";
        $sqlfsOBJ->store( $requiredfile );
    }
}

# perpetually serve up files from SqlFS database via TFTP

# hash ref of ips that have been denied pxe 01-<mac> disabled entries
my $disabledips = {};

while (1) {
    # wait for any request (RRQ or WRQ)
    if (my $request = $listener->waitRQ()) {
        # process request and be done if validateURL
        unless ( $dovalidate && &validateURL( $request ) ) {

            # upcase MAC portion of pxeboot 01-<mac> file
            &upcasepxefilename( $request );

            printf "Received %s peer %s file '%s'\n",
                $OPCODES{$request->{'_REQUEST_'}{'OPCODE'}},
                    $request->{'_REQUEST_'}{'PeerAddr'},
                        $request->{'_REQUEST_'}{'FileName'};

            # process the request
            my $status = $request->processRQ( $disabledips );
            if ( $status ) {
                printf STDOUT "Succeess %s peer %s file '%s' done\n",
                    $OPCODES{$request->{'_REQUEST_'}{'OPCODE'}},
                        $request->{'_REQUEST_'}{'PeerAddr'},
                            $request->{'_REQUEST_'}{'FileName'};
            } else {
                print STDOUT SqlTFTPd->error;
                if ( $debug and
                     ( defined $disabledips->{ $request->{'_REQUEST_'}{'PeerAddr'} } ) ) {
                    print STDOUT "Disabled PXE peer $request->{'_REQUEST_'}{'PeerAddr'} check tftp entry no|enable flag\n";
                }
            }
            &deliverPXE( $request, $status ) if ( $dopxehook );
        }
    }
}

exit 0;

die "DOES NOT EXECUTE";

###########################################################################

sub checkdovalidate {
if (not -e $validatefile) {
    print STDOUT "Build client verification script not found:\n\t$validatefile\n";
    print STDOUT "No confirmation of completed builds or do post install hooks\n";
    print STDOUT "Please check setting of BARACUSDIR in $sysconfigfile\n";
    $dovalidate = 0;
}
}

sub checkdopxehook {
    if (not -e $pxehookpass) {
        $dopxehookpass = 0;
    }
    if (not -e $pxehookfail) {
        $dopxehookfail = 0;
    }
    unless ( $dopxehookpass or $dopxehookfail ) {
        $dopxehook = 0;
    }
}

sub validateURL
{
    my $request = shift;

    my $ip = $request->{'_REQUEST_'}{'PeerAddr'};
    my $name = $request->{'_REQUEST_'}{'FileName'};

    unless ( $name =~ m|.*/baracus/uuid/([-0-9a-zA-Z]{36})\?(\S+).*$| ) {
        return 0;
    }

    my $uuid=$1;
    my $hostname=$2;
    # print STDOUT "VERIFYING hostname $hostname ip $ip uuid $uuid\n";
    my $status = system("$validatefile $hostname $ip $uuid");
    if ( $status == 1 ) {
        print STDOUT "VERIFYING FAILED $hostname $ip $uuid\n";
        if (-x $validatefail) {
            print STDOUT "INVOKING $validatefail\n";
            system("$validatefail $hostname $ip $uuid");
        } else {
            print STDOUT "no executable failed script found: $validatefail\n";
        }
    } elsif ( $status == 0 ) {
        print STDOUT "VERIFYING PASSED $hostname $ip $uuid\n";
        if ( -x $validatepass ) {
            print STDOUT "INVOKING $validatepass\n";
            system("$validatepass $hostname $ip $uuid");
        } else {
            print STDOUT "no executable passed script found: $validatepass\n";
        }
    }
    # was a valid validate url - even if a spoofing attempt
    return 1;
}

sub upcasepxefilename {
    my $request = shift;

    unless ( $request->{'_REQUEST_'}{'FileName'} =~ m|01-((([0-9a-fA-F]){2}-?){6})| ) {
        return;
    }
    $request->{'_REQUEST_'}{'FileName'} =~ s|^([^/]*)/||;  # match prefix and rm
    $request->{'_REQUEST_'}{'FileName'} =~ tr|a-z|A-Z|;    # upcase
    $request->{'_REQUEST_'}{'FileName'} =
        "$1/" . $request->{'_REQUEST_'}{'FileName'};       # put prefix back
}

sub deliverPXE {
    my $request = shift;
    my $tftpsts = shift;

    unless ( $request->{'_REQUEST_'}{'FileName'} =~ m|01-((([0-9a-fA-F]){2}-?){6})| ) {
        return;
    }

    # on successful deliver of pxeboot file we may like to automate
    # some changes of the related entries. for instance for generic
    # hardware set to always pxe boot we need to disable the related
    # tftp server build entry. another example, after delivery of the
    # dban pxeboot file we may want to auto-remove the host template.

    my $mac = $1;
    my $ip = $request->{'_REQUEST_'}{'PeerAddr'};

    $mac =~ s|\-|:|g;

    if ( defined $tftpsts and $dopxehookpass) {
        print STDOUT "INVOKING PXE PASS $pxehookpass $mac $ip\n";
        system("$pxehookpass $mac $ip");
    } elsif ( $dopxehookfail ) {
        print STDOUT "INVOKING PXE FAIL $pxehookpass $mac $ip\n";
        system("$pxehookfail $mac $ip");
    }
    return;
}

die "ABSOLUTELY DOES NOT EXECUTE";

__END__

