#!/usr/bin/perl -w

use strict;
use warnings;

use Getopt::Long;

use lib "/usr/share/baracus/perl";

use BaracusConfig qw( :vars );
use BaracusSYSLOG qw( :subs );
use SqlTFTPd qw(%OPCODES);
use SqlFS;

my $debug = 0;

$debug = 1 if ( defined $baVar{bdoptions} and $baVar{bdoptions} =~ m|debug| );

open(STDOUT, ">>$baDir{'logs'}/baracusd")
    or die "Unable to open log file: $!\n";
open(STDERR, ">>$baDir{'logs'}/baracusd")
    or die "Unable to open log file: $!\n";

#my $uphoststate = "$baDir{'data'}/scripts/baracusd_update_host_state.pl";
#
#my $dovalidate = 1;
#my $validatepass = "$baDir{'hooks'}/verify_client_build_passed";
#my $validatefail = "$baDir{'hooks'}/verify_client_build_failed";
#&checkdovalidate();
#
#my $dopxehookpass = 1;
#my $dopxehookfail = 1;
#my $pxehookpass = "$baDir{'hooks'}/post_pxe_delivery_passed";
#my $pxehookfail = "$baDir{'hooks'}/post_pxe_delivery_failed";
#&checkdopxehook();

&config_syslog();

# get baracus id information
my $user = "baracus";
my $uid;
unless ($uid = (getpwnam($user))[2]) {
    die "Attempt to run server as non-existent or super user\n";
}

# create instance of TFTP server
my $listener = SqlTFTPd->new( 'Timeout' => 10, 'debug' => $debug )
    or die SqlTFTPd->error;

unless( $listener->open() ) {
    print STDOUT "baracusd unable to listen on tftp port: ", $@, "\n";
    print STDOUT "Try shutting down other possible tftp servers first:\n\n",
        "\tservice atftpd stop\n",
        "\tchkconfig atftpd off\n\n",
        "Or disabling the xinetd based 'tftp' service:\n\n",
        "\tchkconfig tftp off\n\tservice xinetd restart\n\n";
    print STDERR "Unable to open port for TFTP connections: ", $@, "\n",
        "please refer to $baDir{'logs'}/baracusd for details.\n";
    exit 3;
}

print STDOUT "baracusd launched with uid: $>\n";

# set the effective id to baracus
$> = $uid;

# delayed printing to switch to non-root asap
printf STDOUT "SqlTFTPd listener is bound to %s:%d\n",
    $listener->{'LocalAddr'} ? $listener->{'LocalAddr'} : "'any address'",
    $listener->{'LocalPort'};

print STDOUT "baracusd now running with uid: $>\n";

# create and/or connect to our database to serve up TFTP files
my $dbname = "sqltftp";
my $dbsource = "DBI:Pg:dbname=$dbname;port=5162";
print STDOUT "dbsource   $dbsource\n";

my $sqlfsOBJ = SqlFS->new( 'DataSource' => "$dbsource",
                           'User' => "baracus",
                           'debug' => $debug )
    or die "Unable to create new instance of SqlFS\n";

$listener->setSqlFSHandle( $sqlfsOBJ );

# load any missing required files
my @requiredfiles = ( "$baDir{'data'}/data/gpxe_baracus.0",
                      "$baDir{'data'}/data/linux.baracus",
                      "$baDir{'data'}/data/initrd.baracus",
                      "$baDir{'data'}/data/pxelinux.0",
                     );

foreach my $requiredfile ( @requiredfiles ) {
    unless ( $sqlfsOBJ->find( $requiredfile ) ) {
        if (not -f $requiredfile) {
            print STDOUT "required file not found: $requiredfile";
            exit 2;
        }
        print STDOUT "missing required - adding $requiredfile\n";
        $sqlfsOBJ->store( $requiredfile );
    }
}

# perpetually serve up files from SqlFS database via TFTP

# hash ref of ips that have been denied pxe 01-<mac> disabled entries
my $pxedisabledips = {};
my $pxedeliveredips = {};

while (1) {
    # wait for any request (RRQ or WRQ)
    if (my $request = $listener->waitRQ()) {
        # process request and be done if validateURL
#        unless ( $dovalidate && &validateURL( $request ) ) {

            # upcase MAC portion of pxeboot 01-<mac> file
            &upcasepxefilename( $request );


        $SIG{CHLD} = 'IGNORE';  # so we don't create zombies

        my $child = fork();

        if ( $child ) {
#            print "forked pid $child for $request->{'_REQUEST_'}{'FileName'}\n";
            ;
        }
        elsif ( ! $child ) {
            $sqlfsOBJ->clone_dhb_for_child();

            printf "Received %s peer %s file '%s'\n",
                $OPCODES{$request->{'_REQUEST_'}{'OPCODE'}},
                    $request->{'_REQUEST_'}{'PeerAddr'},
                        $request->{'_REQUEST_'}{'FileName'};

            # process the request - track 01-<mac> denies and deliveries
            my $status = $request->processRQ( $pxedisabledips,
                                              $pxedeliveredips );
            if ( $status ) {
                printf STDOUT "Succeess %s peer %s file '%s' done\n",
                    $OPCODES{$request->{'_REQUEST_'}{'OPCODE'}},
                        $request->{'_REQUEST_'}{'PeerAddr'},
                            $request->{'_REQUEST_'}{'FileName'};
            } else {
                print STDOUT SqlTFTPd->error;
                if ( $debug and
                     ( defined $pxedisabledips->{ $request->{'_REQUEST_'}{'PeerAddr'} } ) ) {
                    print STDOUT "Disabled PXE peer $request->{'_REQUEST_'}{'PeerAddr'} check tftp entry no|enable flag\n";
                }
            }
            # exit the forked proc
            exit 0;
        }
        else {
            print "Trouble forking\n";
        }
#            &deliverPXE( $request, $status );
#        }
    }
}

exit 0;

die "DOES NOT EXECUTE";

###########################################################################

#sub checkdovalidate {
#if (not -e $uphoststate) {
#    print STDOUT "State change script not found:\n\t$uphoststate\n";
#    print STDOUT "No confirmation of completed builds, wipes\n";
#    $dovalidate = 0;
#}
#}

#sub checkdopxehook {
#    if (not -e $pxehookpass) {
#        $dopxehookpass = 0;
#    }
#    if (not -e $pxehookfail) {
#        $dopxehookfail = 0;
#    }
#}

sub config_syslog
{
    my $logconf="/etc/syslog-ng/syslog-ng.conf";
    my $armorconf="/etc/apparmor.d/sbin.syslog-ng";
    my $logpath = "$baDir{'logs'}/remote";

    unless ( -d $logpath ) {
        mkdir "$logpath", 0755
            or die ("Cannot create: $! \n");
    }

    unless ( -f $logconf ) {
        return;
    }

    if ($baVar{rlogging} eq "yes") {
        print STDOUT "Enabling remote logging support in syslog-ng.conf\n";
        if ( enable_remote_logging( $logpath,
                                    $logconf,
                                    $baVar{serverip} )) {
#            system("rcsyslog restart");
            system("rcsyslog status || rcsyslog restart");
        } else {
            print BaracusSYSLOG::error();
        }

        unless ( -f $armorconf ) {
            return;
        }

        if ( enable_apparmor_logging( $logpath,
                                      $armorconf ) ) {
#            system("rcapparmor restart");
            system("rcapparmor status || rcapparmor restart");
        } else {
            print BaracusSYSLOG::error();
        }
    } else {
        print STDOUT "Disabling remote logging support in syslog-ng.conf\n";
        if ( disable_remote_logging( $logconf ) ) {
#            system("rcsyslog restart");
            system("rcsyslog status || rcsyslog restart");
        } else {
            print BaracusSYSLOG::error();
        }

        unless ( -f $armorconf ) {
            return;
        }

        if ( disable_apparmor_logging( $logpath, $armorconf ) ) {
#            system("rcapparmor restart");
            system("rcapparmor status || rcapparmor restart");
        } else {
            print BaracusSYSLOG::error();
        }
    }
}

#sub validateURL
#{
#    my $request = shift;
#
#    my $name = $request->{'_REQUEST_'}{'FileName'};
#
#    unless ( $name =~ m|.*/baracus/uuid/([-0-9a-zA-Z]{36})\?(\S+).*$| ) {
#        return 0;
#    }
#    my $uuid=$1;
#    my $hostname=$2;
#    my $ip = $request->{'_REQUEST_'}{'PeerAddr'};
#    my $mac = "";
#    if ( defined $pxedeliveredips->{ $request->{'_REQUEST_'}{'PeerAddr'} } ) {
#        $mac = $pxedeliveredips->{ $request->{'_REQUEST_'}{'PeerAddr'} };
#    }
#    my $cmd = "$uphoststate endofbuild --host $hostname --ip $ip --uuid $uuid";
#    $cmd .= " --mac $mac" if ( $mac );
#
#    print STDOUT "VERIFYING hostname $hostname ip $ip uuid $uuid mac $mac\n"
#        if $debug;
#
#    my $status = system( $cmd );
#    if ( $status == 1 ) {
#        print STDOUT "VERIFYING FAILED $hostname $ip $uuid $mac \n";
#        if (-x $validatefail) {
#            print STDOUT "INVOKING $validatefail\n";
#            system("$validatefail $hostname $ip $uuid $mac");
#        } else {
#            print STDOUT "no executable failed script found: $validatefail\n";
#        }
#    } elsif ( $status == 0 ) {
#        print STDOUT "VERIFYING PASSED $hostname $ip $uuid $mac\n";
#        if ( -x $validatepass ) {
#            print STDOUT "INVOKING $validatepass\n";
#            system("$validatepass $hostname $ip $uuid $mac");
#        } else {
#            print STDOUT "no executable passed script found: $validatepass\n";
#        }
#    }
#    # was a valid validate url - even if a spoofing attempt
#    return 1;
#}

sub upcasepxefilename {
    my $request = shift;

    if ( $request->{'_REQUEST_'}{'FileName'} =~ m|01-((([0-9a-fA-F]){2}-?){6})| ) {
        $request->{'_REQUEST_'}{'FileName'} =~ s|^([^/]*)/||; # match prefix and rm
        $request->{'_REQUEST_'}{'FileName'} =~ tr|a-z|A-Z|;   # upcase
        $request->{'_REQUEST_'}{'FileName'} =
            "$1/" . $request->{'_REQUEST_'}{'FileName'}; # put prefix back
    } else {
        $request->{'_REQUEST_'}{'FileName'} =~ s|.*\\||;
        $request->{'_REQUEST_'}{'FileName'} =~ s|^\\||;
    }
}

#sub deliverPXE {
#    my $request = shift;
#    my $tftpsts = shift;
#
#    unless ( $request->{'_REQUEST_'}{'FileName'} =~ m|01-((([0-9a-fA-F]){2}-?){6})| ) {
#        return;
#    }
#
#    # on successful deliver of pxeboot file we may like to automate
#    # some changes of the related entries. for instance for generic
#    # hardware set to always pxe boot we need to disable the related
#    # tftp server build entry. another example, after delivery of the
#    # dban pxeboot file we may want to auto-remove the host template.
#
#    my $mac = $1;
#    $mac =~ s|-|:|g;
#    my $ip = $request->{'_REQUEST_'}{'PeerAddr'};
#
#    if ( defined $tftpsts ) {
#        my $cmd = "$uphoststate pxeserved --mac $mac";
#        system( $cmd );
#    }
#    if ( defined $tftpsts and $dopxehookpass) {
#        print STDOUT "INVOKING PXE PASS $pxehookpass $mac $ip\n";
#        system("$pxehookpass $mac $ip");
#    } elsif ( $dopxehookfail ) {
#        print STDOUT "INVOKING PXE FAIL $pxehookfail $mac $ip\n";
#        system("$pxehookfail $mac $ip");
#    }
#    return;
#}


die "ABSOLUTELY DOES NOT EXECUTE";

__END__
