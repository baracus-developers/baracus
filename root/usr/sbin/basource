#!/usr/bin/perl -w

use strict;

use Getopt::Long qw( :config pass_through );
use AppConfig;
use Pod::Usage;

use File::Temp qw/ tempdir /;
use File::Find;
use File::Path;
use File::Copy;

use lib "/usr/share/baracus/perl";

use SqlFS;
use BaracusDB;
use BaracusSql;

=pod

=head1 NAME

B<basource> - baracus tool to manage the retrival of distro isos and creation of network install sources

=head1 SYNOPSIS

B<basource> E<lt>commandE<gt> [options and arguments]

Where E<lt>commandE<gt> is

Where command is one of

    add     --distro <x>  Add a new build source for distribution <x>
    remove  --distro <x>  Remove <x> as a build source
    disable --distro <x>  Diable a build source for distribution <x>
    enable  --distro <x>  Enable a build source for distribution <x>
    verify  --distro <x>  Verify build source for distribution <x>
    details --distro <x>  Display specifics about a distribution

    list   [--distro <x>] List known distros

    service --start       Start defaults [ BUILDTYPE and dhcpd ]
    service --stop        Stop defaults [ BUILDTYPE and dhcpd ]
    service --start <y>   Start specified service(s) (nfs,http,dhcpd)
    service --stop  <y>   Stop specified service(s) (nfs,http,dhcpd)

    help      This 'Usage' summary message.
    man       Detailed man page.

Use 'man' or 'help <command>' for more details.

=head1 DESCRIPTION

This tool assists with the downloading of distribution iso files, the creation of network install sources for those distributions, and the management of those network services and related control files.

=head1 OPTIONS

=over 4

=item -v --verbose Be verbose with output

=back

=cut

our $LASTERROR="";

my $verbose  = 0;
my $quiet    = 0;
my $all      = 0;
my $nolabels = 0;
my $debug    = 0;
my $man      = 0;
my $help     = 0;

my %multiarg; # used for processing repeatable getoptions

# get the sysconfig option settings
my $sysconfigfile = '/etc/sysconfig/baracus';
my $sysconfig = AppConfig->new( {CREATE => 1} );
$sysconfig->define( 'baracusdir=s',
                    'buildtype=s',
                    'buildip=s',
                   );
$sysconfig->file( $sysconfigfile );
my $baracusdir = $sysconfig->get( 'baracusdir' ); # ~baracus is default
my $buildtype  = $sysconfig->get( "buildtype" );
my $buildip    = $sysconfig->get( "buildip"   );

if ( $baracusdir =~ m|^~([^/]*)| ) {
    my $prepath="";
    if ( "$1" eq "" ) {
        $prepath = $ENV{HOME}
    } else {
        unless ($prepath = (getpwnam($1))[7]) {
            die "BARACUSDIR has bad use of ~ or non-existent user in $sysconfigfile\n";
        }
    }
    $baracusdir =~ s|^~([^/]*)|$prepath|;
}
# remove trailing slash or spaces
$baracusdir =~ s|/*\s*$||;

# store baracus well know directories in global hash 'bdir'
my @bdirs = qw( builds isos templates hooks logs );
my %bdir = (
         'root' => "$baracusdir",
         'data' => "/usr/share/baracus",
         );
foreach my $bd (@bdirs) {
  $bdir{ $bd } = "$baracusdir/$bd";
}

my $execname = $0;
$execname = $1 if ( $0 =~ m|^.*/([^/].+)| );

my %cmds = (
            'add'      => \&add,
            'remove'   => \&remove,
            'enable'   => \&enable,
            'disable'  => \&disable,
            'verify'   => \&verify,
            'list'     => \&list,
            'detail'   => \&detail,
            'service'  => \&service,
            );

GetOptions(
           'verbose'   => \$verbose,
           'quiet'     => \$quiet,
           'all'       => \$all,
           'nolabels'  => \$nolabels,
           'debug+'    => \$debug,
           'man'       => \$man,
           'help|?'    => \$help,
           );

&man()  if $man;
&help() if $help;
&help() unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &man(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &help(@ARGV); }

# wait till here to barf on this so help is available even with bad sysconfig
unless ($buildip) {
    print "Please edit /etc/sysconfig/baracus and set BUILDIP=<server>\n";
    exit 1;
}

my $xml = &baxml_load( "$bdir{'data'}/badistro.xml" );

my $dbname = "baracus";
my $dbrole = "baracus";

my $dbtftp = "sqltftp";

print "setting uid to $dbrole\n" if ($debug > 2);

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

my $hashoftbls = BaracusSql::get_baracus_tables();

print "bahost debug=$debug\n" if $debug;
my $deepdebug = $debug > 2 ? 1 : 0;
my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=$dbtftp",
                           'User' => "baracus",
                           'debug' => $deepdebug )
    or die "Unable to create new instance of SqlFS\n";

# connected as baracus - continue as root
# and swithc to baracus as needed in subroutines
print "setting uid back to $uid\n" if ($debug > 2);
$> = $uid;

my $status = &main(@ARGV);

$sqlfsOBJ->discard();

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

print $LASTERROR if $status;

exit $status;

die "DOES NOT EXECUTE\n";

###########################################################################

sub main
{
    my $command = shift;

    $command = lc $command;
    &check_command( $command );

    printf "Executing $command with \"@_\".\n" if ( $debug );

    $cmds{ $command }( @_ );
}

sub help
{
    my $command = shift;

    unless ( defined $command ) {
        pod2usage( -verboase   => 0,
                   -exitstatus => 0 );
    }

    $command = lc $command;
    &check_command( $command );

    pod2usage( -msg        => "$execname $command ...\n",
               -verbose    => 99,
               -sections   => "COMMANDS/${command}.*",
               -exitstatus => 0 );
}

sub man
{
    pod2usage( -verbose    => 2,
               -sections   => "NAME|SYNOPSIS|DESCRIPTION",
               -exitstatus => 0 );
}

sub check_command
{
    my $command = shift;

    my $cmd_list = join ', ', (sort keys %cmds);
    unless ( defined $command ) {
        print "Requires <command> (e.g. $cmd_list)\n";
        &help();
    }

    unless ( defined $cmds{ $command } ) {
        print "Invalid <command> '$command' please use:  $cmd_list\n";
        exit 1;
    }
}

sub check_either
{
    my $distro = shift;

    unless ( $distro ) {
        print "\nMissing arg: <distro>\n";
        &help();
    }

    unless ( &baxml_distro_gethash( $distro ) ) {
        print "Unknown distribution or addon specified: $distro\n";
        print "Please use one of the following:\n";
        foreach my $dist ( reverse sort &baxml_distros_getlist() ) {
            my $href = &baxml_distro_gethash( $dist );
            print "\t" . $dist . "\n" unless ( $href->{requires} );
        }
        exit 1;
    }
}

sub check_distro
{
    my $distro = shift;

    unless ( $distro ) {
        print "\nMissing arg: <distro>\n";
        &help();
    }

    my $dh = &baxml_distro_gethash( $distro );

    unless ( $dh ) {
        print "Unknown distribution specified: $distro\n";
        print "Please use one of the following:\n";
        foreach my $dist ( reverse sort &baxml_distros_getlist() ) {
            my $href = &baxml_distro_gethash( $dist );
            print "\t" . $dist . "\n" unless ( $href->{requires} );
        }
        exit 1;
    }

    if ( $dh->{requires} ) {
        print "Non-base distribution passed as base $distro\n";
        print "Perhaps try:\n\t\t--distro $dh->{basedist} --addon $distro\n";
        exit 1;
    }
}

sub check_addons
{
    my $distro = shift;
    my $addons = shift;

    my $dh = &baxml_distro_gethash( $distro );

    # verify all addons passed are intended for given distro as base
    foreach my $addon ( split /\s+/, $addons ) {

        &check_addon( $addon );

        my $ah = &baxml_distro_gethash( $addon  );

        unless ( $ah->{basedisthash} eq $dh ) {
            print "Base passed $distro instead of $dh->{basedist} for $addon\n";
            print "Perhaps try\n\t\t--distro $ah->{basedist} --addon $addon\n";
            exit 1;
        }
    }
}

sub check_addon
{
    my $addon = shift;

    my $dh = &baxml_distro_gethash( $addon );

    unless ( $dh ) {
        print "Unknown addon specified: $addon\n";
        print "Please use one of the following:\n";
        foreach my $ao ( reverse sort &baxml_distros_getlist() ) {
            my $ah = &baxml_distro_gethash( $ao );
            print "\t" . $ao . "\n" if ( $ah->{requires} );
        }
        exit 1;
    }

    unless ( defined $dh->{requires} ) {
        print "Base distro passed as value for --addon $addon\n";
        exit 1;
    }
}


=head1 COMMANDS

=head2 add --distro <name> [--addon <addos> [--addon ...]] [--check|--isos [--proxy]]

Where

  --distro <name>  specifies the full name of the base distribution
                   to use, e.g., sles-11-x86_64, sles-10.2-x86_64,
                   opensuse-11.1-i586

  --addon <name>   specifies any addon(s) to layer over the base
                   distribution sles-10.2-rt-x86_64, sles-11-hae-i586

  --check          Force check of the ISOs already present
  --isos           Download missing ISO files
  --proxy          Use a proxy service to fetch the ISO files

=cut

sub add() {

    my $command = 'add';
    my $distro;
    my $addons = "";
    my $proxy;
    my $check;
    my $isos;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addons=s'  => \&multiarg_handler,
               'proxy'     => \$proxy,
               'check'     => \$check,
               'isos|i'    => \$isos,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $addons = $multiarg{ 'addons' } if (defined $multiarg{ 'addons' });

    ## Test if selection is valid
    ##
    $distro = lc $distro;
    &check_distro( $distro );

    if ( $addons ) {
        print "Calling routine to verify addon(s) passed\n";
        return 1 if &check_addons( $distro, $addons );
    }

    my $sdk = get_distro_sdk( $distro );
    # do we have an sdk for this base
    if ( defined $sdk ) {
        if ( not $addons ) {
            # no other addons specified
            $addons = $sdk;
        }
        elsif ( not $addons =~ m/$sdk/ ) {
            # add sdk not specified in addons
            $addons = "$sdk " . $addons;
        }
    }
    if ( $isos ) {
        return 1 if &download_iso( $distro, $addons, $proxy );
    }

    print "Calling routine to locate ISO files\n";

    my $daisohr = &verify_iso( $distro, $addons, $isos, $check );

    print "Calling routines to generate build tree\n";

    &make_paths( $distro, $addons, $daisohr);

    &create_build( $distro );

    &streamline_install( $distro );

    print "Calling routine to configure $buildtype\n";

    &add_build_service( $distro, $addons );

    print "Calling routine to configure bootloader\n";
    &add_bootloader_files( $distro );

    &source_register($command, $distro, $addons);
}


=head2 remove --distro <name> [--addon <addos> [--addon ...]] [ --all ]

Where

  --distro <name>  specifies the full name of the base distribution
                   to remove, e.g., sles-11-x86_64, sles-10.2-x86_64,
                   opensuse-11.1-i586

  --addon <name>   specifies the addon(s) to be removed. like these
                   distributions sles-10.2-rt-x86_64, sles-11-hae-i586

  --all            remove all the addons and the base distro.

Without specifying --all, remove will not remove the base distro if it has any addons present so that a two step remove process must be used to first remove all the addons listed for the base distro and then another invocation with the base --distro alone.

=cut

sub remove() {

    my $command = 'remove';
    my $distro;
    my $addons = "";
    my @addons;
    my $share;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addons=s'  => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $addons = $multiarg{ 'addons' } if (defined $multiarg{ 'addons' });

    ## Test if selection is valid
    ##
    $distro = lc $distro;
    &check_distro( $distro );

    #
    # tempting - but don't put sdk in $addons here or it will be
    # removed even if only a different addon was to be removed leaving
    # the base and maybe other addons in place
    #

    if ( $all and $addons ) {
        $LASTERROR = "Unsafe mix of --all and --addon <addon> usage\n";
        return 1;
    }

    if ( $all ) {
        my $dh =  &baxml_distro_gethash( $distro );
        @addons = @{$dh->{basedisthash}->{addons}};
        $addons = join " ", @addons;
        print "working with 'all': $addons\n" if $debug;
    } else {
        @addons = split( /\s+/, $addons );

        # only check addons passed if not removing all
        if ( scalar @addons ) {
            print "Calling routine to verify addon(s) passed\n";
            return 1 if &check_addons( $distro, $addons );
        }
    }

    if ( scalar @addons ) {
        foreach my $addon ( @addons ) {
            my @shares;
            print "Removing addon $addon\n";
            ($share, undef) = &get_distro_share( $addon );
            print "$share ... removing\n" if $verbose;
            rmtree($share);
        }
        &remove_build_service("",$addons);
        &source_register($command,"",$addons);
    }

    # only remove base if no addons specified or --all passed
    if ( not scalar @addons or $all ) {
        my $dh = &baxml_distro_gethash( $distro );

        # need to check if removing base which has dependent add-ons
        my @addons = &list_installed_addons( $distro );

        # handle default 'unspecified' sdk as transparent member of base
        my $sdk = &get_distro_sdk( $distro );

        if ( ( scalar @addons > 1 ) or
             ( scalar @addons and not defined $sdk ) or
             ( scalar @addons and $addons[0] ne $sdk ) ) {
            $LASTERROR = "Remove these addons before removing $distro (or use --all)\n\t" . join ("\n\t", @addons ) . "\n";
            return 1;
        }
        if ( scalar @addons and defined $sdk and $addons[0] eq $sdk ) {
            ($share,undef) = &get_distro_share( $sdk );
            print "$share ... removing\n" if $verbose;
            rmtree($share);
        }
        ($share,undef) = &get_distro_share( $distro );
        print "$share ... removing\n" if $verbose;
        rmtree($share);

        &remove_bootloader_files($distro);
        &remove_build_service($distro,$addons);
        &source_register($command,$distro,$addons);
    }
    return 0;
}

=head2 enable { --distro <name> | --addon <name> }

Where

  --distro <name>  specifies the full name of the distribution to use

=cut

sub enable() {

    my $command = 'enable';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $distro = lc $distro;
    &check_either( $distro );

    my $dbref = &get_db_source_entry( $distro );
    unless ( defined $dbref->{distroid} and
             ( $dbref->{distroid} eq $distro ) ) {
        $LASTERROR = "Unable to find entry for $distro to enable\n";
        return 1;
    }
    unless ( defined $dbref->{status} and
             ( $dbref->{status} != BaracusSql::BA_DELETED ) ) {
        $LASTERROR = "Unable to enable $distro not yet added.\n";
        return 1;
    }
    if ( $dbref->{status} != BaracusSql::BA_DISABLED ) {
        $LASTERROR = "Unable to enable $distro not disabled.\n";
        return 1;
    }

    print "Enabling $distro\n";

    # do the add_build_service - less code
    &add_build_service( $distro );

    &source_register($command,$distro);
}

=head2 disable { --distro <name> | --addon <name> }

Where

  --distro <name>  specifies the full name of the distribution to
                   use, e.g., sles-11-x86_64, sles-10.2-rt-x86_64,
                   opensuse-11.1-i586, sles-11-hae-i586

=cut

sub disable() {

    my $command = 'disable';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $distro = lc $distro;
    &check_either( $distro );

    my $dbref = &get_db_source_entry( $distro );
    unless ( defined $dbref->{distroid} and
             ( $dbref->{distroid} eq $distro ) ) {
        $LASTERROR = "Unable to find entry for $distro to enable\n";
        return 1;
    }
    unless ( defined $dbref->{status} and
             ( $dbref->{status} != BaracusSql::BA_DELETED ) ) {
        $LASTERROR = "Unable to disable $distro not yet added.\n";
        return 1;
    }
    if ( $dbref->{status} != BaracusSql::BA_READY ) {
        $LASTERROR = "Unable to disable $distro not enabled.\n";
        return 1;
    }

    print "Disabling $distro\n";

    # do the remove_build_service - less code
    &remove_build_service($distro);

    &source_register($command,$distro);
}

=head2 verify { --distro <name> | --addon <name> }

Verify some details for the distro or addon specified

=cut

sub verify() {

    my $command = 'verify';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $distro = lc $distro;
    &check_either( $distro );

    my $dbref = &get_db_source_entry($distro);

    unless ( defined $dbref and
             $dbref->{status} and
             $dbref->{status} != BaracusSql::BA_DELETED ) {
        $LASTERROR = "No entry found for $distro\n";
        return 1;
    }

    if ( $debug > 2 ) {
        while ( my ($key, $val) = each %{$dbref} ) {
            print "dbref $key => $val\n";
        }
    }

    print "Target:\t\t$dbref->{distroid}\n";
    print "Created:\t$dbref->{creation}\n";
    print "Modified:\t$dbref->{change}\n" if defined $dbref->{change};
    print "Status:\t\t$BaracusSql::baState{ $dbref->{status}}\n";
    print "Service:\t$dbref->{type}";
    if ( &check_service( $dbref->{type} ) ) {
        print " not running";
    } elsif ( $verbose ) {
        print " ok";
    }
    print "\n";

    my $oldshare = "";
    foreach my $prod ( &baxml_products_getlist( $distro ) ) {
        my ($netcfg, $share, $state) = &check_service_product( $distro, $prod, $dbref->{type} );

        if ( $oldshare ne $share ) {
            $oldshare = $share;

            print "Share:\t\t$netcfg";
            if ( not $state ) {
                print " missing";
            } elsif ( $verbose ) {
                print " ok";
            }
            print "\n";

            print "Path:\t\t$share";
            if ( not -d $share ) {
                print " missing";
            } elsif ( $verbose ) {
                print " ok";
            }
            print "\n";
        }
    }

    my $dh = &baxml_distro_gethash( $distro );
    my $base = $dh->{basedist};

    my $state = &sqlfs_getstate( "linux.$base" );
    print "kernel:\t\tlinux.$base";
    if ( not $state ) {
        print " missing";
    } else {
        if ( $state != 1 ) {
            print " disabled";
        } elsif ( $verbose ) {
            print " ok";
        }
    }
    print "\n";

    $state = &sqlfs_getstate( "initrd.$base" );
    print "ramdisk:\tinitrd.$base";
    if ( not $state ) {
        print " missing";
    } else {
        if ( $state != 1 ) {
            print " disabled";
        } elsif ( $verbose ) {
            print " ok";
        }
    }
    print "\n";
}

=head2 detail { --distro <name> | --addon <name> }

Displays many details for the distribution specified

=cut

sub detail() {

    my $command = 'detail';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $distro = lc $distro;
    &check_either( $distro );

    my $dbref = &get_db_source_entry($distro);
    if ( defined $dbref and
         defined $dbref->{status} and
         $dbref->{status} != BaracusSql::BA_DELETED ) {
        $status = $BaracusSql::baState{ $dbref->{status} };
    } else {
        $status = $BaracusSql::baState{ BaracusSql::BA_DELETED };
    }

    my $dh = &baxml_distro_gethash( $distro );
    my $bh = $dh->{basedisthash};

    my %iodhash;

    find ( { wanted =>
             sub {
                 $iodhash{$_} .= "$File::Find::name ";
             },
             follow => 1
            },
           $bdir{isos} );

    print "\nDetails for $distro\n";
    print "With current status '$status'\n";
    if ($dh->{requires}) {
        print "Add-on product extending $dh->{basedist}\n";
    } else {
        print "Base product";
        if ( $bh->{addons} and scalar @{$bh->{addons}} ) {
            print " supporting extension(s):  " .
                join (", ", (sort @{$bh->{addons}} ) );
        }
        print "\n";
    }

    print "Based on product(s):  " .
        join (", ", ( sort &baxml_products_getlist( $distro ) ) ) . "\n";
    foreach my $product ( sort &baxml_products_getlist( $distro ) ) {
        print "Detail for $product";
        my $ph = &baxml_product_gethash( $distro, $product );
        if ( defined $ph->{'addon'} and $ph->{'addon'} ne "base" ) {
            print " with extension style '$ph->{'addon'}'\n";
        }
        else {
            print "\n";
        }
        foreach my $iso ( sort &baxml_isos_getlist( $distro, $product ) ) {
            my $ih = &baxml_iso_gethash( $distro, $product, $iso );
            my $builds = $ih->{isopath};
            my $isoexist = "-";
            my $direxist = "-";
            $isoexist = "+" if ( $iodhash{$iso} );
            $direxist = "+" if ( -d $builds );

            $builds =~ s|$bdir{builds}/||og;
            printf "  %s $iso  =>  %s $builds\n", $isoexist, $direxist;
        }
    }
}

=head2 list  [ base | addon ] { --distro <name> | --addon <name> } [--all]

  List distribution state.

  If a distribution has not been added, or has been removed, it is not displayed in the output.  To see all Baracus managable distributions and their state use the --all option.

Options

    --distro <name>  Exact, or partial with wildcarded ('*')
    --all            See all managable distributions

    base             Scope results to matching base distributions
    addon            For a provided base list the applicable addons

=cut

sub list() {

    my $command = 'list';


    my $distro;
    my $base = "";
    my $addon = "";
    my $wildcard = 0;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( defined $distro ) {
        $distro = lc $distro ;
        if ( $distro =~ m|\*| ) {
            $distro =~ s|\*|.*|g;
            $wildcard = 1;
        }
    } else {
        $distro = "";
    }

    my $name = "distro";
    if ( scalar @ARGV ) {
        if ( $ARGV[0] eq "base" ) {
            $base = shift @ARGV;
        }
        elsif ( $ARGV[0] eq "addon" ) {
            $addon = shift @ARGV;
            $name = "addon";
        }

        if ( scalar @ARGV ) {
            printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
            &help( $command );
        }
    }

    #
    # more like barepo than bahost this tools list relies on the
    # badistro.xml and the populated builds and isos directories.
    #

    unless ( $quiet || $nolabels ) {
        print "--------------------------------------------------------------------------------\n";
        printf "%-32s status\n", $name;
        print "--------------------------------------------------------------------------------\n";
    }

    foreach my $adistro ( reverse sort &baxml_distros_getlist() ) {
        my $dh = &baxml_distro_gethash($adistro);
        if ( $base ) {
            next if ( defined $dh->{requires} );
        }
        unless ( $addon ) {
            if ( $distro ) {
                if ( $wildcard ) {
                    next unless ( $adistro =~ m|$distro|o );
                } else {
                    next unless ( $adistro eq $distro );
                }
            }
        }
        if ( $addon ) {
            next unless ( defined $dh->{requires} );
            if ( $distro ) {
                if ( $wildcard ) {
                    next unless ( $dh->{basedist} =~ m|$distro|o );
                } else {
                    next unless ( $dh->{basedist} eq $distro );
                }
            }
        }
        my $dbref = &get_db_source_entry($adistro);
        my $status;

        if ( defined $dbref and
             $dbref->{status} and
             $dbref->{status} != BaracusSql::BA_DELETED ) {
            printf "%-32s ", $adistro;
            $status = $BaracusSql::baState{ $dbref->{status} };
            unless ( $quiet ) {
                printf "$status";
            }
            print "\n";
        } elsif ( $all ) {
            printf "%-32s ", $adistro;
            $status = $BaracusSql::baState{ BaracusSql::BA_DELETED };
            unless ( $quiet ) {
                printf "$status";
            }
            print "\n";
        }
    }
    return 0;
}

=head2 service { --start [type] | --stop [type] }

With service you need to specify start or stop

    service --start
    service --stop

With current sysconfig settings, if specific services are unspecified, these default to start or stop both the build type and dhcpd.

You can also list the services to start or stop specifically

    service --start "http dhcpd" --stop nfs

=cut

sub service() {

    my $command = 'service';

    my $startlist = "";
    my $stoplist  = "";

    @ARGV = @_;

    GetOptions(
               'start:s'    => \&multiarg_handler,
               'stop:s'     => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $command );
    }

    $startlist = $multiarg{ 'start' } if (defined $multiarg{ 'start' });
    $stoplist  = $multiarg{ 'stop'  } if (defined $multiarg{ 'stop'  });


    unless ( $startlist or $stoplist ) {
        &help ( $command );
    }

    if ( defined $startlist ) {
        foreach my $serv ( split(/\s+/, $startlist ) ) {
            &enable_service( $serv );
        }
    }
    if ( defined $stoplist ) {
        foreach my $serv ( split(/\s+/, $stoplist ) ) {
            &disable_service( $serv );
        }
    }
    return 0
}

###########################################################################
# finished with primary commands - helpers follow

sub download_iso() {

    print "+++++ download_iso\n" if ( $debug > 1 );

    use Term::ReadKey;

    my $distro = shift;
    my $addons = shift;
    my $proxy  = shift;

    my @dalist;

    push @dalist, $distro if $distro;
    push @dalist, split( /\s+/, $addons) if ( $addons );

    my $daisohr = {};
    my @isofilelist;
    my $found = 0;

    ## create directory for iso files if not present
    if (! -d $bdir{builds}) {
        mkpath "$bdir{builds}" or die ("Cannot create ~baracus/isos directory\n");
    }

    print "Searching for iso files needing download ...\n" if ($verbose);
    foreach my $da ( @dalist ) {
        my @distisolist = ();
        my $distisoinfo = {};
        my $skip = 0;
        foreach my $prod ( &baxml_products_getlist( $da ) ) {
            foreach my $isofile ( &baxml_isos_getlist( $da, $prod ) ) {
                my $ih = &baxml_isos_getlist( $da, $prod, $isofile );
                $distisoinfo->{$isofile}->{path} = $ih->{isopath};
                $distisoinfo->{$isofile}->{hash} = $ih;
                find ( { wanted =>
                         sub {
                             if ($_ eq $isofile) {
                                 print "found $File::Find::name\n" if $debug;
                                 $found=1;
                                 $skip=1;
                             }
                         },
                         follow => 1
                        },
                       $bdir{isos} );
                unless ( $skip ) {
                    push @distisolist, $isofile;
                    $skip = 0;
                }
            }
        }
        $daisohr->{ $da }->{info} = $distisoinfo;
        push @{$daisohr->{ $da }->{list}}, @distisolist;
        push @isofilelist, @distisolist;

    }
    if ($found) {
        print "ISO download requested and files were already found. If checksum\n";
        print "verification fails for a file, please remove the file and retry.\n";
    }

    return 0 unless @isofilelist;

    my $username="";
    my $password="";
    my $proxyaddr="";
    my $pusername="";
    my $ppassword="";

    my $dh = &baxml_distro_gethash( $distro );

    if ($dh->{autodownload} eq "no") {
        $LASTERROR = "Baracus assisted download not supported for $distro\n";
        return 1;
    }

    if ($dh->{autodownload} eq "auth") {
        print "Please enter (novell.com) userid: ";
        chomp($username = ReadLine 0);

        print "Please enter (novell.com) password: ";
        ReadMode 'noecho';
        chomp($password = ReadLine 0);
        ReadMode 'normal';
    }

    if ($proxy) {
        print "Please enter proxy address: ";
        chomp($proxyaddr = ReadLine 0);

        print "Please enter proxy username: ";
        chomp($pusername = ReadLine 0);

        print "Please enter proxy password: ";
        ReadMode 'noecho';
        chomp($ppassword = ReadLine 0);
        ReadMode 'normal';
        print "\n";
    }

    print "\nDownloading: \n";
    foreach my $da ( @dalist ) {
        foreach my $isofile ( sort @{$daisohr->{ $da }->{list}} ) {
            # here isofile has no path info just the filename
            my $url = $daisohr->{$da}->{info}->{$isofile}->{hash}->{url};
            &get_iso($distro,$url,$isofile,$username,$password,$proxy,$pusername,$ppassword,$proxyaddr);
        }
    }
}

sub get_iso() {

    print "+++++ get_iso\n" if ( $debug > 1 );
    my ($distro,$url,$iso,$username,$password,$proxy,$pusername,$ppassword,$proxyaddr) = @_;
    use LWP::UserAgent;
    my $file="$bdir{'isos'}/$iso";
    my $br;
    my $ua;

    my $dh = &baxml_distro_gethash( $distro );

    $proxyaddr =~ s/http:\/\///;
    $ENV{'HTTP_PROXY'} = "http:\/\/$pusername:$ppassword\@$proxyaddr";

    unless(-d $bdir{'isos'}) {
        mkdir $bdir{'isos'}, 0755 || die ("Cannot create directory\n");
    }

    if ($proxy) {
        $ua = LWP::UserAgent->new(keep_alive => 1, env_proxy=>1 ) || die "$!";
    } else {
        $ua = LWP::UserAgent->new(keep_alive => 1 ) || die "$!";
    }
    unless ($dh->{autodownload} eq "open") {
        $ua->cookie_jar({});
        $ua->credentials('cdn.novell.com:80', 'iChain', "$username",  "$password" );
    }

    $| = 1;
    open(FILE, ">$file") || die "Can't open $file: $!\n";
    my $req = $ua->request(HTTP::Request->new(GET => $url),
                           sub {
                               $br += length($_[0]);
                               if ($_[1]->content_length) {
                                   printf STDERR " $iso: [ %d%% ] \r",100*$br/$_[1]->content_length;
                               }
                               binmode FILE;
                               print FILE $_[0] or die "Can't write to $file: $!\n";
                           });
    if (! $req->is_success) {
        unlink $file;
        print $req->status_line, "\n";
        exit(1);
    }
    print "\n";
    if (fileno(FILE)) {
        close(FILE) || die "Can't write to $file: $!\n";
    }
}

sub verify_iso() {

    print "+++++ verify_iso\n" if ( $debug > 1 );

    use Digest::MD5 qw(md5 md5_hex md5_base64);
    use File::Basename;

    my $distro = shift;
    my $addons = shift;
    my $isos   = shift;
    my $check  = shift;

    my @dalist;

    push @dalist, $distro if $distro;
    push @dalist, split( /\s+/, $addons) if ( $addons );

    my $halt = 0;
    my $daisohr = {};

    ## test directory for iso files
    if (! -d $bdir{builds}) {
        print "Directory does not exist: $bdir{builds}\n";
        exit(1);
    }

    print "Searching for required iso files ...\n" if ($verbose);
    foreach my $da ( @dalist ) {
        print "verify working dist $da\n" if ($debug > 1);
        my @distisolist = ();
        my $distisoinfo = {};
        my $missing;
        foreach my $prod ( &baxml_products_getlist( $da ) ) {
            foreach my $isofile ( &baxml_isos_getlist( $da, $prod ) ) {
                print "dist $da prod $prod iso $isofile\n";
                my $ih = &baxml_iso_gethash( $da, $prod, $isofile );
                $distisoinfo->{$isofile}->{'hash'} = $ih;
                $distisoinfo->{$isofile}->{'path'} = $ih->{'isopath'};
                $missing=1;
                find ({ wanted =>
                        sub {
                            if ($_ eq $isofile) {
                                print "found $File::Find::name\n" if $debug;
                                push @distisolist, "$File::Find::name";
                                $missing=0;
                            }
                        },
                        follow => 1
                       },
                      $bdir{isos});
                if ($missing == 1) {
                    $missing = 0;
                    $halt = 1;
                    print "Missing required file $isofile\n";
                }
            }
        }
        $daisohr->{ $da }->{info} = $distisoinfo;
        push @{$daisohr->{ $da }->{list}}, @distisolist;
        print "verify:\n" . join( "\n", @distisolist ) . "\n" if ($debug > 1);
    }

    if ( $halt ) {
        print "Please use --isos to download missing files.\n";
        exit 1;
    }

    unless (($isos) || ($check)) {
        return $daisohr;
    }

    $halt = 0;
    foreach my $da ( @dalist ) {
        print "Verifing iso checksums for $da ...\n";            # print LONG
        foreach my $isofile ( @{$daisohr->{ $da }->{list}} ) {
            my $isoshort = $isofile;
            $isoshort =~ s|$bdir{isos}||;
            print $isoshort . " checksum in progress\n" if $debug;
            open(FILE, $isofile) or
                die "Can't open '$isofile': $!";
            binmode(FILE);
            my $md5 = Digest::MD5->new->addfile(*FILE)->hexdigest;
            chomp($md5);
            my $iname = basename( $isofile );
            my $storedmd5 = $daisohr->{$da}->{info}->{$iname}->{hash}->{md5};
            print "$isoshort : $md5 == $storedmd5 ?\n" if ($debug);
            if ( $md5 ne $storedmd5 ) {
                print "Bad md5sum for $isoshort\n";
                $halt=1;
            } elsif ( $verbose ) {
                print "Good md5sum for $isoshort\n";
            }
        }
    }
    if ( $halt ) {
        print  "Please remove file(s) with bad checksum and retry --isos\n";
        exit 1;
    }

    return $daisohr;
}

sub make_paths() {

    print "+++++ make_paths\n" if ( $debug > 1 );

    use File::Basename;

    my $distro  = shift;
    my $addons  = shift;
    my $daisohr = shift;

    #
    # $daisohr
    #   -> { $distro }                   # distro or addon name
    #     -> { 'list' } = @{$isofiles}   # isos found with complete pathing
    #     -> { 'info' }
    #       -> { $isoname }
    #         -> { 'path' } = "fulldir"  # where to extract isos and share
    #         -> { 'hash' }              # href to xml data
    #           -> { 'md5' } = md5sum
    #           -> { 'url' } = url
    #                                    # and for distro product base
    #           -> { 'kernel' } = linux  # relative path to loader
    #           -> { 'initrd' } = initrd
    #

    my @dalist;

    push @dalist, $distro if $distro;
    push @dalist, split( /\s+/, $addons) if ( $addons );

    ## Create /tmp/directory to mount iso files for copy
    ##
    my $tdir = tempdir( "baracus.XXXXXX", TMPDIR => 1, CLEANUP => 1 );
    print "using tempdir $tdir\n" if ($debug > 1);
    mkdir $tdir, 0755 || die ("Cannot create directory\n");
    chmod 0777, $tdir || die "$!\n";

    print "dalist: " . join( ' ', @dalist ) . "\n" if ( $debug > 1 );
    foreach my $da ( @dalist ) {
        foreach my $isofile ( @{$daisohr->{ $da }->{list}} ) {
            my $iname = basename( $isofile );
            print "$isofile and $iname\n" if ( $debug > 1 );
            my $idir  = $daisohr->{ $da }->{info}->{$iname}->{path};
            if ( -d $idir ) {
                print "$idir directory exists \n" if $debug;
            } else {
                if ($verbose) {
                    print "Creating Build Path $idir\n";
                }
                unless ( mkpath $idir ) {
                    $LASTERROR = "Unable to create directory\n$!";
                    return 1;
                }
                my ($isoshort, $idirshort) = ($isofile, $idir);
                $isoshort  =~ s|$bdir{isos}||;
                $idirshort =~ s|$bdir{isos}||;
                print "Extraction $isoshort to $idirshort\n";    # print LONG
                system( "mount -o loop $isofile $tdir" );
                system( "/usr/bin/rsync -azHl $tdir/* $idir" );
                system( "umount $tdir" );
            }
        }
    }

    print "removing tempdir $tdir\n" if ($debug > 1);
    rmdir $tdir;

    return 0;
}

###########################################################################

sub create_build
{
    print "+++++ create_build\n" if ( $debug > 1 );

    my $distro  = shift;

    my $dh = &baxml_distro_gethash( $distro );
    my $bh = $dh->{basedisthash};

    my $share = $bh->{basedistpath};

    return unless ( $distro eq $dh->{basedist} );

    # driverupdate fix for the aytoyast tftp last ACK
    # for i586/x86_64 sles10.2-11 - bnc 507086

    if ($distro =~ /sles-10\.2/ or $distro =~ /sles-11/) {
        my $driverupdate_in = "$bdir{'data'}/driverupdate";
        my $driverupdate_out = "$bh->{baseisopath}/driverupdate";
        if ( $debug ) {
            print "Installing driverupdate for sles 10.2 - 11\n";
            print "from $driverupdate_in\n";
            print "to $driverupdate_out\n";
        }

        my $addonstyle = "";

        # we are base - find any product with non-base addon style
        # and if that fails then addon then product then addon style
        foreach my $prod ( &baxml_products_getlist( $distro ) ) {
            my $ph = &baxml_product_gethash( $distro, $prod );
            if ( defined $ph->{'addon'} and $ph->{'addon'} ne "base" ) {
                $addonstyle = $ph->{'addon'};
            }
        }
        if ( not $addonstyle and $bh->{addons} ) {
            foreach my $addon ( @{$bh->{addons}} ) {
                foreach my $prod ( &baxml_products_getlist( $addon ) ) {
                    my $ph = &baxml_product_gethash( $addon, $prod );
                    if ( defined $ph->{'addon'} and $ph->{'addon'} ne "base" ) {
                        $addonstyle = $ph->{'addon'};
                    }
                }
            }
        }

        if ( $addonstyle ) {
            print "addon style is found to be: $addonstyle\n" if ( $debug > 1 );

            if ($addonstyle eq "flat") {
                if ( -f $driverupdate_out ) {
                    print "driverupdate already installed\n" if $verbose;
                } else {
                    print "$driverupdate_in => $driverupdate_out\n" if ( $debug );
                    copy( $driverupdate_in, $driverupdate_out );
                }
            } elsif ($addonstyle eq "signed") {

                use IO::File;
                # TODO - fix this for smoother sle11 installs - dhb

                # copy, sign, add to directory.yast list
                # copy( $driverupdate_in, $driverupdate_out );

                # $io = IO::File->new( "$driverupdate_out", 'r' );
                # $sha1->addfile($io);
                # $io->close;
                # print FILE $sha1->hexdigest, "  driverupdate\n";
                ;
            }
        }
    }

    if ($distro =~ /sles-9/) {
        my %yasthash;

        ## Create yast/instorder and yast/order

        my $first  = "Service-Pack";
        my $second = "SUSE-SLES";
        my $third  = "SUSE-CORE";

        my @order = ( $first, $second, $third );
        my @products = &baxml_products_getlist( $distro );


    PORDER: foreach my $product ( @products ) {
            for (my $count = 0; $count < 3; $count++ ) {
                print "ordering $product -- test $order[$count]\n" if $debug;
                if ( $product =~ m/$order[$count]/ ) {
                    $yasthash{ $order[$count] } = $product;
                    print "ordered $product -- $order[$count]\n" if $debug;
                    ++$count;
                    $yasthash{ $first  } = $product if ( $product =~ m/$first/  );
                    $yasthash{ $second } = $product if ( $product =~ m/$second/ );
                    $yasthash{ $third  } = $product if ( $product =~ m/$third/  );
                    next PORDER;
                }
            }
        }
        print "Creating ORDER files for sles-9\n$share/yast/instorder\n$share/yast/order\n" if $debug;
        mkpath "$share/yast" || die ("Cannot create yast directory\n");
        open(IORDER, ">$share/yast/instorder") || die ("Cannot open file\n");
        open(ORDER, ">$share/yast/order") || die ("Cannot open file\n");
        foreach my $order ( @order ) {
            if ( defined $yasthash{$order} ) {
                print IORDER "/$yasthash{$order}/CD1\n";
                print ORDER "/$yasthash{$order}/CD1\t/$yasthash{$order}/CD1\n";
            }
        }
        print IORDER "/\n";
        print ORDER "/\n";
        close(IORDER);
        close(ORDER);

        ## Create necessary links (this is sles9 logic)
        ##
        chdir($share);
        symlink("$yasthash{$second}/CD1/boot","boot");
        symlink("$yasthash{$second}/CD1/content","content");
        symlink("$yasthash{$second}/CD1/control.xml","control.xml");
        symlink("$yasthash{$second}/CD1/media.1","media.1");

        if ( defined $yasthash{$first} ) {
            symlink("$yasthash{$first}/CD1/linux","linux");
            symlink("$yasthash{$first}/CD1/driverupdate","driverupdate");
        } else {
            symlink("$yasthash{$second}/CD1/linux","linux");
            symlink("$yasthash{$second}/CD1/driverupdate","driverupdate");
        }
    }
}

sub streamline_install
{
    print "+++++ streamline_install\n" if ( $debug > 1 );
    my $distro = shift;

    my $licensefile;
    my $remove = 0;

    ## Need to make sure license acceptance does not interfere
    ## Remove license.zip or info.txt and associated entry in
    ## media.1/directory.yast
    ##
    if ($distro =~ /sles-10/ or $distro =~ /sles-11/) {
        $licensefile = "license.zip";
        $remove = 1;

    } elsif ($distro =~ /sles-9/) {
        ## Need to make sure license acceptance does not interfere
        ##
        $licensefile = "info.txt";
        $remove = 1;
    }

    if ( $remove ) {
        my $dh = &baxml_distro_gethash( $distro );
        print "streamline_install calling get_distro_share($distro)\n";
        my ($share,undef) = &get_distro_share( $distro );

        my @dyast;
        find ( { wanted =>
                 sub {
                     if ($_ eq $licensefile) {
                         print "Removed $File::Find::name\n" if ( $debug > 1 );
                         unlink("$File::Find::name");
                         push(@dyast, "$File::Find::dir/");
                     }
                 }
                },
               $share );
        foreach my $dyast (@dyast) {
            open(INFILE, "<$dyast/directory.yast") || die ("Cannot open file\n");
            my $contents = join '', <INFILE>;
            close(INFILE);
            $contents =~ s|$licensefile\s*\n||;
            open(OUTFILE, ">$dyast/directory.yast") || die ("Cannot open file\n");
            print OUTFILE $contents;
            close(OUTFILE);
        }
    }
}

#  called only if non-add-on ('requires' is *not* defined)

sub add_bootloader_files() {

    print "+++++ add_bootloader_files\n" if ( $debug > 1 );

    my $distro = shift;

    my $tdir = tempdir( "baracus.XXXXXX", TMPDIR => 1, CLEANUP => 1 );
    print "using tempdir $tdir\n" if ($debug > 1);
    mkdir $tdir, 0755 || die ("Cannot create directory\n");
    chmod 0777, $tdir || die "$!\n";

    my $dh = &baxml_distro_gethash( $distro );
    my $bh = $dh->{basedisthash};

    my $basedist = $dh->{basedist};
    if ( &sqlfs_getstate( "linux.$distro" ) ) {
        print "found bootloader linux.$basedist in tftp database\n" if $verbose;
    } else {
        copy($bh->{baselinux},"$tdir/linux.$basedist") or die "Copy failed: $!";
        &sqlfs_store( "$tdir/linux.$basedist" );
        unlink ( "$tdir/linux.$basedist" );
    }
    if( &sqlfs_getstate( "initrd.$basedist" ) ) {
        print "found bootloader initrd.$basedist in tftp database\n" if $verbose;
    } else {
        copy($bh->{baseinitrd},"$tdir/initrd.gz") or die "Copy failed: $!";
        if ( $distro =~ /sles-11/ ) {
            system("gunzip", "$tdir/initrd.gz");
            copy("$bdir{data}/gpghome/.gnupg/my-key.gpg", "$tdir/my-key.gpg") or
                     die "Copy failed: $!";
            my $result = `cd $tdir; find my-key.gpg | cpio --quiet -o -A -F initrd -H newc >> /dev/null`;
            unlink( "$tdir/my-key.gpg" );
            system("gzip", "$tdir/initrd");
        }
        copy("$tdir/initrd.gz", "$tdir/initrd.$basedist") or
            die "Copy failed: $!";
        unlink( "$tdir/initrd.gz" );

        &sqlfs_store( "$tdir/initrd.$basedist" );
        unlink( "$tdir/initrd.$basedist" );
    }

    print "removing tempdir $tdir\n" if ($debug > 1);
    rmdir $tdir;

    ## Create example pxelinux.cfg boot file
    ##
    open(PXEFILE, "<$bdir{'data'}/templates/pxelinux.template")
        or die "unable to open file: $!\n";
    my $pxe = join '', <PXEFILE>;
    close(PXEFILE);

    $pxe =~ s/%PXEID%/$distro/g;
    $pxe =~ s/%TYPE%/$buildtype/g;
    $pxe =~ s/%IP%/$buildip/g;
    if ( $distro =~ /sles-9/ ) {
        $pxe =~ s|%PATH%|$bh->{distpath}/|g;
    } else {
        $pxe =~ s|%PATH%|$bh->{baseprodpath}/|g;
    }

    # store won't overwrite ( $name, \$contentref, [ description ] )
    if ( &sqlfs_getstate( "template.$buildtype.$basedist" ) ) {
        print "found bootloader template.$buildtype.$basedist in tftp database\n" if $verbose;
    } else {
        &sqlfs_storeScalar( "template.$buildtype.$basedist", \$pxe );
    }
    # TODO:  perhaps create a menu of install sources to choose from
    # NOTE:  SqlFS is 'flat' so 'default' is only used for lookup match here
    unless ( &sqlfs_getstate( "default" ) ) {
        &sqlfs_storeScalar( "default", \$pxe, "template.$buildtype.$basedist" );
    }
}

sub remove_bootloader_files() {

    print "+++++ remove_bootloader_files\n" if ( $debug > 1 );

    my $distro = shift;

    my $dh = &baxml_distro_gethash( $distro );
    my $bh = $dh->{basehash};
    my $basedist = $dh->{basedist};

    if ( &sqlfs_getstate( "linux.$basedist" ) ) {
        &sqlfs_remove( "linux.$basedist" );
    }
    if ( &sqlfs_getstate( "initrd.$basedist" ) ) {
        &sqlfs_remove( "initrd.$basedist" );
    }

    foreach my $type ( "http", "nfs" ) {
        if ( &sqlfs_getstate( "template.$type.$basedist" ) ) {
            &sqlfs_remove( "template.$type.$basedist" );
        }
    }
}

################################################################################
# networking service handling

# add line or config file for build and restart service (only if neeeded)
sub add_build_service
{
    print "+++++ add_build_service\n" if ( $debug > 1 );
    my $distro = shift;
    my $addons = shift;

    my @dalist;

    push @dalist, $distro if $distro;
    push @dalist, split( /\s+/, $addons) if ( $addons );

    my $restartservice = 0;
    foreach my $da ( @dalist ) {

        foreach my $prod ( &baxml_products_getlist( $da ) ) {

            my ($file, $share, $state) =
                &check_service_product( $da, $prod, $buildtype );

            if ( $state ) {
                print "$buildtype file $file found added for $da\n" if $verbose;
            }
            else {
                print "modifying $file adding $share\n" if ( $debug );

                $restartservice = 1;

                if ($buildtype eq "nfs") {
                    open(FILE, ">>$file") || die ("Cannot open $file\n$!");
                    print FILE "$share\t*(ro,root_squash,insecure,sync,no_subtree_check)\n";
                    close(FILE);
                }

                if ($buildtype eq "http") {
                    open(FILE, "<$bdir{'data'}/templates/inst_server.conf.in") or
                        die ("Cannot open file\n");
                    my $httpdconf = join '', <FILE>;
                    close(FILE);

                    unless ( -d "/etc/apache2/conf.d/") {
                        mkpath "/etc/apache2/conf.d/" || die ("Cannot create directory\n");
                    }

                    open(FILE, ">$file") || die ("Cannot open $file\n");
                    $httpdconf =~ s|%OS%|$da|g;
                    $httpdconf =~ s|%ALIAS%|/install/$da/|g;
                    $httpdconf =~ s|%SERVERDIR%|$share/|g;
                    print FILE $httpdconf;
                    close(FILE);

                }
            }
        }
    }
    if ( $restartservice ) {
        if ($buildtype eq "nfs") {
            system("/usr/sbin/exportfs -r");
        }
        if ($buildtype eq "http") {
            system("/etc/init.d/apache2 reload");
        }
    }
}

# add line or config file for build and restart service (only if neeeded)
sub remove_build_service
{
    print "+++++ remove_build_service\n" if ( $debug > 1 );
    my $distro = shift;
    my $addons = shift;

    my @dalist;

    push @dalist, $distro if $distro;
    push @dalist, split( /\s+/, $addons) if ( $addons );

    my $restartservice = 0;
    foreach my $da ( @dalist ) {

        foreach my $prod ( &baxml_products_getlist( $da ) ) {

            my ($file, $share, $state) =
                &check_service_product( $da, $prod, $buildtype );

            if ( not $state ) {
                print "$buildtype file $file found removed for $da\n" if $verbose;
            } else {
                print "modifying $file removing $share\n" if ( $debug );

                $restartservice = 1;

                if ($buildtype eq "nfs") {
                    copy("/etc/exports", "/etc/exports.bak");
                    open(OUTFILE, ">/etc/exports") || die ("Cannot open file\n");
                    open(INFILE, "</etc/exports.bak") || die ("Cannot open file\n");
                    while (<INFILE>) {
                        unless (m|$share|) {
                            print OUTFILE $_;
                        }
                    }
                    close(INFILE);
                    close(OUTFILE);
                    unlink("/etc/exports.bak");
                }

                if ($buildtype eq "http") {
                    unlink( $file );
                }
            }
        }
    }
    if ( $restartservice ) {
        if ($buildtype eq "nfs") {
            system("/usr/sbin/exportfs -r");
        }
        if ($buildtype eq "http") {
            system("/etc/init.d/apache2 reload");
        }
    }
}

# return filename and state 0-missing 1-found for service config mods
sub check_service_product
{
    print "+++++ check_serviceconfig\n" if ( $debug > 1 );
    my $distro    = shift;
    my $product   = shift;
    my $type      = shift;

    my $dh = &baxml_distro_gethash( $distro );

    my ($share, $name) = &get_distro_share( $distro );

    my $file;
    my $state = 0;

    if ($type eq "nfs") {
        $file = "/etc/exports";
        if ( -f $file ) {
            open(FILE, "<$file") or die ("Cannot open $file\n$!");
            while (<FILE>) {
                if (m|$share|) {
                    $state = 1;
                }
            }
            close(FILE);
        }
    }
    if ($type eq "http") {
        $file = "/etc/apache2/conf.d/$name.conf";
        $state = 1 if ( -f $file);
    }

    return $file, $share, $state;
}

sub enable_service() {

    print "+++++ enable_service\n" if ( $debug > 1 );
    my $type = shift @_;

    if ($verbose) {
        print "Enabling $type ... \n";
    }
    $type =~ s/http/apache2/;
    $type =~ s/nfs/nfsserver/;
    system("chkconfig $type on");
    system("/etc/init.d/$type start")
}

sub disable_service() {

    print "+++++ disable_service\n" if ( $debug > 1 );
    my $type = shift @_;

    ## Disable service
    ##
    if ($verbose) {
        print "Disabling $type ... \n";
    }
    $type =~ s/http/apache2/;
    $type =~ s/nfs/nfsserver/;
    system("chkconfig $type off");
    system("/etc/init.d/$type stop");
}

# status returns 0 if enabled
sub check_service() {
    print "+++++ check_service\n" if ( $debug > 1 );
    my $type = shift @_;

    $type =~ s/http/apache2/;
    $type =~ s/nfs/nfsserver/;
    system("/etc/init.d/$type status >& /dev/null");
}

###########################################################################
# sqlfsOBJ - sqlfstable - tftp db

# lookup file - 0 missing, 1 enabled, 2 disabled
sub sqlfs_getstate
{
    my $file = shift;
    my $state = 0;
    print "setting uid to $dbrole\n" if ($debug > 2);
    $uid = BaracusDB::su_user( $dbrole );

    my $sel = $sqlfsOBJ->detail( $file );
    if ( defined $sel ) {
        if ( $sel->{'enabled'} ) {
            $state = 1;
        } else {
            $state = 2;
        }
    }
    print "setting uid back to $uid\n" if ($debug > 2);
    $> = $uid;

    return $state;
}

# store a file located on disk
sub sqlfs_store
{
    my $file = shift;
    my $status = 0;
    print "setting uid to $dbrole\n" if ($debug > 2);
    $uid = BaracusDB::su_user( $dbrole );
    $status = $sqlfsOBJ->store( $file );
    if ( $status ) {
        warn "Store failed to store $file in sqlfs\n";
    }
    print "setting uid back to $uid\n" if ($debug > 2);
    $> = $uid;
    return $status;
}

# store contents of scalar var ref
sub sqlfs_storeScalar
{
    my $file = shift;
    my $ref  = shift;
    my $desc = shift;

    my $status = 0;
    print "setting uid to $dbrole\n" if ($debug > 2);
    $uid = BaracusDB::su_user( $dbrole );
    $status = $sqlfsOBJ->storeScalar( $file, $ref, $desc );
    if ( $status ) {
        warn "StoreScalar failed to store $file in sqlfs\n";
    }
    print "setting uid back to $uid\n" if ($debug > 2);
    $> = $uid;
    return $status;
}

# remove a file located in sqlfs tftp relation
sub sqlfs_remove
{
    my $file = shift;
    my $status = 0;
    print "setting uid to $dbrole\n" if ($debug > 2);
    $uid = BaracusDB::su_user( $dbrole );
    $status = $sqlfsOBJ->remove( $file );
    if ( $status ) {
        warn "Unable to remove $file from sqlfs\n";
    }
    print "setting uid back to $uid\n" if ($debug > 2);
    $> = $uid;
    return $status;
}

###########################################################################
# distro_cfg - basource state relation

sub source_register() {

    print "+++++ source_register\n" if ( $debug > 1 );
    my $command = shift;
    my $distro  = shift;
    my $addons  = shift;

    print "setting uid to $dbrole\n" if ($debug > 2);
    $uid = BaracusDB::su_user( $dbrole );

    if ($command eq "add") {

        my @dalist;

        push @dalist, $distro if $distro;
        push @dalist, split( /\s+/, $addons) if ( $addons );

        foreach my $da ( @dalist ) {
            print "Updating registration: add $da\n";
            my $dbref = &get_db_source_entry( $da );
            unless ( defined $dbref->{distroid} and
                     ( $dbref->{distroid} eq $da ) and
                     defined $dbref->{staus} and
                     ( $dbref->{staus} != BaracusSql::BA_DELETED ) ) {
                &add_db_source_entry( $da );
            }
        }
    }

    elsif ($command eq "remove") {

        print "Updating registration: remove $distro\n";
#        my $sql = q|DELETE FROM sqlfstable_reg
#                    WHERE distro=?|;

        my $sql = q|UPDATE distro_cfg
                    SET change=CURRENT_TIMESTAMP(0),
                        status=?
                    WHERE distroid=?|;

        my $sth = $dbh->prepare( $sql )
            or die "Cannot prepare sth: ",$dbh->errstr;

        my @dalist;

        push @dalist, $distro if $distro;
        push @dalist, split( /\s+/, $addons) if ( $addons );

        foreach my $da ( @dalist ) {
            $sth->execute( BaracusSql::BA_DELETED, $da )
                or die "Cannot execute sth: ", $sth->errstr;
        }

    }

    elsif ($command eq "disable") {

        print "Updating registration: disable $distro\n";

#        my $sql = q|UPDATE sqlfstable_reg
#                    SET modify_date=CURRENT_TIMESTAMP(0),
#                        status=?
#                    WHERE distro=?|;

        my $sql = q|UPDATE distro_cfg
                    SET change=CURRENT_TIMESTAMP(0),
                        status=?
                    WHERE distroid=?|;

        my $sth = $dbh->prepare( $sql )
            or die "Cannot prepare sth: ",$dbh->errstr;

        $sth->execute( BaracusSql::BA_DISABLED, $distro )
            or die "Cannot execute sth: ", $sth->errstr;

    }

    elsif ($command eq "enable") {

        print "Updating registration: enable $distro\n";

#        my $sql = q|UPDATE sqlfstable_reg
#                    SET modify_date=CURRENT_TIMESTAMP(0),
#                        status=?
#                    WHERE distro=?|;

        my $sql = q|UPDATE distro_cfg
                    SET change=CURRENT_TIMESTAMP(0),
                        status=?
                    WHERE distroid=?|;

        my $sth = $dbh->prepare( $sql )
            or die "Cannot prepare sth: ",$dbh->errstr;

        $sth->execute( BaracusSql::BA_READY, $distro )
            or die "Cannot execute sth: ", $sth->errstr;

    }

    else {
        $LASTERROR = "Incorrect subcommand passed for source register\n";
        return 1;
    }

    print "setting uid back to $uid\n" if ($debug > 2);
    $> = $uid;

    return 0;
}

sub get_db_source_entry() {

    my $distro = shift;

    my $sql = q|SELECT distroid,
                       buildip,
                       type,
                       basepath,
                       status,
                       creation,
                       change
                FROM distro_cfg
                WHERE distroid = ?|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute($distro)
        or die "Cannot execute sth: ",$sth->errstr;

    my $href = $sth->fetchrow_hashref();

    $sth->finish;
    undef $sth;

    return $href;

}

sub add_db_source_entry() {

    my $distro = shift;

    print "Registering source: $distro $buildip $bdir{root} $buildtype\n"
        if ($verbose);

    my $sql;
    my $sth;

    my $dh = &baxml_distro_gethash( $distro );

    my ($share,undef) = get_distro_share( $distro );

    my $dbref = &get_db_source_entry( $distro );

    if ( defined $dbref ) {
        $sql = q|UPDATE distro_cfg
                 SET creation=CURRENT_TIMESTAMP(0),
                     change=NULL,
                     buildip=?,
                     type=?,
                     basepath=?,
                     status=?
                 WHERE distroid=?|;

        $sth = $dbh->prepare( $sql )
            or die "Cannot prepare sth: ",$dbh->errstr;

        $sth->bind_param( 1, $buildip    );
        $sth->bind_param( 2, $buildtype  );
        $sth->bind_param( 3, $share      );
        $sth->bind_param( 4, BaracusSql::BA_READY );
        $sth->bind_param( 5, $distro     );

        $sth->execute()
            or die "Cannot execute sth: ", $sth->errstr;
    } else {
        $sql = q|INSERT INTO distro_cfg ( distroid,
                                          os,
                                          release,
                                          arch,
                                          description,
                                          addon,
                                          addos,
                                          addrel,
                                          buildip,
                                          type,
                                          basepath,
                                          status,
                                          creation,
                                          change,
                                        )
                 VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                          CURRENT_TIMESTAMP(0), NULL ) |;

        $sth = $dbh->prepare( $sql )
            or die "Cannot prepare sth: ",$dbh->errstr;

        $sth->bind_param( 1, $distro        );
        $sth->bind_param( 2, $dh->{os}      );
        $sth->bind_param( 3, $dh->{release} );
        $sth->bind_param( 4, $dh->{arch}    );
        $sth->bind_param( 5, $dh->{description} );
        if ( defined $dh->{addos} and $dh->{addos} ) {
            $sth->bind_param( 6, 1 );
            $sth->bind_param( 7, $dh->{addos} );
            if ( defined $dh->{addrel} and $dh->{addrel} ) {
                $sth->bind_param( 8, $dh->{addrel} );
            } else {
                $sth->bind_param( 8, 'NULL' );
            }
        } else {
            $sth->bind_param( 6, 0 );
            $sth->bind_param( 7, 'NULL' );
            $sth->bind_param( 8, 'NULL' );
        }
        $sth->bind_param( 9,  $buildip    );
        $sth->bind_param( 10, $buildtype  );
        $sth->bind_param( 11, $share      );
        $sth->bind_param( 12, BaracusSql::BA_READY );

        print "dist $distro os $dh->{os} rel $dh->{release} arch $dh->{arch} desc $dh->{description} addos $dh->{addos} addrel $dh->{addrel} ip $buildip type $buildtype share $share\n";
        $sth->execute()
            or die "Cannot execute sth: ", $sth->errstr;
    }
}

sub get_distro_sdk
{
    my $distro = shift;

    my $dh = &baxml_distro_gethash( $distro );
    unless ( defined $dh->{basedisthash}->{addons} ) {
        return undef;
    }

    my @addons = @{$dh->{basedisthash}->{addons}};

    foreach my $addon ( @addons ) {
        return $addon if ($addon =~ /\-sdk\-/);
    }
    return undef;
}

sub get_distro_share
{
    my $distro = shift;

    my $share;
    my $name;

    # collapse multi prod sles-9 down to
    # os/release/arch

    # all other shares have one installable product
    # os/release/arch[/addos[/addrel]]/product

    if ( $distro =~ /sles-9/ ) {
        my $dh = &baxml_distro_gethash( $distro );
        $share = $dh->{basedisthash}->{distpath};
        $name  = "$dh->{basedist}_server";
    }
    elsif ( $distro =~ /opensuse-11.1/ ) {
        my $dh = &baxml_distro_gethash( $distro );
        $share = $dh->{basedisthash}->{distpath};
        $name  = "$dh->{basedist}_server";
    }
    else {
        my @prods = &baxml_products_getlist( $distro );
        if ( scalar @prods > 1 ) {
            die "get_distro_share: Unsure how to handle multiple product distro $distro\n";
        }
        my $ph = &baxml_product_gethash( $distro, $prods[0] );
        $share = $ph->{prodpath};
        $name = "$distro-$prods[0]_server";
    }
    print "get_distro_share: returning share $share and name $name\n" if $debug;
    return ($share, $name);
}

sub list_installed_addons
{
    my $distro = shift;
    my @list;

    my $dh = &baxml_distro_gethash( $distro );
    my $bh = $dh->{basedisthash};
    my $base = $dh->{basedist};

    foreach my $dist ( @{$bh->{addons}} ) {
        print "is distro $base addon $dist 'added' ? " if $debug;
        my $dbref = &get_db_source_entry( $dist );
        if ( defined $dbref and defined $dbref->{status} and
             ( $dbref->{distroid} eq $dist ) and
             ( $dbref->{status} != BaracusSql::BA_DELETED ) ) {
            print "YES\n" if $debug;
            push @list, $dist;
        } else {
            print "NO\n" if $debug;
        }
    }
    return @list;
}

###########################################################################

# this arg handling will parse many variations
# --module=doOne,doTwo --module doThree --module "doFour,doFive doSix"
# --vars=doOne=hey,doTwo=there --vars "doThree=love,doFour=or doFive=not"
sub multiarg_handler() {
    my $option = $_[0];
    my $value  = $_[1];
    my @values;
    if ( $value ne '' ) {
        # arg specified - push into array
        @values = split(/[,\s*]/,$value);
    } else {
        # no value profided and no defaults
        # with ':s' should not get here
        # we could 'die("FINISH")'
        # but for now just return
        @values = ( $buildtype, "dhcpd" );
    }
    foreach $value (@values) {
        $value = lc $value;
        if ( $option eq "vars" ) {
            # special check for key=value assignment syntax
            die("FINISH") if ( $value !~ m/=/ );
        }
        if (not defined $multiarg{ $option } ){
            # initialize
            $multiarg{ $option } = "$value";
        }
        elsif ( $multiarg{ $option } !~ m/$value/ ) {
            # append if not already present
            $multiarg{ $option } .= " $value";
        }
    }
}

###########################################################################
#
#  xml config helpers - for more formatting info refer to
#
#      /usr/share/baracus/badistro.xml
#      /usr/share/baracus/perl/badistro_check_xml.pl

#
#  All baxml_* helpers try to abstract the deep referencing of the
#  xml.  The goals are to contain the required code changes, if the
#  xml is modified, to these subroutines (probably have not achieved
#  this goal yet), and to reduce typo or incorrect referencing.
#  perhaps a module interface next release. dhb
#

# returns an array of distro names
sub baxml_distros_getlist
{
    return keys %{$xml->{'distro'}};
}

# returns a hash reference to the distro attribs
sub baxml_distro_gethash
{
    return $xml->{'distro'}->{$_[0]};
}

# returns an array of product names for the given distro
sub baxml_products_getlist
{
    return keys %{$xml->{'distro'}->{$_[0]}->{'product'}};
}

# returns a hash reference to the distro's product attribs
sub baxml_product_gethash
{
    return $xml->{'distro'}->{$_[0]}->{'product'}->{$_[1]};
}

# returns an array of product names for the given distro
sub baxml_isos_getlist
{
    return keys %{$xml->{'distro'}->{$_[0]}->{'product'}->{$_[1]}->{'iso'}};
}

# returns a hash reference to the distro's product's iso attribs
sub baxml_iso_gethash
{
    return $xml->{'distro'}->{$_[0]}->{'product'}->{$_[1]}->{'iso'}->{$_[2]};
}

sub baxml_load
{
    use XML::Simple;

    my $xmlfile = shift;

    my $xs = XML::Simple->new ( SuppressEmpty => 1,
                                ForceArray => [ qw (distro product iso) ],
                                KeyAttr => { distro => 'name',
                                             product => 'name',
                                             iso => 'name' } );
    my $xml = $xs->XMLin( $xmlfile );

    # sanity checking
    # and promote some items to base for direct access
    # and other helper info to struct just created by xml

    print "XML post-processing xml struct\n" if ($debug > 2);
    foreach my $distro ( keys %{$xml->{distro}} ) {
        my $dh = $xml->{distro}->{$distro};
        my @baseparts = ( $dh->{os}, $dh->{release}, $dh->{arch} );
        $dh->{basedist} = join "-", @baseparts;
        unless ( $xml->{distro}->{ $dh->{basedist} } ) {
            die "Malformed $xmlfile\nMissing entry for distro $dh->{basename} required by $distro\n";
        }
        print "XML working with distro $distro\n" if ($debug > 2);
        $dh->{basedisthash} = $xml->{distro}->{ $dh->{basedist} };
        $dh->{distpath} = join "/", $bdir{'builds'}, @baseparts;
        if ( defined $dh->{'requires'} ) {
            if ( $distro eq $dh->{basedist} ) {
                die "Malformed $xmlfile\nAdd-on $distro (has 'requires') only has base components as part of its name\n";
            }
            print "XML distro is addon for base $dh->{basedist}\n" if ($debug > 2);
            $dh->{distpath} = join "/", $dh->{distpath}, $dh->{addos};
            $dh->{distpath} = join "/", $dh->{distpath}, $dh->{addrel}
                if ( defined $dh->{addrel} );

            # append distro to base addons list
            print "XML add $distro to $dh->{basedist} addon array\n"
                if ($debug > 2);
            push @{$dh->{basedisthash}->{addons}}, $distro;
        } elsif ( $dh != $dh->{basedisthash}) {
            die "non-addon $distro hash $dh not equal to $dh->{basedisthash} ?!\n";
        }
        print "XML distro path $dh->{distpath}\n" if ($debug > 2);
        # every non-addon distro needs one product of addon type "base"
        my $basefound = 0;
        $basefound = 1 if ( defined $dh->{'requires'} ); # spoof check for addons
        # a distro with base product needs one iso with "kernel" and "initrd"
        my $loaderfound = 1;
        foreach my $product ( keys %{$dh->{product}} ) {
            my $ph = $dh->{product}->{$product};
            $ph->{prodpath} = join "/", $dh->{distpath}, $product;
            print "XML working with product $product\n" if ($debug > 2);
            print "XML product path $ph->{prodpath}\n" if ($debug > 2);
            if ( defined $ph->{'addon'} and $ph->{'addon'} eq "base" ) {
                if ( $basefound ) {
                    die "Malformed $xmlfile\nDistro $distro has more than one product with <addon>base</addon>\n";
                }
                $basefound = 1;
                $loaderfound = 0;
                $dh->{baseprod} = $product;
                $dh->{baseprodhash} = $ph;
                $dh->{baseprodpath} = join "/", $bdir{'builds'}, @baseparts,
                    $product;
                print "XML base prod path $dh->{baseprodpath}\n" if ($debug > 2);
            }
            foreach my $iso ( keys %{$ph->{iso}} ) {
                my $ih = $ph->{iso}->{$iso};
                $ih->{isopath} = $ph->{prodpath};
                $ih->{isopath} = join "/", $ih->{isopath}, $ih->{'path'}
                    if ( defined $ih->{'path'} );
                print "XML iso path $ih->{isopath}\n" if ($debug > 2);
                if ( defined $ih->{'kernel'} and defined $ih->{'initrd'} ) {
                    if ( $loaderfound ) {
                        die "Malformed $xmlfile\nDistro $distro product $product has more than one iso with <kernel> and <initrd>\n";
                    }
                    $loaderfound = 1 ;
                    $dh->{baseiso} = $iso;
                    $dh->{baseisohash} = $ih;
                    $dh->{baseisopath} = $ih->{isopath};
                    $dh->{baselinux}  = join "/", $ih->{isopath}, $ih->{kernel};
                    $dh->{baseinitrd} = join "/", $ih->{isopath}, $ih->{initrd};
                    print "XML base iso path $dh->{baseisopath}\n" if ($debug > 2);
                    print "XML $dh->{baselinux}\n" if ($debug > 2);
                    print "XML $dh->{baseinitrd}\n" if ($debug > 2);
                }
            }
            unless ( $loaderfound ) {
                die "Malformed $xmlfile\nEntry $distro base $product is missing an iso containing both <kernel> and <initrd>\n";
            }
        }
        unless ( $basefound ) {
            die "Malformed $xmlfile\nEntry $distro is missing a product containing <addon>base</addon>\n";
        }
    }

    return $xml;
}

######################################################################

die "ABSOLUTELY DOES NOT EXECUTE";

__END__
