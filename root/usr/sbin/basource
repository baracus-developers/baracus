#!/usr/bin/perl -w

###########################################################################
#
# Baracus build and boot management framework
#
# Copyright (C) 2010 Novell, Inc, 404 Wyman Street, Waltham, MA 02451, USA.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the Artistic License 2.0, as published
# by the Perl Foundation, or the GNU General Public License 2.0
# as published by the Free Software Foundation; your choice.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Both the Artistic
# Licesnse and the GPL License referenced have clauses with more details.
#
# You should have received a copy of the licenses mentioned
# along with this program; if not, write to:
#
# FSF, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110, USA.
# The Perl Foundation, 6832 Mulderstraat, Grand Ledge, MI 48837, USA.
#
###########################################################################

use strict;

use Getopt::Long qw( :config pass_through );
use Pod::Usage;
use File::Find;
use File::Path;

use lib "/usr/share/baracus/perl";

use SqlFS;
use BaracusDB;
use BaracusCore   qw( :subs );
use BaracusConfig qw( :vars :subs );
use BaracusState  qw( :vars :admin );
use BaracusSource qw( :vars :subs );


=pod

=head1 NAME

B<basource> - baracus tool to manage the retrival of distro isos and creation of network install sources

=head1 SYNOPSIS

B<basource> E<lt>commandE<gt> [options and arguments]

Where E<lt>commandE<gt> is

Where command is one of

    add     --distro <x>  Add a new build source for distribution <x>
    remove  --distro <x>  Remove <x> as a build source
    update  --distro <x>  Update sharetype and/or shareip for distribution <x>
    disable --distro <x>  Diable a build source for distribution <x>
    enable  --distro <x>  Enable a build source for distribution <x>
    verify  --distro <x>  Verify build source for distribution <x>
    detail  --distro <x>  Display specifics about a distribution

    list [base|addon] [--distro <x>] [--all] List known distros

    service --start       Start defaults [ SHARE_TYPE and dhcpd ]
    service --stop        Stop defaults [ SHARE_TYPE and dhcpd ]
    service --start <y>   Start specified service(s) (nfs,http,dhcpd)
    service --stop  <y>   Stop specified service(s) (nfs,http,dhcpd)

    help      This 'Usage' summary message.
    man       Detailed man page.

Use 'man' or 'help <command>' for more details.

=head1 DESCRIPTION

This tool assists with the downloading of distribution iso files, the creation of network install sources for those distributions, and the management of those network services and related control files.

=head1 OPTIONS

=over 4

=item -v --verbose Be verbose with output

=back

=cut

my $man  = 0;
my $help = 0;

my $cmds = {
            'add'      => \&add,
            'remove'   => \&remove,
            'update'   => \&update,
            'enable'   => \&enable,
            'disable'  => \&disable,
            'verify'   => \&verify,
            'list'     => \&list,
            'detail'   => \&detail,
            'init'     => \&init,
            'service'  => \&service,
            };

my $opts = {
            verbose    => 0,
            quiet      => 0,
            all        => 0,
            nolabels   => 0,
            debug      => 0,
            execname   => "",
            LASTERROR  => "",
            };

# Build command line for help, historical reference and point-in-time rebuilding
$opts->{execname} = $0;
$opts->{execname} = $1 if ( $0 =~ m|^.*/([^/].+)| );

GetOptions(
           'verbose'   => \$opts->{verbose},
           'quiet'     => \$opts->{quiet},
           'all'       => \$opts->{all},
           'nolabels'  => \$opts->{nolabels},
           'debug+'    => \$opts->{debug},
           'man'       => \$man,
           'help|?'    => \$help,
           );

&man()  if $man;
&help( $opts, $cmds ) if $help;
&help( $opts, $cmds ) unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &man(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &help( $opts, $cmds, @ARGV ); }

# wait till here to barf on this so help is available even with bad sysconfig
unless ($baVar{serverip}) {
    print "Please edit /etc/sysconfig/baracus and set SERVER_IP=<server>\n";
    exit 1;
}

my $dbname = "baracus";
my $dbrole = $dbname;

my $dbtftp = "sqltftp";

print "setting uid to $dbrole\n" if ($opts->{debug} > 2);

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

print "basource debug=$opts->{debug}\n" if $opts->{debug};
my $deepdebug = $opts->{debug} > 2 ? 1 : 0;
my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=$dbtftp;port=5162",
                           'User' => "baracus",
                           'debug' => $deepdebug )
    or die "Unable to create new instance of SqlFS\n";

# connected as baracus - continue as root
# and swithc to baracus as needed in subroutines
print "setting uid back to $uid\n" if ($opts->{debug} > 2);
$> = $uid;

my $baXML = &baxml_load( $opts, "$baDir{'data'}/badistro.xml" );

$opts->{dbh}      = $dbh;
$opts->{dbrole}   = $dbrole;
$opts->{sqlfsOBJ} = $sqlfsOBJ;
$opts->{baXML}    = $baXML;

my $status;
# sidestep list of cmds - provide
if ( $ARGV[0] eq "prepdbwithxml" ) {
    # unadvertised method to initialize distro relations
    $status = &prepdbwithxml( $opts );
} elsif ( $ARGV[0] eq "purgedbofxml" ) {
    # unadvertised method to purge distro relations
    $status = &purgedbofxml( $opts );
} else {
    $status = &main( $opts, $cmds, @ARGV );
}
$sqlfsOBJ->discard();

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

print $opts->{LASTERROR} if $status;

exit $status;

die "DOES NOT EXECUTE\n";

###########################################################################


=head1 COMMANDS

=head2 add --distro <name> [--addon <addos> [--addon ...]] [--check|--isos [--proxy]]

Where

  --distro <name>  specifies the full name of the base distribution
                   to use, e.g., sles-11-x86_64, sles-10.2-x86_64,
                   opensuse-11.1-x86

  --addon <name>   specifies any addon(s) to layer over the base
                   distribution sles-10.2-rt-x86_64, sles-11-ha-x86

  --no-loopback    Force source trees to be synced to local directory
  --check          Force check of the ISOs already present
  --isos           Download missing ISO files
  --proxy          Use a proxy service to fetch the ISO files

=cut

sub add() {

    my $command = 'add';
    my $distro = "";
    my $addons = "";
    my $proxy;
    my $check;
    my $isos;
    my $loopback = 1;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addons=s'  => \&multiarg_handler,
               'proxy'     => \$proxy,
               'check'     => \$check,
               'isos|i'    => \$isos,
               'loopback!'  => \$loopback,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $addons = $multiarg{ 'addons' } if (defined $multiarg{ 'addons' });

    ## Test if selection is valid
    ##
    $distro = lc $distro;
    &check_distro( $opts, $distro );

    if ( $addons ) {
        print "Calling routine to verify addon(s) passed\n";
        return 1 if &check_addons( $opts, $distro, $addons );
    }

    my $sdk = get_distro_sdk( $opts, $distro );
    # do we have an sdk for this base
    if ( defined $sdk ) {
        if ( not $addons ) {
            # no other addons specified
            $addons = $sdk;
        }
        elsif ( not $addons =~ m/$sdk/ ) {
            # add sdk not specified in addons
            $addons = "$sdk " . $addons;
        }
    }
    my $checkhr = {};
    if ( $isos ) {
        return 1 if &download_iso( $opts, $distro, $addons, $proxy, $checkhr );
    }

    print "Calling routine to locate ISO files\n";

    my $daisohr = &verify_iso( $opts, $distro, $addons, $isos, $check, $checkhr );

    print "Calling routines to generate build tree\n";
    &make_paths( $opts, $distro, $addons, $daisohr, $loopback);

    &create_build( $opts, $distro );

    unless ( $loopback ) { &streamline_install( $opts, $distro, $loopback ); }

    print "Calling routine to configure $baVar{sharetype}\n";

    &add_build_service( $opts, $distro, $addons );

    print "Calling routine to configure bootloader\n";
    &add_bootloader_files( $opts, $distro );

    &source_register( $opts, $command, $distro, $addons );
}

=head2 update --distro <name> [--addon <addos> [--addon ...]] [ --all ]

Where

  --distro <name>  specifies the full name of the base distribution
                   to update, e.g., sles-11-x86_64, sles-10.2-x86_64,
                   opensuse-11.1-x86

  --addon <name>   specifies the addon(s) to be updated. like these
                   distributions sles-10.2-rt-x86_64, sles-11-ha-x86

  --all            update all the addons and the base distro.

Without specifying --all, update will not update the base distro if it has any addons present so that a two step update process must be used to first update all the addons listed for the base distro and then another invocation with the base --distro alone.

=cut

sub update() {

    my $command = 'update';
    my $distro;
    my $addons = "";
    my @addons;
    my $sharetype = "";
    my $shareip = "";
    my $dbref;
    my $ret = 0;

    @ARGV = @_;

    GetOptions(
               'distro=s'    => \$distro,
               'addons=s'    => \&multiarg_handler,
               'sharetype=s' => \$sharetype,
               'shareip=s'   => \$shareip,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    ## Test if selection is valid
    ##
    $distro = lc $distro;
    &check_distro( $opts, $distro );

    unless (( $shareip ne "" ) || ( $sharetype ne "" ))  {
        $opts->{LASTERROR} = "update requires either --sharetype or --shareip\n";
        return 1;
    }

    $addons = $multiarg{ 'addons' } if (defined $multiarg{ 'addons' });

    if ( $opts->{all} and $addons ) {
            $opts->{LASTERROR} = "Unsafe mix of --all and --addon <addon> usage\n";
            return 1;
    }

    if ( $sharetype ne "") {
        unless (( $sharetype eq "nfs" ) || ( $sharetype eq "http" )) {
            $opts->{LASTERROR} = "$sharetype not valid. (supported types: nfs/http) \n";
            return 1;
        }
    }

    if ( $opts->{all} ) {
        my $dh =  &baxml_distro_gethash( $opts, $distro );
        @addons = @{$dh->{basedisthash}->{addons}};
        $addons = join " ", @addons;
        print "working with 'all': $addons\n" if $opts->{debug};
    } else {
        @addons = split( /\s+/, $addons );

        # only check addons passed if not removing all
        if ( scalar @addons ) {
            print "Calling routine to verify addon(s) passed\n";
            return 1 if &check_addons( $opts, $distro, $addons );
        }
    }

    if ( scalar @addons ) {
        foreach my $addon ( @addons ) {
            my @shares;
            print "Updating addon $addon\n";
            if ( $sharetype ne "" ) {
                $dbref = &get_db_source_entry( $opts, $addon );
                &remove_build_service( $opts, $addon );
                &update_db_source_entry( $opts, $sharetype, "", $addon);
                &update_db_iso_entry( $opts, $addon, $sharetype );
          #      &remove_build_service( $opts, $addon );
                &add_build_service( $opts, $addon );
                print "$sharetype ... Updated\n" if $opts->{verbose};
            }
            if ( $shareip ne "" ) {
                print "Update ShareIP\n";
                &update_db_source_entry( $opts, "", $shareip, $addon);
            }
        }
    }

    # only remove base if no addons specified or --all passed
    if ( not scalar @addons or $opts->{all} ) {
        my $dh = &baxml_distro_gethash( $opts, $distro );

        # need to check if updating base which has dependent add-ons
        my @addons = &list_installed_addons( $opts, $distro );

        # handle default 'unspecified' sdk as transparent member of base
        my $sdk = &get_distro_sdk( $opts, $distro );

        if ( ( scalar @addons > 1 ) or
             ( scalar @addons and not defined $sdk ) or
             ( scalar @addons and $addons[0] ne $sdk ) ) {
             $opts->{LASTERROR} = "Update these addons before Updating $distro (or use --all)\n\t" . join ("\n\t", @addons ) . "\n";
             return 1;
        }
        if ( scalar @addons and defined $sdk and $addons[0] eq $sdk ) {
            if ( $sharetype ne "" ) {
                $dbref = &get_db_source_entry( $opts, $sdk );
                &remove_build_service( $opts, $sdk );
                &update_db_source_entry( $opts, $sharetype, "", $sdk);
                &update_db_iso_entry( $opts, $sdk, $sharetype );
               # &remove_build_service( $opts, $sdk );
                &add_build_service( $opts, $sdk );
                print "$sharetype ... updated\n" if $opts->{verbose};
            }
            if ( $shareip ne "" ) {
                print "Update ShareIP\n";
                &update_db_source_entry( $opts, "", $shareip, $sdk);
            }
        }
        if ( $sharetype ne "" ) {
            $dbref = &get_db_source_entry( $opts, $distro );
            &remove_build_service( $opts, $distro );
            &update_db_source_entry( $opts, $sharetype, "", $distro );
            &update_db_iso_entry( $opts, $distro, $sharetype );
   #         &remove_build_service( $opts, $distro );
            &add_build_service( $opts, $distro );
            print "$sharetype ... updated\n" if $opts->{verbose};
        }
        if ( $shareip ne "" ) {
                print "Update ShareIP\n";
                 &update_db_source_entry( $opts, "", $shareip, $distro );
        }
    }

    return 0;

}

=head2 remove --distro <name> [--addon <addos> [--addon ...]] [ --all ]

Where

  --distro <name>  specifies the full name of the base distribution
                   to remove, e.g., sles-11-x86_64, sles-10.2-x86_64,
                   opensuse-11.1-x86

  --addon <name>   specifies the addon(s) to be removed. like these
                   distributions sles-10.2-rt-x86_64, sles-11-ha-x86

  --all            remove all the addons and the base distro.

Without specifying --all, remove will not remove the base distro if it has any addons present so that a two step remove process must be used to first remove all the addons listed for the base distro and then another invocation with the base --distro alone.

=cut

sub remove() {

    my $command = 'remove';
    my $distro;
    my $addons = "";
    my @addons;
    my $share;
    my $is_loopback = "";
    my $ret = 0;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addons=s'  => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $addons = $multiarg{ 'addons' } if (defined $multiarg{ 'addons' });

    ## Test if selection is valid
    ##
    $distro = lc $distro;
    &check_distro( $opts, $distro );

    #
    # tempting - but don't put sdk in $addons here or it will be
    # removed even if only a different addon was to be removed leaving
    # the base and maybe other addons in place
    #

    if ( $opts->{all} and $addons ) {
        $opts->{LASTERROR} = "Unsafe mix of --all and --addon <addon> usage\n";
        return 1;
    }

    if ( $opts->{all} ) {
        my $dh =  &baxml_distro_gethash( $opts, $distro );
        @addons = @{$dh->{basedisthash}->{addons}};
        $addons = join " ", @addons;
        print "working with 'all': $addons\n" if $opts->{debug};
    } else {
        @addons = split( /\s+/, $addons );

        # only check addons passed if not removing all
        if ( scalar @addons ) {
            print "Calling routine to verify addon(s) passed\n";
            return 1 if &check_addons( $opts, $distro, $addons );
        }
    }

    if ( scalar @addons ) {
        foreach my $addon ( @addons ) {
            my @shares;
            print "Removing addon $addon\n";
            ($share, undef) = &get_distro_share( $opts, $addon );
            $is_loopback = &get_loopback( $opts, $share );
            &remove_build_service( $opts, "", $addons);
            print "$share ... removing\n" if $opts->{verbose};
            if ( $is_loopback ) {
                $ret = system("umount $share");
                if ( $ret > 0 ) {
                    $opts->{LASTERROR} = "loopback unmount failed\n";
                    return 1;
                }
                rmdir($share);
            } else {
                rmtree($share);
            }
        }
        &source_register( $opts, $command, "", $addons);
    }

    # only remove base if no addons specified or --all passed
    if ( not scalar @addons or $opts->{all} ) {
        my $dh = &baxml_distro_gethash( $opts, $distro );

        # need to check if removing base which has dependent add-ons
        my @addons = &list_installed_addons( $opts, $distro );

        # handle default 'unspecified' sdk as transparent member of base
        my $sdk = &get_distro_sdk( $opts, $distro );

        if ( ( scalar @addons > 1 ) or
             ( scalar @addons and not defined $sdk ) or
             ( scalar @addons and $addons[0] ne $sdk ) ) {
            $opts->{LASTERROR} = "Remove these addons before removing $distro (or use --all)\n\t" . join ("\n\t", @addons ) . "\n";
            return 1;
        }
        if ( scalar @addons and defined $sdk and $addons[0] eq $sdk ) {
            ($share,undef) = &get_distro_share( $opts, $sdk );
            $is_loopback = &get_loopback( $opts, $share );
            &remove_build_service( $opts, "", $sdk);
            print "$share ... removing\n" if $opts->{verbose};
            if ( $is_loopback ) {
                $ret =  system("umount $share");
                if ( $ret > 0 ) {
                    $opts->{LASTERROR} = "loopback unmount failed\n";
                    return 1;
                }
                rmdir($share);
            } else {
                rmtree($share);
            }
            &source_register( $opts, $command, "", $sdk);
        }
        ($share,undef) = &get_distro_share( $opts, $distro );
        $is_loopback = &get_loopback( $opts,  $share );
        &remove_build_service( $opts, $distro, $addons);
        print "$share ... removing\n" if $opts->{verbose};
        if ( $is_loopback ) {
            $ret = system("umount $share");
            if ( $ret > 0 ) {
                    $opts->{LASTERROR} = "loopback unmount failed\n";
                    return 1;
                }
            rmdir($share);
        } else {
            rmtree($share);
        }

        &remove_bootloader_files( $opts, $distro );
        &source_register( $opts, $command, $distro, $addons);
    }
    return 0;
}

=head2 enable { --distro <name> | --addon <name> }

Where

  --distro <name>  specifies the full name of the distribution to use

=cut

sub enable() {

    my $command = 'enable';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $distro = lc $distro;
    &check_either( $opts, $distro );

    my $dbref = &get_db_source_entry( $opts, $distro );
    unless ( defined $dbref->{distroid} and
             ( $dbref->{distroid} eq $distro ) ) {
        $opts->{LASTERROR} = "Unable to find entry for $distro to enable\n";
        return 1;
    }
    unless ( defined $dbref->{status} and
             ( $dbref->{status} != BA_ADMIN_REMOVED ) ) {
        $opts->{LASTERROR} = "Unable to enable $distro not yet added.\n";
        return 1;
    }
    if ( $dbref->{status} != BA_ADMIN_DISABLED ) {
        $opts->{LASTERROR} = "Unable to enable $distro not disabled.\n";
        return 1;
    }

    print "Enabling $distro\n";

    # do the add_build_service - less code
    &add_build_service( $opts, $distro );

    &source_register( $opts, $command, $distro );
}

=head2 disable { --distro <name> | --addon <name> }

Where

  --distro <name>  specifies the full name of the distribution to
                   use, e.g., sles-11-x86_64, sles-10.2-rt-x86_64,
                   opensuse-11.1-x86, sles-11-ha-x86

=cut

sub disable() {

    my $command = 'disable';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $distro = lc $distro;
    &check_either( $opts, $distro );

    my $dbref = &get_db_source_entry( $opts, $distro );
    unless ( defined $dbref->{distroid} and
             ( $dbref->{distroid} eq $distro ) ) {
        $opts->{LASTERROR} = "Unable to find entry for $distro to enable\n";
        return 1;
    }
    unless ( defined $dbref->{status} and
             ( $dbref->{status} != BA_ADMIN_REMOVED ) ) {
        $opts->{LASTERROR} = "Unable to disable $distro not yet added.\n";
        return 1;
    }
    if ( $dbref->{status} != BA_ADMIN_ENABLED ) {
        $opts->{LASTERROR} = "Unable to disable $distro not enabled.\n";
        return 1;
    }

    print "Disabling $distro\n";

    # do the remove_build_service - less code
    &remove_build_service( $opts, $distro );

    &source_register( $opts, $command, $distro);
}

=head2 verify { --distro <name> | --addon <name> }

Verify some details for the distro or addon specified

=cut

sub verify() {

    my $command = 'verify';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $distro = lc $distro;
    &check_either( $opts, $distro );

    my $dbref = &get_db_source_entry( $opts, $distro );

    unless ( defined $dbref and
             $dbref->{status} and
             $dbref->{status} != BA_ADMIN_REMOVED ) {
        $opts->{LASTERROR} = "No entry found for $distro\n";
        return 1;
    }

    if ( $opts->{debug} > 2 ) {
        while ( my ($key, $val) = each %{$dbref} ) {
            print "dbref $key => $val\n";
        }
    }

    print "Target:\t\t$dbref->{distroid}\n";
    print "Created:\t$dbref->{creation}\n";
    print "Modified:\t$dbref->{change}\n" if defined $dbref->{change};
    print "Status:\t\t$baState{ $dbref->{status}}\n";
    print "Service:\t$dbref->{sharetype}";
    if ( &check_service( $opts, $dbref->{sharetype} ) ) {
        print " not running";
    } elsif ( $opts->{verbose} ) {
        print " ok";
    }
    print "\n";
    print "Share IP:\t$dbref->{shareip}\n";

    my $oldshare = "";
    foreach my $prod ( &baxml_products_getlist( $opts, $distro ) ) {
        my ($netcfg, $share, $state) = &check_service_product( $opts, $distro, $prod, $dbref->{sharetype} );

        if ( $oldshare ne $share ) {
            $oldshare = $share;

            print "Share:\t\t$netcfg";
            if ( not $state ) {
                print " missing";
            } elsif ( $opts->{verbose} ) {
                print " ok";
            }
            print "\n";

            print "Path:\t\t$share";
            if ( not -d $share ) {
                print " missing";
            } elsif ( $opts->{verbose} ) {
                print " ok";
            }
            print "\n";
        }
    }

    my $dh = &baxml_distro_gethash( $opts, $distro );
    my $base = $dh->{basedist};

    my $state = &sqlfs_getstate( $opts, "linux.$base" );
    print "kernel:\t\tlinux.$base";
    if ( not $state ) {
        print " missing";
    } else {
        if ( $state != 1 ) {
            print " disabled";
        } elsif ( $opts->{verbose} ) {
            print " ok";
        }
    }
    print "\n";

    $state = &sqlfs_getstate( $opts, "initrd.$base" );
    print "ramdisk:\tinitrd.$base";
    if ( not $state ) {
        print " missing";
    } else {
        if ( $state != 1 ) {
            print " disabled";
        } elsif ( $opts->{verbose} ) {
            print " ok";
        }
    }
    print "\n";
}

=head2 detail { --distro <name> | --addon <name> }

Displays many details for the distribution specified

=cut

sub detail() {

    my $command = 'detail';
    my $distro;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $distro = lc $distro;
    &check_either( $opts, $distro );

    my $dbref = &get_db_source_entry( $opts, $distro );
    if ( defined $dbref and
         defined $dbref->{status} )
    {
        $status = $baState{ $dbref->{status} };
    } else {
        $status = $baState{ BA_NONE };
    }

    my $dh = &baxml_distro_gethash( $opts, $distro );
    my $bh = $dh->{basedisthash};

    my %iodhash;

    find ( { wanted =>
             sub {
                 $iodhash{$_} .= "$File::Find::name ";
             },
             follow => 1
            },
           $baDir{isos} );

    print "\nDetails for $distro\n";
    print "With current status '$status'\n";
    if ($dh->{requires}) {
        print "Add-on product extending $dh->{basedist}\n";
    } else {
        print "Base product";
        if ( $bh->{addons} and scalar @{$bh->{addons}} ) {
            print " supporting extension(s):  " .
                join (", ", (sort @{$bh->{addons}} ) );
        }
        print "\n";
    }

    print "Based on product(s):  " .
        join (", ", ( sort &baxml_products_getlist( $opts, $distro ) ) ) . "\n";
    foreach my $product ( sort &baxml_products_getlist( $opts,  $distro ) ) {
        print "Detail for $product\n";
        my $ph = &baxml_product_gethash( $opts, $distro, $product );
        foreach my $iso ( sort &baxml_isos_getlist( $opts, $distro, $product ) ) {
            my $ih = &baxml_iso_gethash( $opts, $distro, $product, $iso );
            my $builds = $ih->{isopath};
            my $isoexist = "-";
            my $direxist = "-";
            $isoexist = "+" if ( $iodhash{$iso} );
            $direxist = "+" if ( -d $builds );

            $builds =~ s|$baDir{builds}/||og;
            printf "  %s $iso  =>  %s $builds\n", $isoexist, $direxist;
        }
    }
}

=head2 list  [ base | addon ] [ --distro <name> | --addon <name> ] [ --all ]

  List distribution state.

  If a distribution has not been added, or has been removed, it is not
  displayed in the output.  To see all Baracus managable distributions
  and their state use the --all option.

Options

    --distro <name>  Exact, or partial with wildcarded ('*')
    --all            See all managable distributions

    base             Scope results to matching base distributions
    addon            For a provided base list the applicable addons

=cut

sub list() {

    my $command = 'list';

    my $distro;
    my $base = "";
    my $addon = "";
    my $wildcard = 0;

    @ARGV = @_;

    GetOptions(
               'distro=s'  => \$distro,
               'addon=s'   => \$distro,
               );

    if ( defined $distro ) {
        $distro = lc $distro ;
        if ( $distro =~ m|\*| ) {
            $distro =~ s|\*|.*|g;
            $wildcard = 1;
        }
    } else {
        $distro = "";
    }

    my $name = "base/addon";
    if ( scalar @ARGV ) {
        if ( $ARGV[0] eq "base" ) {
            $base = shift @ARGV;
            $name = "base";
        }
        elsif ( $ARGV[0] eq "addon" ) {
            $addon = shift @ARGV;
            $name = "addon";
        }

        if ( scalar @ARGV ) {
            printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
            &help( $opts, $cmds, $command );
        }
    }

    #
    # more like barepo than bahost this tools list relies on the
    # badistro.xml and the populated builds and isos directories.
    #

    unless ( $opts->{quiet} || $opts->{nolabels} ) {
        print "--------------------------------------------------------------------------------\n";
        printf "%-28s %-8s description\n", $name, "status";
        print "--------------------------------------------------------------------------------\n";
    }

    foreach my $adistro ( reverse sort &baxml_distros_getlist( $opts ) ) {
        my $dh = &baxml_distro_gethash( $opts, $adistro );
        if ( $base ) {
            next if ( defined $dh->{requires} );
        }
        unless ( $addon ) {
            if ( $distro ) {
                if ( $wildcard ) {
                    next unless ( $adistro =~ m|$distro|o );
                } else {
                    next unless ( $adistro eq $distro );
                }
            }
        }
        if ( $addon ) {
            next unless ( defined $dh->{requires} );
            if ( $distro ) {
                if ( $wildcard ) {
                    next unless ( $dh->{basedist} =~ m|$distro|o );
                } else {
                    next unless ( $dh->{basedist} eq $distro );
                }
            }
        }
        my $dbref = &get_db_source_entry( $opts, $adistro );
        my $status;


        if ( defined $dbref and
             defined $dbref->{status} )
        {
            $status = $baState{ $dbref->{status} };
        } else {
            $status = $baState{ BA_NONE };
        }

        if ( ($status ne $baState{ BA_NONE }) and
             ($status ne $baState{ BA_ADMIN_REMOVED })
            )
        {
            printf "%-28s ", $adistro;
            unless ( $opts->{quiet} ) {
                printf "%-8s %s", $status, $dh->{description};
            }
            print "\n";
        } elsif ( $opts->{all} ) {
            printf "%-28s ", $adistro;
            unless ( $opts->{quiet} ) {
                printf "%-8s %s", $status, $dbref->{description};
            }
            print "\n";
        }
    }
    return 0;
}

=head2 init [ --exports | --mounts] [ --all ]

  Initialize or sync distro share media mount/exports to internal table.

  Since Baracus does not use /etc/exports or /etc/fstab to maintain iso
  mounts or exports the init function can be used to make sure all media
  is properly available.  Usually this function is only necessary as part
  of the system boot initialization of Baracus but can be called explictly
  if media seems to be missing.

Options

    --exports        Export any media marked for export that is not already
    --mounts         Mount and media marked for mount that is not already
    --all            check for both out of sync exports and mounts

=cut

sub init() {

    my $command = 'init';

    my $exports = 0;
    my $mounts = 0;
    my $all;
    my $ret = 0;

    @ARGV = @_;

    GetOptions(
               'exports!'  => \$exports,
               'mounts!'   => \$mounts,
               );

    if (( $mounts )  || ( $opts->{all} )) {
        print "init mounts\n" if $opts->{debug};
        $ret = &init_mounter( $opts );
        $opts->{LASTERROR} = "mount failure\n" if ( $ret > 0);
    }
    if (( $exports ) || ( $opts->{all} )) {
        print "init exports\n" if $opts->{debug};
        $ret = &init_exporter( $opts );
        $opts->{LASTERROR} = "export failure\n" if ( $ret > 0);
    }
    return $ret;
}

=head2 service { --start [service] | --stop [service] }

With service you need to specify start or stop

    service --start
    service --stop

With current sysconfig settings, if specific services are unspecified, these default to start or stop both the SHARE_TYPE and dhcpd services.

You can also list the services to start or stop specifically

    service --start "http dhcpd" --stop nfs

=cut

sub service() {

    my $command = 'service';

    my $startlist = "";
    my $stoplist  = "";

    @ARGV = @_;

    GetOptions(
               'start:s'    => \&multiarg_handler,
               'stop:s'     => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help( $opts, $cmds, $command );
    }

    $startlist = $multiarg{ 'start' } if (defined $multiarg{ 'start' });
    $stoplist  = $multiarg{ 'stop'  } if (defined $multiarg{ 'stop'  });


    unless ( $startlist or $stoplist ) {
        &help( $opts, $cmds, $command );
    }

    if ( defined $startlist ) {
        foreach my $serv ( split(/\s+/, $startlist ) ) {
            &enable_service( $opts, $serv );
        }
    }
    if ( defined $stoplist ) {
        foreach my $serv ( split(/\s+/, $stoplist ) ) {
            &disable_service( $opts, $serv );
        }
    }
    return 0
}

######################################################################

die "ABSOLUTELY DOES NOT EXECUTE";

__END__
