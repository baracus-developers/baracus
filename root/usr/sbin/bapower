#!/usr/bin/perl -w

use strict;
use warnings;

use Getopt::Long qw( :config pass_through );
use AppConfig;
use Pod::Usage;

use lib "/usr/share/baracus/perl";

use BaracusPower qw( :subs );
use BaracusDB;
use BaracusSql;

=pod

=head1 NAME

B<bapower> - baracus tool for BMC power management

=head1 SYNOPSIS
 
B<bapower> E<lt>commandE<gt> [options]

Where E<lt>commandE<gt> is

    off    --mac=<mac> --alias=alias    poweroff hardware.
    on     --mac=<mac> --alias=alias    poweron hardware.
    cycle  --mac=<mac> --alias=alias    powercycle hardware.
    status --mac=<mac> --alias=alias    power status.
    list   --mac=<mac>|--alias <alias>  List BMC entries
    remove --mac=<mac>|--alias <alias>  Remove BMC entry
    add    --mac=<mac> --bmcaddr=<bmc ip> --ctype <BMC type> --login <username> --passwd <password> --alias <alias>  Add BMC entry

    help                      This 'Usage' summary message.
    man                       Detailed man page.

Use 'man' or 'help <command>' for more details.

=head1 DESCRIPTION

This tool allows for power management via plugable BMC control modules

=head1 OPTIONS

=over 4

=item -v --verbose  Be verbose with output

=back

=cut

our $LASTERROR="";

my $man      = 0;
my $help     = 0;
my $debug    = 0;
my $verbose  = 0;
my $quiet    = 0;

my %cmds = (
            'on'     => \&on,
            'off'    => \&off,
            'cycle'  => \&cycle,
            'status' => \&status,
            'add'    => \&add_stub,
            'remove' => \&remove_stub,
            'list'   => \&list_stub,
            'help'   => \&help,
            'man'    => \&man,
            );

GetOptions(
           'debug'          => \$debug,
           'quiet'          => \$quiet,
           'help|?'         => \$help,
           'man'            => \$man,
           'verbose'        => \$verbose,
           );

&man()  if $man;
&help() if $help;
&help() unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &man(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &help(@ARGV); }

my $dbname = "baracus";
my $dbrole = $dbname;

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

my $status = &main(@ARGV);

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

print $LASTERROR if $status;

exit $status;

die "DOES NOT EXECUTE";

###############################################################################
#
# subroutines
#

sub main
{
    my $command = shift;

    my $deviceid = "";
    my $bmc;

    printf "Executing $command with \"@_\".\n" if $debug;

    $command = lc $command;
    &check_command( $command );
    
    if ( ( $command eq "add") || ( $command eq "remove") || ( $command eq "update" ) || ( $command eq "list" ) ) {
        $bmc->{'dbh'} = $dbh;
        $cmds{ $command }( $bmc, @_ );
    } else {
        $deviceid = &arg_handler( @_ );
        unless ($deviceid) {
            print "invalid or non-existant deviceid\n";
            return 1;
        }
        $bmc = &get_bmc($deviceid, $dbh);
        $cmds{ $command }( $bmc );
    }
}

sub help() {
    my $command = shift;

    unless ( defined $command ) {
        pod2usage( -verboase => 0,
                   -exitstatus => 0 );
    }

    $command = lc $command;
    &check_command( $command );

    my $execname = $0;
    $execname = $1 if ( $0 =~ m|^.*/([^/].+)| );

    pod2usage( -msg        => "$execname $command ...\n",
               -verbose    => 99,
               -sections   => "COMMANDS/${command}.*",
               -exitstatus => 0 );
}

sub man
{
    pod2usage( -verbose    => 2,
               -sections   => "NAME|SYNOPSIS|DESCRIPTION|OPTIONS|COMMANDS",
               -noperldoc  => 1,
               -exitstatus => 0 );
}

sub arg_handler() {

    my %entry = (
                 'mac'      => "",
                 'alias'    => "",
                );
    @ARGV = @_;
    GetOptions(
               'mac=s'      => \$entry{'mac'},
               'alias=s'    => \$entry{'alias'},
              );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help();
    }

    if ( ($entry{'mac'}) && ($entry{'alias'}) ) {
        $LASTERROR = sprintf "\n--mac and --alias not allowed together\n";
        return 1;
    }

    my $deviceid = 0;

    if ($entry{'mac'}) {
        $deviceid = $entry{'mac'};
    } elsif ($entry{'alias'}) {
        $deviceid = &get_mac( $entry{'alias'}, $dbh );
    } else {
        $LASTERROR = sprintf "\n--mac or --alias required\n";
        return 1;
    }

    return( $deviceid );

}

sub check_command
{
    my $command = shift;

    my $cmd_list = join ', ', (sort keys %cmds);
    unless ( defined $command ) {
        print "Requires <command> (e.g. $cmd_list)\n";
        &help();
    }

    unless ( defined $cmds{ $command } ) {
        $LASTERROR = sprintf "\nInvalid <command> '$command' please use:  $cmd_list\n";
        return 1;
    }
}

sub remove_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'alias=s'       => \$bmcref->{'alias'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my $status = &remove( $bmcref );

    return $status;

}

sub add_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'ctype=s'       => \$bmcref->{'ctype'},
               'login=s'       => \$bmcref->{'login'},
               'passwd=s'      => \$bmcref->{'passwd'},
               'bmcaddr=s'     => \$bmcref->{'bmcaddr'},
               'node=s'        => \$bmcref->{'node'},
               'other=s'       => \$bmcref->{'other'},
               'alias=s'       => \$bmcref->{'alias'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    } 

    ## Check minimal required args
    ## Should be broken out into ctype specific checks
    unless ( ($bmcref->{'mac'}) && ($bmcref->{'login'}) && ($bmcref->{'passwd'}) && ($bmcref->{'ctype'} && ($bmcref->{'bmcaddr'}))  ) {
        $LASTERROR = "Required BMC args not provided ( ctype,mac,login,passwd,bmcaddr ).\n";
        return 1;
    }

    &add( $bmcref );

    return 0;

}   

sub list_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'alias=s'       => \$bmcref->{'alias'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my $sth = &list_start( $bmcref );
    my $href = $sth->fetchrow_hashref();
    unless ( defined $href ) {
        $LASTERROR = sprintf "Failed in find deviceid \n";
        return 1;
    }

    unless ($quiet) {
    print "--------------------------------------------------------------------------------------\n";
    printf "%-8s %-16s %-18s %-18s %-16s %-16s ", "ctype", "bmcaddr", "mac", "alias", "node", "other";
    print "\n";
    print "--------------------------------------------------------------------------------------\n";
    }

    while  ($href ne "null") { 
        $href->{'node'} =~ s/NULL//g;
        $href->{'other'} =~ s/NULL//g;
        printf "%-8s %-16s %-18s %-18s %-16s %-16s ", "$href->{'ctype'}", "$href->{'bmcaddr'}", "$href->{'mac'}", "$href->{'alias'}", "$href->{'node'}", "$href->{'other'}";
        print "\n";
        $href = &list_next( $sth );
    }

    return 0;

}

die "ABSOLUTELY DOES NOT EXECUTE";

__END__
