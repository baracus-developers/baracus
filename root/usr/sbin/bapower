#!/usr/bin/perl -w

###########################################################################
#
# Baracus build and boot management framework
#
# Copyright (C) 2010 Novell, Inc, 404 Wyman Street, Waltham, MA 02451, USA.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the Artistic License 2.0, as published
# by the Perl Foundation, or the GNU General Public License 2.0
# as published by the Free Software Foundation; your choice.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Both the Artistic
# Licesnse and the GPL License referenced have clauses with more details.
#
# You should have received a copy of the licenses mentioned
# along with this program; if not, write to:
#
# FSF, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110, USA.
# The Perl Foundation, 6832 Mulderstraat, Grand Ledge, MI 48837, USA.
#
###########################################################################

use strict;
use warnings;

use Getopt::Long qw( :config pass_through );
use AppConfig;
use Pod::Usage;

use lib "/usr/share/baracus/perl";

use BaracusPower qw( :subs );
use BaracusDB;
use BaracusSql;
use BaracusCore qw( :subs );

=pod

=head1 NAME

B<bapower> - baracus tool for BMC power management

=head1 SYNOPSIS
 
B<bapower> E<lt>commandE<gt> [options]

Where E<lt>commandE<gt> is

  off    --mac <mac> | --hostname <host>  power off hardware.
  on     --mac <mac> | --hostname <host>  power on hardware.
  cycle  --mac <mac> | --hostname <host>  power cycle hardware.
  status --mac <mac> | --hostname <host>  power status.
  remove --mac <mac> | --hostname <host>  Remove BMC entry

  add    --mac <mac> [--hostname <host>] --bmcaddr=<bmc ip> --ctype <BMC type> --login <username> --passwd <password>
         Add BMC entry

  list   [ --mac <mac> | --hostname <host> ] List BMC entries with optional filter

  help   This 'Usage' summary message.
  man    Detailed man page.

Use 'man' or 'help <command>' for more details.

=head1 DESCRIPTION

This tool allows for power management via plugable BMC control modules

=head1 OPTIONS

=over 4

=item -v --verbose  Be verbose with output

=back

=cut

our $LASTERROR="";

my $man      = 0;
my $help     = 0;
my $debug    = 0;
my $verbose  = 0;
my $quiet    = 0;

my %cmds = (
            'on'     => \&on,
            'off'    => \&off,
            'cycle'  => \&cycle,
            'status' => \&status,
            'add'    => \&add_stub,
            'remove' => \&remove_stub,
            'list'   => \&list_stub,
            'help'   => \&myhelp,
            'man'    => \&myman,
            );

GetOptions(
           'debug'          => \$debug,
           'quiet'          => \$quiet,
           'help|?'         => \$help,
           'man'            => \$man,
           'verbose'        => \$verbose,
           );

&myman()  if $man;
&myhelp() if $help;
&myhelp() unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &myman(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &myhelp(@ARGV); }

my $dbname = "baracus";
my $dbrole = $dbname;

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

my $status = &mymain(@ARGV);

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

print $LASTERROR if $status;

exit $status;

die "DOES NOT EXECUTE";

###############################################################################
#
# subroutines
#

sub mymain
{
    my $command = shift;

    my $deviceid = "";
    my $bmc;

    printf "Executing $command with \"@_\".\n" if $debug;

    $command = lc $command;
    &mycheck_command( $command );
    
    if ( ( $command eq "add") || ( $command eq "remove") || ( $command eq "update" ) || ( $command eq "list" ) ) {
        $bmc->{'dbh'} = $dbh;
        $cmds{ $command }( $bmc, @_ );
    } else {
        $deviceid = &arg_handler( @_ );
        unless ($deviceid) {
            print "invalid or non-existant deviceid\n";
            return 1;
        }
        $bmc = &get_bmc($deviceid, $dbh);
        unless ($bmc) {
            print "invalid or non-existant controler type for $deviceid\n";
            return 1;
        }
        $cmds{ $command }( $bmc );
    }
}

sub myhelp() {
    my $command = shift;

    unless ( defined $command ) {
        pod2usage( -verboase => 0,
                   -exitstatus => 0 );
    }

    $command = lc $command;
    &mycheck_command( $command );

    my $execname = $0;
    $execname = $1 if ( $0 =~ m|^.*/([^/].+)| );

    pod2usage( -msg        => "$execname $command ...\n",
               -verbose    => 99,
               -sections   => "COMMANDS/${command}.*",
               -exitstatus => 0 );
}

sub myman
{
    pod2usage( -verbose    => 2,
               -sections   => "NAME|SYNOPSIS|DESCRIPTION|OPTIONS|COMMANDS",
               -noperldoc  => 1,
               -exitstatus => 0 );
}

sub arg_handler() {

    my %entry = (
                 'mac'      => "",
                 'hostname' => "",
                );
    @ARGV = @_;
    GetOptions(
               'mac=s'      => \$entry{'mac'},
               'hostname=s'    => \$entry{'hostname'},
              );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &myhelp();
    }

    if ( ($entry{'mac'}) && ($entry{'hostname'}) ) {
        $LASTERROR = sprintf "\n--mac and --hostname not allowed together\n";
        return 1;
    }

    my $deviceid = 0;

    if ($entry{'mac'}) {
        $deviceid = &check_mac( $entry{'mac'} );
    } elsif ($entry{'hostname'}) {
	$deviceid = $entry{'hostname'};
    } else {
        $LASTERROR = sprintf "\n--mac or --hostname required\n";
        return 1;
    }

    return( $deviceid );

}

sub mycheck_command
{
    my $command = shift;

    my $cmd_list = join ', ', (sort keys %cmds);
    unless ( defined $command ) {
        print "Requires <command> (e.g. $cmd_list)\n";
        &myhelp();
    }

    unless ( defined $cmds{ $command } ) {
        $LASTERROR = sprintf "\nInvalid <command> '$command' please use:  $cmd_list\n";
        return 1;
    }
}

sub remove_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'hostname=s'    => \$bmcref->{'hostname'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my $status = &remove( $bmcref );

    return $status;

}

sub add_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'hostname=s'    => \$bmcref->{'hostname'},
               'ctype=s'       => \$bmcref->{'ctype'},
               'login=s'       => \$bmcref->{'login'},
               'passwd=s'      => \$bmcref->{'passwd'},
               'bmcaddr=s'     => \$bmcref->{'bmcaddr'},
               'node=s'        => \$bmcref->{'node'},
               'other=s'       => \$bmcref->{'other'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    } 

    ## Check minimal required args
    foreach my $arg ( my @req_args = get_bmcref_req_args($bmcref) ) {
	unless ( $bmcref->{$arg} ) {
	    $LASTERROR = "Required BMC args not provided (" .
		join(",", @req_args) . ").\n";
	    return 1;
	}
    }

    &add( $bmcref );

    return 0;

}   

sub list_stub() {

    my $bmcref = shift;
    @ARGV = @_;
    GetOptions(
               'mac=s'         => \$bmcref->{'mac'},
               'hostname=s'    => \$bmcref->{'hostname'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my $sth = &list_start( $bmcref );
    my $href = $sth->fetchrow_hashref();
    unless ( defined $href ) {
        $LASTERROR = sprintf "No entries found.\n";
        return 1;
    }

    unless ($quiet) {
    print "--------------------------------------------------------------------------------------\n";
    printf "%-8s %-16s %-18s %-18s %-16s %-16s ", "ctype", "bmcaddr", "mac", "hostname", "node", "other";
    print "\n";
    print "--------------------------------------------------------------------------------------\n";
    }

    while  ($href ne "null") { 
        $href->{'node'} =~ s/NULL//g;
        $href->{'other'} =~ s/NULL//g;
        printf "%-8s %-16s %-18s %-18s %-16s %-16s ", "$href->{'ctype'}", "$href->{'bmcaddr'}", "$href->{'mac'}", "$href->{'hostname'}", "$href->{'node'}", "$href->{'other'}";
        print "\n";
        $href = &list_next( $sth );
    }

    return 0;

}

die "ABSOLUTELY DOES NOT EXECUTE";

__END__
