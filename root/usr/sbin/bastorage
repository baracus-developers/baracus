#!/usr/bin/perl -w

###########################################################################
#
# Baracus build and boot management framework
#
# Copyright (C) 2010 Novell, Inc, 404 Wyman Street, Waltham, MA 02451, USA.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the Artistic License 2.0, as published
# by the Perl Foundation, or the GNU General Public License 2.0
# as published by the Free Software Foundation; your choice.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Both the Artistic
# Licesnse and the GPL License referenced have clauses with more details.
#
# You should have received a copy of the licenses mentioned
# along with this program; if not, write to:
#
# FSF, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110, USA.
# The Perl Foundation, 6832 Mulderstraat, Grand Ledge, MI 48837, USA.
#
###########################################################################

use strict;
use warnings;

use Getopt::Long qw( :config pass_through );
use Pod::Usage;

use lib "/usr/share/baracus/perl";

use SqlFS;

use BaracusDB;
use BaracusCore qw( :subs  );
use BaracusConfig qw( :vars :subs );
use BaracusLUN qw( :vars :subs );


#     update    <...>  Update a storage name or description

=pod

=head1 NAME

B<bastorage> - Baracus "storage" for SAN and NAS identification and handling

=head1 SYNOPSIS

B<bastorage> E<lt>commandE<gt> [options and arguments]

Where E<lt>commandE<gt> is

    add       <...>  Add an identifier, name and description for media or share
    remove    <...>  Remove Baracus knowledge of media or share
    list      <...>  List the known non-local storage shares and media available
    detail    <...>  Show all known information about storage

    help    This 'Usage' summary message.
    man     Detailed man page.

Use 'man' or 'help <command>' for more details.

=head1 DESCRIPTION

This tool allows for the identification of disserperate network storage (Network Attached Storage or Storage Area Networks) for potential use with baracus hosts as available disks for network boot targets (e.g. nfsroot, ibft/iscsi).

=head1 OPTIONS

=over 4

=item -v --verbose  Be verbose with output

=back

=cut

my $man      = 0;
my $help     = 0;

# no add / remove here - all cmds add or update as needed
# to 'mac', 'build', and 'templateid' tables

my $cmds = {
            'add'           => \&add,
            'remove'        => \&remove,
            'list'          => \&list,
            'detail'        => \&detail,

            'help'          => \&help,
            'man'           => \&man,
            };

my $opts = {
            verbose    => 0,
            quiet      => 0,
#            all        => 0,
#            nolabels   => 0,
            debug      => 0,
            execname   => "",
            LASTERROR  => "",
            };

# Build command line for help, historical reference and point-in-time rebuilding
$opts->{execname} = $0;
$opts->{execname} = $1 if ( $0 =~ m|^.*/([^/].+)| );
my $cmdline = join '::', $opts->{execname}, @ARGV;

GetOptions(
           'verbose'   => \$opts->{verbose},
           'quiet'     => \$opts->{quiet},
#           'all'       => \$opts->{all},
#           'nolabels'  => \$opts->{nolabels},
           'debug+'    => \$opts->{debug},
           'man'       => \$man,
           'help|?'    => \$help,
           );

&man()  if $man;
&help( $opts, $cmds ) if $help;
&help( $opts, $cmds ) unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &man(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &help( $opts, $cmds, @ARGV ); }

my $dbname = "baracus";
my $dbrole = $dbname;

print "setting uid to $dbrole\n" if ($opts->{debug} > 2);

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

my $status = &main( $opts, $cmds, @ARGV );

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

print $opts->{LASTERROR} if $status;

exit $status;

die "DOES NOT EXECUTE";


###############################################################################
##
## commands
##

=head1 COMMANDS

=head2 add --id <unique uri> --ip <server> --username <username> --password <password> --name <name> --description <"text">

Where

  --id <unique uri>        Globally unique share locator URI.
  --ip <server>            Address of the network storage server.
  --target <target>        remote target path or iqn identifer
  --username <username>    username for LUN authentication
  --passwd <password>      password for LUN authentication
  --description <"text">   Quoted descriptive text for the share.
  --size <"text">          Describe the size of the partition.

=cut

#
#  uri is generated by gen_uri in BaracusLUN.pm
#

sub add
{
    my $command = "add";

    unless ( scalar @_ ) {
        &help( $opts, $cmds, $command );
    }

    my $lunref = {
                  targetid => "",
                  targetip => "",
                  };
    my $chkref;

    @ARGV = @_;

    GetOptions(
               'id=s'          => \$lunref->{'targetid'},
               'ip=s'          => \$lunref->{'targetip'},
               'type=s'        => \$lunref->{'type'},
               'target=s'      => \$lunref->{'target'},
               'username=s'    => \$lunref->{'username'},
               'passwd=s'      => \$lunref->{'passwd'},
               'size=s'        => \$lunref->{'size'},
               'description=s' => \$lunref->{'description'},
              );

    if ( scalar @ARGV ) {
        $opts->{LASTERROR} = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    ## Verify Mandatory parameters
    ##
    if ( $lunref->{'targetid'} eq "" ) {
        $opts->{LASTERROR} = "Missing  --id\n";
        return 1;
    }
    if ( $lunref->{targetip} eq "" ) {
        $opts->{LASTERROR} = "Missing  --ip\n";
        return 1;
    }
    if ( $lunref->{target} eq "" ) {
        $opts->{LASTERROR} = "Missing  --target\n";
        return 1;
    }
    unless ( defined $baLunType{ $lunref->{type} } ) {
        $opts->{LASTERROR} = "Incorrect  --type \n";
        return 1;
    } else {
        $lunref->{type} = $baLunType{ $lunref->{type} };
    }

    &check_ip( $lunref->{targetip} );  # exits on error

    # check for pre-exsisting id
    $chkref = &get_db_lun( $dbh, $lunref->{targetid} );
    if ( defined $chkref ) {
        my $name = defined $chkref->{'name'} ? $chkref->{'name'} : "";
        $opts->{LASTERROR} = "lun: $lunref->{targetid} already exists $name\n";
        return 1;
    }

    # done with all checking
    # begin loading of hash used for remainder of processing command

    $lunref->{name} = $lunref->{id} unless ( defined $lunref->{name} );

    &add_db_lun( $dbh, $lunref );

    if ( $opts->{verbose} )
    {
        printf "lun: $lunref->{id} added\n";
    }

    return 0;
}


=head2 remove --id <id>

This command does not remove any data from the network storage device. Instead this only removes the info from Baracus so that it cannot easily be assigned to a host.

Also note this does not remove any existing relations of this share with existing host entries.

=cut

sub remove
{
    my $command = "remove";

    unless ( scalar @_ ) {
        &help( $opts, $cmds, $command );
    }

    my $id="";

    my $chkref;

    @ARGV = @_;

    GetOptions(
               'id=s' => \$id,
               );

    if ( scalar @ARGV ) {
        $opts->{LASTERROR} = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    $chkref = &get_db_lun( $dbh, $id );
    if ( defined $chkref ) {
        &remove_db_lun( $dbh, $id );
    }

    return 0;
}

=head2 list [ --filter <id|name>::<partial*|specific> ]

List the network storage for which Baracus has information.

Option

     --filter id::'partial*'  filter results based on wildcard
     --filter name::specific  filter for a single match

=cut

sub list
{
    my $command = "list";

    my $filter = "";

    @ARGV = @_;

    GetOptions(
               'filter=s'   => \$filter,
              );

    if ( scalar @ARGV ) {
        $opts->{LASTERROR} = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my $sth = list_start_lun ( $dbh, $filter );

    unless( defined $sth ) {
        # well - we've likely died in list_start if logic would get here
        return 1;
    }

    unless ($opts->{quiet}) {
    print "----------------------------------------------------------------------------------------------\n";
    printf "%-26s %-15s %-26s %-6s %-8s\n", "targetid", "targetip", "target", "name", "size", "user";
    print "----------------------------------------------------------------------------------------------\n";
    }

    my $size;
    my $user;
    my $name;

    my $dbref;
    while ( $dbref = &list_next_lun( $sth ) ) {
        $size  = defined $dbref->{size}         ? $dbref->{size}         : "";
        $user  = defined $dbref->{username}     ? $dbref->{username}     : "";
        $name  = defined $dbref->{name}         ? $dbref->{name}         : "";

        printf "%-26s %-15s %-26s %-6s %-8s\n",
            $dbref->{targetid}, $dbref->{targetip}, $dbref->{target}, $name, $size, $user ;
    }

    return 0;
}

=head2 detail --id <targetid>

Show details for specified network storage device

=cut

sub detail
{
    my $command = "detail";

    unless ( scalar @_ ) {
        &help( $opts, $cmds, $command );
    }

    my $lunref;
    my $id = "";

    @ARGV = @_;

    GetOptions(
               'id=s' => \$id,
               );

    if ( scalar @ARGV ) {
        $opts->{LASTERROR} = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    $lunref = &get_db_lun( $dbh, $id );
    unless ( defined $lunref ) {
        $opts->{LASTERROR} = "No storage found with id: $id\n";
        return 1;
    }

    printf "%-12s %s\n", "Target ID",   $lunref->{'targetid'} ;
    printf "%-12s %s\n", "Target IP",   $lunref->{'targetip'} ;
    printf "%-12s %s\n", "Target Type",   $baLunType{ $lunref->{'type'} } ;
    printf "%-12s %s\n", "Target",      $lunref->{'target'} ;
    if ( defined $lunref->{'size'} and $lunref->{'size'} ne "" ) {
        printf "%-12s %s\n", "Size",        $lunref->{'size'}     ;
    }
    print "\n";
    if ( defined $lunref->{'description'} and $lunref->{'description'} ne "" ) {
        printf "%-12s %s\n", "Description", $lunref->{'description'} ;
    }
    print "\n";
    if ( defined $lunref->{'username'} and $lunref->{'username'} ne "" ) {
        printf "%-12s %s\n", "Username", $lunref->{'username'} ;
    }
    if ( defined $lunref->{'passwd'} and $lunref->{'passwd'} ne "" ) {
        printf "%-12s %s\n", "Password", "....." ;
    }
    return 0;
}


die "ABSOLUTELY DOES NOT EXECUTE";

__END__
