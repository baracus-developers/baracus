#!/usr/bin/perl -w

use strict;

use Getopt::Long qw( :config pass_through );
use Pod::Usage;

use lib "/usr/share/baracus/perl";

use BaracusDB;
use BaracusSql;

=pod

=head1 NAME

B<baconfig> - baracus tool to manage hardware, module, profile, and tftp entries.

=head1 SYNOPSIS

B<baconfig> E<lt>commandE<gt> E<lt>typeE<gt> [options and arguments]

Where E<lt>commandE<gt> is

    list   <type> [match]  List entries in database.
    add    <type> <...>    Copy to database from specified file.
    update <type> <...>    Modify module, profile or tftp entry.
    export <type> <...>    Export data portion of entry to new file.
    detail <type> <name>   Display file entry in database table.
    remove <type> <name>   Delete file from database table.

    help      This 'Usage' summary message.
    man       Detailed man page.

And, where E<lt>typeE<gt> is

    hardware  Values related to the hardware of the build client.
    module    Postinstall scripts to run on build completion.
    profile   Network or other variable definitions.
    tftp      TFTP filesystem database.

And, where <...> indicates additional required arguments.

Use 'man' or 'help <command> [<type>]' for more details.

=head1 DESCRIPTION

This tool allows files related to hardware, modules or profiles to be
added to, removed from, detailed, fetched from database tables.  Additionally,
all the database entries can be listed by type.

=head1 OPTIONS

=over 4

=item -v --verbose  Be verbose with output

=item -q --quiet  Be as quiet as possible

=item -n --nolabels  Do not print headers/footers

=item -a --all  For versioned files, show disabled too

=back

=cut

# what DBI schema and database are we using
my $dbname = "baracus";
my $dbrole = $dbname;

my $dbtftp = "sqltftp";

our $LASTERROR="";

my $man     = 0;
my $help    = 0;
my $debug   = 0;
my $quiet   = 0;
my $all     = 0;
my $verbose = 0;
my $nolabels = 0;

my %multiarg; # used for processing repeatable getoptions

# max_allowed_packets a mysql specific construct
my $maxlen = 1048575;

my %tbl = (
           'distro'   => 'distro_cfg',
           'hardware' => 'hardware_cfg',
           'module'   => 'module_cfg',
           'profile'  => 'profile_cfg',
           'tftp'     => 'sqlfstable',
           'oscert'   => 'hardwareid',
           'modcert'  => 'module_cert_cfg'
           );

my %cmds = (
            'list'    => \&list,
            'add'     => \&add,
            'update'  => \&update,
            'export'  => \&export,
            'detail'  => \&detail,
            'remove'  => \&remove,
            'help'    => \&help,
            'man'     => \&man,
            );

GetOptions(
           'help|?'   => \$help,
           'man'      => \$man,
           'debug+'   => \$debug,
           'quiet'    => \$quiet,
           'all'      => \$all,
           'verbose+' => \$verbose,
           'nolabels' => \$nolabels,
           );

&man()  if $man;
&help() if $help;
&help() unless ( scalar @ARGV );
if ($ARGV[0] eq "man"  ) { &man(); }
if ($ARGV[0] eq "help" ) { shift @ARGV; &help(@ARGV); }

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

my $tftph = BaracusDB::connect_db( $dbtftp, $dbrole );
die BaracusDB::errstr unless( $tftph );

my $status = &main(@ARGV);

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );
die BaracusDB::errstr unless BaracusDB::disconnect_db( $tftph );

print $LASTERROR if $status;

exit $status;

die "DOES NOT EXECUTE";

###########################################################################

# START - dhb
#
# these constructs are duplicates of those in SqlFS.pm
# at some point want to break out the guts of baconfig
# into a refreshed pm and clean up our interfaces....

# bytea_encode

# encode bytestream for VARCHAR storage

#

sub bytea_encode
{
    my ($in, $out);
    $in = shift;
    $out = pack( 'u', $in);
    return $out;
}

# bytea_decode

# decode bytestream for VARCHAR storage

#

sub bytea_decode
{
    my ($in,$out);
    $in = shift;
    $out = unpack( 'u', $in );
    return $out;
}
#
# END - dhb

sub main
{
    my $command = shift;

    $command = lc $command;
    &check_command( $command );

    printf "Executing $command with \"@_\".\n" if $debug;

    $cmds{ $command }( @_ );
}

sub help
{
    my $command = shift;
    my $type = shift;

    unless ( defined $command ) {
        pod2usage( -verboase => 0,
                   -exitstatus => 0 );
    }

    $command = lc $command;
    &check_command( $command );

    # so far only add and update have valid help for type

    my $execname = $0;
    $execname = $1 if ( $0 =~ m|^.*/([^/].+)| );

    if ( defined $type and ( $command eq "add" or $command eq "update" ) ) {
        $type = lc $type;
        &check_type( $type );

        pod2usage( -msg        => "$execname $command $type ...\n",
                   -verbose    => 99,
                   -sections   => "COMMANDS/${command} ${type}.*",
                   -exitstatus => 0 );
    } else {
        pod2usage( -msg        => "$execname $command ...\n",
                   -verbose    => 99,
                   -sections   => "COMMANDS/${command}.*",
                   -exitstatus => 0 );
    }
}

sub man
{
    pod2usage( -verbose    => 2,
               -sections   => "NAME|SYNOPSIS|DESCRIPTION",
               -exitstatus => 0 );
}

=head1 COMMANDS

=head2 list <type> [--all] [--quiet] [match]

Takes <type> as an argument, (hardware, module, profile, tftp).
Also takes optional string [ match ] to use for partial matching.

Lists enabled entries of type, matching match, in filesystem.
If --all is specified all versions (if <type> supports versions)
are listed.

=cut

sub list
{
    my $type = shift;
    my $pattern = shift;

    if ( scalar @_ ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @_);
        &help();
    }

    $type = lc $type;
    my $tlist = &check_type( $type );

    # recursive call to list for all types - one shot whammy
    if ( $type eq "all" ) {
        my @ltypes = split( /, /, $tlist);
        my $status;
        foreach my $ltype ( @ltypes ) {
            if ( defined $pattern ) {
                $status = &list( $ltype, $pattern );
            } else {
                $status = &list( $ltype );
            }
            return $status if $status;
        }
        return 0;
    }

    $pattern = "" unless( defined $pattern );

    my $sth = &list_start( $type, $pattern );

    unless( defined $sth ) {
        $LASTERROR .= "Unable to create db stmt handle for search: $pattern\n";
        return 1;
    }

    unless ( $quiet || $nolabels ) {
        print "--------------------------------------------------------------------------------\n";
        if ( $type eq "profile" ) {
            printf "%-32s ver sts description\n", $type;
        } elsif ( $type eq "module") {
             printf "%-32s ver sts mty description\n", $type;
        } elsif ( $type eq "tftp" ) {
            printf "%-32s cnt sts description\n", $type;
        } else {
            printf "%-32s description\n", $type;
        }
        print "--------------------------------------------------------------------------------\n";
    }
    while ( my $href = &list_next( $sth ) ) {
        if ( $type eq "profile" ) {
            next unless ( $all || $href->{'status'} );
            # name, version, status, description
            printf "%-32s ", $href->{'name'};
            unless ( $quiet ) {
                printf "%-3s %-3s %s",
                    $href->{'version'}, $href->{'status'},
                        (defined $href->{'description'}) ?
                            $href->{'description'} : "";
            }
        }  elsif ( $type eq "module" ) {
               next unless ( $all || $href->{'status'} );
               # name, version, status, mandatory, description
               printf "%-32s ", $href->{'name'};
               unless ( $quiet ) {
                  # printf "%-3s %-3s %-3s %s",
                   printf "%-3s %-3s     %s",
                    #   $href->{'version'}, $href->{'status'}, $href->{'mandatory'},
                       $href->{'version'}, $href->{'status'},
                           (defined $href->{'description'}) ?
                               $href->{'description'} : "";
            }
        } elsif ( $type eq "tftp" ) {
            next unless ( $all || $href->{'enabled'} );
            # name, count, status, description
            printf "%-32s ", $href->{'name'};
            unless ( $quiet ) {
                printf "%-3s %-3s %s",
                    $href->{'count'}, $href->{'enabled'},
                        (defined $href->{'description'}) ?
                            $href->{'description'} : "";
            }
        } else {
            # name, description
            printf "%-32s ", $href->{'name'};
            unless ( $quiet ) {
                printf "%s",
                    (defined $href->{'description'}) ?
                        $href->{'description'} : "";
            }
        }
        print "\n";
    }
    &list_finish( $sth );

    return 0;
}

# add invoke proper add type

sub add
{
    my $type = shift;
    my $status;

    $type = lc $type;
    &check_type( $type );

    if ( $type eq "hardware" ) {
        $status = &add_hardware( @_ );
    } elsif ( $type eq "module" ) {
        $status = &add_module( @_ );
    } elsif ( $type eq "profile" ) {
        $status = &add_profile( @_ );
    } elsif ( $type eq "tftp" ) {
        $status = &add_tftp( @_ );
    }

    return $status;
}

=head2 add hardware <options and args>

Where <options and args> are

    --name id              Required unique id, suggest make-model.
    --bootArgs string      Quoted line of kernel boot arguments.
    --rootdisk disk        Disk device to install. [ default /dev/sda ]
    --rootpart part        Root partition. [ default <diskroot> ]
    --description "note"   Describe this hardware entry.

The following templates are filename only and are expected to be
located in the directories ~baracus/templates/<os>/<arch>,
and ~baracus/templates/<os>/<arch>/pxetemplates, where <os> and <arch>
relate to the distro being used when creating the host entry.

    --pxeTemplate boot     Bootp pxe [ default pxetemplate-auto ]
    --yastTemplate file    Autoinstall [ default template.xml ]

    --hwdriver             Additional pkgs install for hardware.
    --oscert <distro>      A list of supported distros, for this
                           hardware. May be spcified multiple times.

=cut

sub add_hardware
{
    my %entry = (
                 'hardwareid'   => "",
                 'bootargs'     => "",
                 'rootdisk'     => "/dev/sda",
                 'rootpart'     => "",
                 'pxetemplate'  => "pxetemplate-auto",
                 'yasttemplate' => "template.xml",
                 'description'  => "",
                 'hwdriver'     => "",
                 'oscert'       => "",
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'hardwareid'},
               'bootargs=s'     => \$entry{'bootargs'},
               'rootdisk=s'     => \$entry{'rootdisk'},
               'rootpart=s'     => \$entry{'rootpart'},
               'pxetemplate=s'  => \$entry{'pxetemplate'},
               'yasttemplate=s' => \$entry{'yasttemplate'},
               'description=s'  => \$entry{'description'},
               'hwdriver=s'     => \&multiarg_handler,
               'oscert=s'       => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        printf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        &help();
    }

    # multiarg creates hash entry with a space seperated list of unique values

    $entry{'hwdriver'} =
        $multiarg{ 'hwdriver' } if (defined $multiarg{ 'hwdriver' });
    $entry{'oscert'}   =
        $multiarg{ 'oscert'   } if (defined $multiarg{ 'oscert'   });

    &help() unless ( $entry{'hardwareid'} );

    my $findcount = &find( 'hardware', $entry{'hardwareid'} );
    if ( defined $findcount ) {
        if ( $findcount ) {
            $LASTERROR = "Entry already exists:  hardware $entry{'hardwareid'}.\n";
            return 1;
        }
    } else {
        $LASTERROR .= "Failed in add hardware.\n" . $LASTERROR;
        return 1;
    }

    $entry{'rootpart'} = $entry{'rootdisk'} unless ( $entry{'rootpart'} );

    my $sql_cols = lc get_cols( 'hardware' );
    $sql_cols =~ s/[ \t]*//g;
    my @cols = split( /,/, $sql_cols );
    my $sql_vals = "?," x scalar @cols; chop $sql_vals;

    my $sql_cert_cols = lc get_cols( 'oscert' );
    $sql_cert_cols =~ s/[ \t]*//g;
    my @cert_cols = split( /,/, $sql_cert_cols );
    my $sql_cert_vals = "?," x scalar @cert_cols; chop $sql_cert_vals;
    my @cert_data = split( /\s/, $entry{ oscert });

    my $sql_cert = qq|INSERT INTO $tbl{ 'oscert' }
                     ( $sql_cert_cols )
                     VALUES ( $sql_cert_vals )
                     |;

    my $sql = qq|INSERT INTO $tbl{ 'hardware' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;

    print $sql . "\n" if $debug;

    my $sth;
    ## hardware table insert
    foreach my $cert_in ( @cert_data ) {
        unless ( &check_distroid($cert_in) ) {
            $LASTERROR = "Unable to add hardware, distro: $cert_in does not exist\n";
                return 1;
             }
    }
    my $sql_handle = ( $sth = $dbh->prepare( $sql ) );
    my $sql_cert_handle = ( $sth = $dbh->prepare( $sql_cert ) );

    unless ( (defined $sql_handle) && (defined $sql_cert_handle) ) {
        die "Unable to prepare 'add' hardware statement\n" .
            $dbh->errstr;
        return 1;
    }

    my $paramidx = 0;
    foreach my $col (@cols) {
        $paramidx += 1;
        $sql_handle->bind_param( $paramidx, $entry{ $col } );
    }

    my $success = 1;
    $success &&= $sql_handle->execute( );
    foreach my $cert_in (@cert_data) {
        $sql_cert_handle->bind_param( "1", $cert_in );
        $sql_cert_handle->bind_param( "2", $entry{'hardwareid'});
        $success &&= $sql_cert_handle->execute( );
    }

    unless ($success) {
        die "Unable to execute 'add' hardware oscert statement\n" .
            $sth->errstr;
        return 1;
    }

    $sth->finish;
    undef $sth;

    return 0;
}

=head2 add module <options and args>

Where <options and args> are

    --name id                                   Required unique id, suggest script name.
    --enable | --noenable                       Enable module for use. [ default enable ]
    --description "note"                        Quoted note describing this script.
    --mandatory --cert "distro1 distro2 etc.."  Make module mandatory for listed distros
    --optional --cert "distro1 distro2 etc.."   Make module optional for listed distros
    --file <path/script>                        Script to use for this module.

=cut

# thought this was supported from old autoinit documentation
#
#  --interpreter value   where value is shell, perl, python  [default shell]

sub add_module
{
    my $file = "";
    my %entry = (
                 'moduleid'      => "",
                 'description'   => "",
                 'interpreter'   => "shell",
                 'data'          => "",
                 'status'        => "t",
                 'cert'          => "",
                 'mandatory'     => "f",
                 'version'       => 1,
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'moduleid'},
               'description=s'  => \$entry{'description'},
#              'interpreter=s'  => \$entry{'interpreter'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'status'},
               'disable'        => sub { $entry{'status'} = 0 },
               'mandatory!'     => \$entry{'mandatory'},
               'optional'       => sub { $entry{'mandatory'} = 0},
               'cert=s'         => \$entry{'cert'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    &help() unless ( $entry{'moduleid'} );

    my $findcount = &find( 'module', $entry{'moduleid'} );
    if ( defined $findcount ) {
        if ( $findcount ) {
            $LASTERROR = "Entry already exists:  module $entry{'moduleid'}.\n";
            return 1;
        }
    } else {
        $LASTERROR .= "Failed in add module.\n" . $LASTERROR;
        return 1;
    }

    $entry{'interpreter'} = lc $entry{'interpreter'};
    $entry{'interpreter'} =~ s/[ \t]*//g;

    if ( ($entry{'interpreter'} ne "shell")   &&
         ($entry{'interpreter'} ne "perl")    &&
         ($entry{'interpreter'} ne "python" ) ){
        $LASTERROR = "invalid interpreter specified \'$entry{'interpreter'}\' - should be 'shell' 'perl' or 'python'\n";
        return 1;
    }

    if ( $entry{'status'} ne "" ) {
        if ( $entry{'status'} ) {
            $entry{'status'} = "t";
        } else {
            $entry{'status'} = "f";
        }
    }

    unless ( $file ne "" ) {
        print "Need --file <file>.\n";
        &help( "add", "module" );
    }

    unless ( -f $file and -r $file ) {
        $LASTERROR = "Unable to find or read file: $file.\n";
        return 1;
    }

    open (FILE, "<$file") || die "unable to open $file: $!\n";
    undef $/;
    $entry{'data'}=<FILE>;  # slurp mode
    $/ = "\n";
    close FILE;

    my $sql_cols = lc get_cols( 'module' );
    $sql_cols =~ s/[ \t]*//g;
    my @cols = split( /,/, $sql_cols );
    my $sql_vals = "?," x scalar @cols; chop $sql_vals;

    my $sql_cert_cols = lc get_cols( 'modcert' );
    $sql_cert_cols =~ s/[ \t]*//g;
    my @cert_cols = split( /,/, $sql_cert_cols );
    my $sql_cert_vals = "?," x scalar @cert_cols; chop $sql_cert_vals;
    my @cert_data = split( /\s/, $entry{ 'cert' });

    my $sql_cert = qq|INSERT INTO $tbl{ 'modcert' }
                     ( $sql_cert_cols )
                     VALUES ( $sql_cert_vals )
                     |;

    my $sql = qq|INSERT INTO $tbl{ 'module' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;
    print $sql . "\n" if $debug;

    my $sth;
    ## Module table insert
    foreach my $cert_in ( @cert_data ) {
        unless ( &check_distroid($cert_in) ) {
            $LASTERROR = "Unable to add module, distro: $cert_in does not exist\n";
                return 1;
        }
    }

    my $sql_handle = ( $sth = $dbh->prepare( $sql ) );
    my $sql_cert_handle = ( $sth = $dbh->prepare( $sql_cert ) );

    unless ( (defined $sql_handle) && (defined $sql_cert_handle) ) {
        die "Unable to prepare 'add' hardware statement\n" .
            $dbh->errstr;
        return 1;
    }

    my $paramidx = 0;
    foreach my $col (@cols) {
        $paramidx += 1;
        $sql_handle->bind_param( $paramidx, $entry{ $col } );
    }

    my $success = 1;
    $success &&= $sql_handle->execute( );
    foreach my $cert_in (@cert_data) {
        $sql_cert_handle->bind_param( "1", $entry{'moduleid'} );
        $sql_cert_handle->bind_param( "2", $cert_in );
        $sql_cert_handle->bind_param( "3", $entry{'mandatory'} );
        $success &&= $sql_cert_handle->execute( );
    }

    unless ($success) {
        die "Unable to execute 'add' modcert statement\n" .
            $sth->errstr;
        return 1;
    }

    $sth->finish;
    undef $sth;

    return 0;

}

=head2 add profile <options and args>

Where <options and args> are

    --name id              Required unique id.
    --enable | --noenable  Enable profile for use. [ default enable ]
    --description "note"   Quoted note describing this profile.
    --file <path/prof>     File to use for this profile.

=cut

sub add_profile
{
    my $file = "";
    my %entry = (
                 'profileid'    => "",
                 'description'  => "",
                 'data'         => "",
                 'status'       => "t",
                 'version'      => 1,
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'profileid'},
               'description=s'  => \$entry{'description'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'status'},
               'disable'        => sub { $entry{'status'} = 0 },
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    &help() unless ( $entry{'profileid'} );

    my $findcount = &find( 'profile', $entry{'profileid'} );
    if ( defined $findcount ) {
        if ( $findcount ) {
            $LASTERROR = "Entry already exists:  profile $entry{'profileid'}.\n";
            return 1;
        }
    } else {
        $LASTERROR .= "Failed in add profile.\n" . $LASTERROR;
        return 1;
    }

    if ( $entry{'status'} ne "" ) {
        if ( $entry{'status'} ) {
            $entry{'status'} = "t";
        } else {
            $entry{'status'} = "f";
        }
    }

    unless ( $file ne "" ) {
        print "Need --file <file>.\n";
        &help( "add", "profile" );
    }

    unless ( -f $file and -r $file ) {
        $LASTERROR = "Unable to find or read file: $file.\n";
        return 1;
    }

    open (FILE, "<$file") || die "unable to open $file: $!\n";
    undef $/;
    $entry{'data'}=<FILE>;  # slurp mode
    $/ = "\n";
    close FILE;

    my $sql_cols = lc get_cols( 'profile' );
    $sql_cols =~ s/[ \t]*//g;
    my @cols = split( /,/, $sql_cols );
    my $sql_vals = "?," x scalar @cols; chop $sql_vals;

    my $sql = qq|INSERT INTO $tbl{ 'profile' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;
    print $sql . "\n" if $debug;

    my $sth;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'add' profile statement\n" .
            $dbh->errstr;
        return 1;
    }

    my $paramidx = 0;
    foreach my $col (@cols) {
        $paramidx += 1;
        $sth->bind_param( $paramidx, $entry{ $col } );
    }

    # finished with last entry
    unless( $sth->execute( ) ) {
        $LASTERROR = "Unable to execute 'add' profile statement\n" .
            $sth->err;
        return 1;
    }

    $sth->finish;
    undef $sth;

    return 0;
}

=head2 add tftp <options and args>

Where <options and args> are

    --name id              Required unique id.
    --enable | --noenable  Enable tftp file for use. [ default enable ]
    --description "note"   Quoted note describing this file.
    --file <path/prof>     File to use for this tftp entry.

=cut

sub add_tftp
{
    my $file = "";
    my %entry = (
                 'name'         => "",
                 'description'  => "",
                 'bin'          => "",
                 'enabled'      => "t",
                 'insertion'    => "CURRENT_TIMESTAMP",
                 'change'       => "NULL",
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'name'},
               'description=s'  => \$entry{'description'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'enabled'},
               'disable'        => sub { $entry{'enabled'} = 0 },
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    &help() unless ( $entry{'name'} );

    my $findcount = &find( 'tftp', $entry{'name'} );
    if ( defined $findcount ) {
        if ( $findcount ) {
            $LASTERROR = "Entry already exists:  tftp $entry{'name'}.\n";
            return 1;
        }
    } else {
        $LASTERROR .= "Failed in add tftp.\n" . $LASTERROR;
        return 1;
    }

    if ( $entry{'enabled'} ne "" ) {
        if ( $entry{'enabled'} ) {
            $entry{'enabled'} = "1";
        } else {
            $entry{'enabled'} = "0";
        }
    }

    unless ( $file ne "" ) {
        print "Need --file <file>.\n";
        &help( "add", "tftp" );
    }

    unless ( -f $file and -r $file ) {
        $LASTERROR = "Unable to find or read file: $file.\n";
        return 1;
    }

    my $fh;
    open ($fh, "<", $file) || die "unable to open $file: $!\n";

    my $sql_cols = lc get_cols( 'tftp' );
    $sql_cols =~ s/[ \t]*//g;
    my @cols = split( /,/, $sql_cols );

    $sql_cols = "";
    my $sql_vals = "";
    # for the cols we are setting get rid of the autoincrement key
    foreach my $col( @cols ) {
        next if ( $col eq "id" );
        if ( $col eq "bin" ) {
            $sql_cols .= "$col,";
            $sql_vals .= "?,";
            next;
        }
        if ( defined $entry{ $col } ) {
            $sql_cols .= "$col,";
            if ( $col eq "insertion" or $col eq "change" ) {
                $sql_vals .= qq|$entry{ $col },|;
            } else {
                $sql_vals .= qq|'$entry{ $col }',|;
            }
        }
    }
    chop $sql_cols;
    chop $sql_vals;

    my $sql = qq|INSERT INTO $tbl{ 'tftp' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;
    print $sql . "\n" if $debug;

    my $sth;
    unless ( $sth = $tftph->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'add' tftp statement\n" .
            $dbh->errstr;
        return 1;
    }

    my $bytes = 1;
    while ( $bytes ) {
        read $fh, $bytes, $maxlen;
        $entry{ 'bin' } = &bytea_encode( $bytes );
        if ( $bytes ) {
            unless( $sth->execute( $entry{ 'bin' } ) ) {
                $LASTERROR = "Unable to execute 'add' tftp statement\n" .
                    $sth->err;
                return 1;
            }
        }
    }

    close $fh;

    $sth->finish;
    undef $sth;

    return 0;
}

# update - invoke proper update type

# this is not exactly straight forward - things to consider
#   - do we really need the trigger to convert the 'update' to an 'add'?
#   - highest version
#   - enabled version
#   - highest + 1 for new file content ( enabled by default - disable former )
#   - specified version ( if enabled former enabled version must be disabled )

sub update
{
    my $type = shift;
    my $status;

    $type = lc $type;
    &check_type( $type );

    if ( $type eq "module" ) {
        $status = &update_module( @_ );
    } elsif ( $type eq "profile" ) {
        $status = &update_profile( @_ );
    } elsif ( $type eq "tftp" ) {
        $status = &update_tftp( @_ );
    } elsif ( $type eq "hardware" ) {
        $status = &update_hardware( @_ );
    } else {
        $LASTERROR = "Invalid <type> '$type' passed for update.\n";
        return 1;
    }

    return $status;
}

=head2 update module <options and args>

Where <options and args> are

    --name id                                   Required unique id, suggest script name.
    --enable | --noenable                       Enable module for use. [ no default ]
    --description "note"                        Quoted note describing this script.
    --addcert "distro1 distro2 etc.."           Add distros for which module is supported
    --rmcert "distro1 distro2 etc.."            Remove distro support for module
    --mandatory --cert "distro1 distro2 etc.."  Make module mandatory for listed distros
    --optional --cert "distro1 distro2 etc.."   Make module optional for listed distros

you may only specify one of the following

    --file <path/script>   Create a new version with this content.
    --version <version>    Modify parameters of an existing version.

=cut

# dhb: thought init-scripts would support this but they don't anymore:
#
#   --interpreter value   where value is shell, perl, python  [default shell]

sub update_module
{
    my $type = 'module';
    my $file = "";

    my %entry = (
                 'moduleid'     => "",
                 'description'  => "",
                 'interpreter'  => "",
                 'data'         => "",
                 'status'       => "",
                 'mandatory'    => 0,
                 'cert'         => "",
                 'addcert'      => "",
                 'rmcert'       => "",
                 'version'      => 0,
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'moduleid'},
               'description=s'  => \$entry{'description'},
#              'interpreter=s'  => \$entry{'interpreter'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'status'},
               'disable'        => sub { $entry{'status'} = 0 },
               'mandatory!'     => \$entry{'mandatory'},
               'optional'       => sub { $entry{'mandatory'} = 0},
               'cert=s'         => \&multiarg_handler,
               'addcert=s'      => \&multiarg_handler,
               'rmcert=s'       => \&multiarg_handler,
               'version=i'      => \$entry{'version'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    unless ( $entry{'moduleid'} ) {
        print "Required --name <name> not provided.\n";
        &help();
    }

    if ( $entry{'status'} ne "" ) {
        print "enable or noenable passed: $entry{'status'}\n" if $debug;
        if ( $entry{'status'} ) {
            $entry{'status'} = "t";
        } else {
            $entry{'status'} = "f";
        }
    }

    # fetch needed entries from db
    my ( $version_href, $highest_href, $enabled_href ) =
        &get_versions( $type, $entry{'moduleid'}, $entry{'version'});

    unless (defined $highest_href) {
        unless ( $LASTERROR ) {
            $LASTERROR =
                "Unable to update $type, entry '$entry{'moduleid'}' not found\n";
        }
        return 1;
    }

    if ( $entry{'version'} != 0 ) {
        if ( $file ) {
            $LASTERROR = "Change of --file content for a version unsupported.\n";
            return 1;
        }
        unless (defined $version_href) {
            $LASTERROR = "Specified version was not found.\n";
            return 1;
        }
    } elsif ( $file eq "" ) {
        $LASTERROR = "Require --file <file> or specified --version for update.\n";
        return 1;
    } elsif ( ! $file ) {
        $LASTERROR = "Need --file <file> to add. Unable to find: $file.\n";
        return 1;
    } else {
        open (FILE, "<$file") || die "unable to open $file: $!\n";
        undef $/;
        $entry{'data'}=<FILE>;  # slurp mode
        $/ = "\n";
        close FILE;
    }

    $entry{'cert'} =
        $multiarg{ 'cert' } if (defined $multiarg{ 'cert' });

    $entry{'addcert'} =
        $multiarg{ 'addcert' } if (defined $multiarg{ 'addcert' });

    $entry{'rmcert'} =
        $multiarg{ 'rmcert' } if (defined $multiarg{ 'rmcert' });

    unless ( &check_module( $entry{'moduleid'} ) ) {
        $LASTERROR = "Unable to update module, $entry{'moduleid'} does not exist\n";
        return 1;
    }

    unless ($entry{'addcert'} eq "" ) {
        my $status = &update_cert("modcert", $entry{'moduleid'}, "addcert", $entry{'addcert'}, $entry{'mandatory'});
    }

    unless ($entry{'rmcert'} eq "" ) {
        my $status = &update_cert("modcert", $entry{'moduleid'}, "rmcert", $entry{'rmcert'});
    }

    # finished processing command line

    if ( $entry{'version'} != 0 ) {

        # true UPDATE for specified version
        # possibly two UPDATEs this 'status' changes to enable

        if ( defined $enabled_href->{'version'} &&
             $entry{'version'} != $enabled_href->{'version'} &&
             $entry{'status'} eq "t" ) {

            # disable enabled version - in preperation to enable specified version
            return 1 if &change_status( $type, "f", $enabled_href );
        }
        if ( $entry{'status'} ne "" ) {
            return 1 if &change_status( $type, $entry{'status'}, $version_href );
        }

        # changing the mandatory flag
        if ( (! $entry{'addcert'} eq "" ) || ( defined ( $entry{'cert'} ) ) ) {
            my $mandatory =  &get_mandatory( $entry{'moduleid'}, $entry{'cert'} );

            if ( $entry{'mandatory'} == $mandatory ) {
                $LASTERROR = "mandatory setting already set\n";
                return 1;
            }

            if ( $mandatory ne "" ) {
                ## Check to make sure that at least one version is enabled
                ##
                unless ( &check_enabled( $entry{'moduleid'} ) ) {
                    $LASTERROR = "At least one version must be enabled to set to mandatory.\n";
                    return 1;
                }
                return 1
                    if &change_mandatory( $entry{'mandatory'},
                                          $entry{'moduleid'}, $entry{'cert'} );
            }
        }

        # the only other param to modify is description
        # because we don't support intreperter now
        # and data modification is not allowed.

        elsif ( $entry{'description'} ne "" ) {
            return 1
                if &change_description( $type,
                                        $entry{'description'},
                                        $version_href );
        }

        # done with the genuine UPDATE of the version specified

    } else {

        # not UPDATE but instead INSERT a new version of <file> (highest ver + 1)
        # if --enable passed then may need UPDATE to disable earlier entry

        my $new_vers = $highest_href->{'version'} + 1;

        return 1 if (&redundant_data($type, $entry{'moduleid'}, $entry{'data'}));

        if ( defined $enabled_href->{'version'} &&
             $entry{'status'} eq "t" ) {

            # disable enabled version - in preperation to enable new version
            return 1 if &change_status( $type, "f", $enabled_href );
        }

        # use information from enabled version if found
        # and if not then highest version for all the fields
        # not provided with the new version of this file

        my $use_href;

        if ( defined $enabled_href->{'version'} ) {
            $use_href = $enabled_href;
        } else {
            $use_href = $highest_href;
        }

        while ( my ($key, $value) = each %entry ) {
            # change only what was passed
            if ( $value ) {
                $use_href->{ $key } = $value;
            }
        }

        if ( $entry{'status'} ne "t" ) {
            $use_href->{ 'status' } = "f";
        }

        # and assign the new version
        $use_href->{'version'} = $new_vers;

        # now add it

        my $sql_cols = lc get_cols( 'module' );
        $sql_cols =~ s/[ \t]*//g;
        my @cols = split( /,/, $sql_cols );
        my $sql_vals = "?," x scalar @cols; chop $sql_vals;

        my $sql = qq|INSERT INTO $tbl{ 'module' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;
        print $sql . "\n" if $debug;

        my $sth;
        unless ( $sth = $dbh->prepare( $sql ) ) {
            $LASTERROR = "Unable to prepare 'update' module statement\n" .
                $dbh->errstr;
            return 1;
        }

        my $paramidx = 0;
        foreach my $col (@cols) {
            $paramidx += 1;
            $sth->bind_param( $paramidx, $use_href->{ $col } );
        }

        # finished with last entry
        unless( $sth->execute( ) ) {
            $LASTERROR = "Unable to execute 'update' module statement\n" .
                $sth->err;
            return 1;
        }

        $sth->finish;
        undef $sth;

    }

    return 0;
}

=head2 update profile <options and args>

Where <options and args> are

    --name id              Required unique id.
    --enable | --noenable  Enable module for use. [ no default ]
    --description "note"   Quoted note describing this profile.

you may only specify one of the following

    --file <path/profile>  Create a new version with this content.
    --version <version>    Modify parameters of an existing version.

=cut

sub update_profile
{
    my $type = 'profile';
    my $file = "";

    my %entry = (
                 'profileid'    => "",
                 'description'  => "",
                 'data'         => "",
                 'status'       => "",
                 'version'      => 0,
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'profileid'},
               'description=s'  => \$entry{'description'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'status'},
               'disable'        => sub { $entry{'status'} = 0 },
               'version=i'      => \$entry{'version'},
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    unless ( $entry{'profileid'} ) {
        print "Required --name <name> not provided.\n";
        &help();
    }

    if ( $entry{'status'} ne "" ) {
        print "enable or noenable passed: $entry{'status'}\n" if $debug;
        if ( $entry{'status'} ) {
            $entry{'status'} = "t";
        } else {
            $entry{'status'} = "f";
        }
    }

    # fetch needed entries from db
    my ( $version_href, $highest_href, $enabled_href ) =
        &get_versions( $type, $entry{'profileid'}, $entry{'version'});

    unless (defined $highest_href) {
        unless ( $LASTERROR ) {
            $LASTERROR =
                "Unable to update $type, entry '$entry{'profileid'}' not found\n";
        }
        return 1;
    }

    if ( $entry{'version'} != 0 ) {
        if ( $file ) {
            $LASTERROR = "Change of --file content for a version unsupported.\n";
            return 1;
        }
        unless (defined $version_href) {
            $LASTERROR = "Specified version was not found.\n";
            return 1;
        }
    } elsif ( $file eq "" ) {
        $LASTERROR = "Require --file <file> or specified --version for update.\n";
        return 1;
    } elsif ( ! $file ) {
        $LASTERROR = "Need --file <file> to add. Unable to find: $file.\n";
        return 1;
    } else {
        open (FILE, "<$file") || die "unable to open $file: $!\n";
        undef $/;
        $entry{'data'}=<FILE>;  # slurp mode
        $/ = "\n";
        close FILE;
    }

    # finished processing command line

    if ( $entry{'version'} != 0 ) {

        # true UPDATE for specified version
        # possibly two UPDATEs this 'status' changes to enable

        if ( defined $enabled_href->{'version'} &&
             $entry{'version'} != $enabled_href->{'version'} &&
             $entry{'status'} eq "t" ) {

            # disable enabled version - in preperation to enable specified version
            return 1 if &change_status( $type, "f", $enabled_href );
        }
        if ( $entry{'status'} ne "" ) {
            return 1 if &change_status( $type, $entry{'status'}, $version_href );
        }

        # the only other param to modify is description
        # because we don't support intreperter now
        # and data modification is not allowed.

        if ( $entry{'description'} ne "" ) {
            return 1
                if &change_description( $type,
                                        $entry{'description'},
                                        $version_href );
        }

        # done with the genuine UPDATE of the version specified

    } else {

        # not UPDATE but instead INSERT a new version of <file> (highest ver + 1)
        # if --enable passed then may need UPDATE to disable earlier entry

        my $new_vers = $highest_href->{'version'} + 1;

        return 1 if (&redundant_data($type, $entry{'profileid'}, $entry{'data'}));

        if ( defined $enabled_href->{'version'} &&
             $entry{'status'} eq "t" ) {

            # disable enabled version - in preperation to enable new version
            return 1 if &change_status( $type, "f", $enabled_href );
        }

        # use information from enabled version if found
        # and if not then highest version for all the fields
        # not provided with the new version of this file

        my $use_href;

        if ( defined $enabled_href->{'version'} ) {
            $use_href = $enabled_href;
        } else {
            $use_href = $highest_href;
        }

        while ( my ($key, $value) = each %entry ) {
            # change only what was passed
            if ( $value ) {
                $use_href->{ $key } = $value;
            }
        }

        # if not explicitly enabled we default to disabled
        if ( $entry{'status'} ne "t" ) {
            $use_href->{ 'status' } = "f";
        }

        # and assign the new version
        $use_href->{'version'} = $new_vers;

        # now add it

        my $sql_cols = lc get_cols( 'profile' );
        $sql_cols =~ s/[ \t]*//g;
        my @cols = split( /,/, $sql_cols );
        my $sql_vals = "?," x scalar @cols; chop $sql_vals;

        my $sql = qq|INSERT INTO $tbl{ 'profile' }
                ( $sql_cols )
                VALUES ( $sql_vals )
                |;
        print $sql . "\n" if $debug;

        my $sth;
        unless ( $sth = $dbh->prepare( $sql ) ) {
            $LASTERROR = "Unable to prepare 'update' profile statement\n" .
                $dbh->errstr;
            return 1;
        }

        my $paramidx = 0;
        foreach my $col (@cols) {
            $paramidx += 1;
            $sth->bind_param( $paramidx, $use_href->{ $col } );
        }

        # finished with last entry
        unless( $sth->execute( ) ) {
            $LASTERROR = "Unable to execute 'update' profile statement\n" .
                $sth->err;
            return 1;
        }

        $sth->finish;
        undef $sth;

    }

    return 0;
}

=head2 update tftp <options and args>

Where <options and args> are

    --name id              Required unique id, suggest script name.
    --enable | --noenable  Enable module for use. [ no default ]
    --description "note"   Quoted note describing this script.
    --file <path/script>   Create a new version with this content.

There is no support for versioning of these files.

=cut

sub update_tftp
{
    my $type = 'tftp';
    my $file = "";

    my $sth;
    my $sql;
    my $href;
    my %save;

    my %entry = (
                 'name'         => "",
                 'description'  => "",
                 'enabled'      => "",
                 'insertion'    => "",
                 'change'       => "CURRENT_TIMESTAMP",
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'name'},
               'description=s'  => \$entry{'description'},
               'file=s'         => \$file,
               'enable!'        => \$entry{'enabled'},
               'disable'        => sub { $entry{'enabled'} = 0 },
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    unless ( $entry{'name'} ) {
        print "Required --name <name> not provided.\n";
        &help();
    }

    # get the current description and enabled states to see if we need to change
    my $sql_cols = lc get_cols( 'tftp' );
    $sql_cols =~ s/[ \t]*//g;

    $sql = qq|SELECT $sql_cols
              FROM $tbl{ $type }
              WHERE name = ?
              ORDER BY id|;

    print "$sql\n" if $debug;
    unless ( $sth = $tftph->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'update' tftp query\n" . $tftph->errstr;
        return 1;
    }

    unless ( $sth->execute( $entry{'name'} ) ) {
        $LASTERROR = "Unable to execute 'update' tftp query\n" . $sth->err;
        return 1;
    }

    my $entry_data;
    my $rowcount = 0;
    my %id;

    # store off first entry
    while ( $href = $sth->fetchrow_hashref( ) ) {
        while ( my ($key, $val) = each %{$href} ) {
            print "update $rowcount - $href->{'id'} entry:  $key => $val\n" if $debug;
        }
        unless ( $rowcount ) {
            while ( my ($key, $val) = each %{$href} ) {
                if ( $key ne "bin" ) {
                    $save{ $key } = $val;
                    if ( $debug and $val ) {
                        print "1 entry $href->{'id'}:  $key => $val\n";
                    } elsif ( $debug ) {
                        print "2 entry $href->{'id'}:  $key =>\n";
                    }
                }
            }
        }
        $rowcount += 1;
        $id{ $href->{'id'} } = $href->{'id '};
        $entry_data .= &bytea_decode( $href->{'bin'} );
    }

    unless ( $rowcount ) {
        $LASTERROR = "Entry not found for update: tftp $entry{'name'}.\n";
        return 1;
    }

    my $desc_needed = 0;
    my $stat_needed = 0;

    if ( defined $entry{'enabled'} && $entry{'enabled'} ne "" ) {
        if ( $save{'enabled'} ne $entry{'enabled'} ) {
            $save{'enabled'} = $entry{'enabled'};
            $stat_needed = 1;
        }
    }

    if ( defined $entry{'description'} && $entry{'description'} ne "" ) {
        if ( $save{'description'} ne $entry{'description'} ) {
            $save{'description'} = $entry{'description'};
            $desc_needed = 1;
        }
    }

    # if first change we don't have a value in entry.
    $save{'change'} = $entry{'change'};

    # determine if updating file now so can remove all entries -
    # then add data entries - after update status and desc if needed

    if ( $file ne "" ) {

        if ( ! $file ) {
            $LASTERROR = "Need --file <file> to add. Unable to find: $file.\n";
            return 1;
        }

        # grab file content for comparison with current entry 'data'
        open (FILE, "<$file") || die "unable to open $file: $!\n";
        undef $/;
        my $file_data = <FILE>;  # slurp mode
        $/ = "\n";
        close FILE;

        # must check first - for refusing to 'update' with duplicate data
        if ( $file_data eq $entry_data ) {
            $LASTERROR = "Reject updating file entry with duplicate data\n";
            return 1;
        }

        # delete all old entries
        my $delete = qq|DELETE FROM $tbl{'tftp'} where name = '$entry{'name'}'|;
        unless ( $sth = $tftph->do( $delete ) ) {
            $LASTERROR = "Unable to do 'update' tftp removal\n" .
                $tftph->errstr;
            return 1;
        }

        my $sql_cols = lc get_cols( 'tftp' );
        $sql_cols =~ s/[ \t]*//g;
        my @cols = split( /,/, $sql_cols );

        my $sql_vals = "";
        $sql_cols = "";

        foreach my $col ( @cols ) {
            next if ( $col eq "id" );  # do not include autoincr key in sql
            if ( $col eq "bin" ) {
                $sql_cols .= "$col,";
                $sql_vals .= "?,";
                next;
            }
            if ( $save{ $col } ne "" ) {
                $sql_cols .= "$col,";
                if ( $col eq "change" ) {
                    # do not quote CURRENT_TIMESTAMP or other sql expressions
                    $sql_vals .= qq|$save{ $col },|;
                } else {
                    $sql_vals .= qq|'$save{ $col }',|;
                }
            }
        }
        chop $sql_cols;
        chop $sql_vals;

        $sql = qq|INSERT INTO $tbl{ 'tftp' }
                  ( $sql_cols )
                  VALUES ( $sql_vals )
                 |;
        print $sql . "\n" if $debug;

        unless ( $sth = $dbh->prepare( $sql ) ) {
            $LASTERROR = "Unable to prepare 'update' tftp statement\n" .
                $dbh->errstr;
            return 1;
        }

        # open the file again to be read in by chunks to store
        my $fh;
        open ($fh, "<", $file) || die "unable to open $file: $!\n";

        my $bytes = 1;
        while ( $bytes ) {
            read $fh, $bytes, $maxlen;
            $file_data = &bytea_encode( $bytes );
            if ( $bytes ) {
                unless ( $sth->execute( $file_data ) ) {
                    $LASTERROR = "Unable to execute 'update' tftp statement\n" .
                        $sth->err;
                    return 1;
                }
            }
        }

        close $fh;

    } elsif ( $desc_needed == 1 || $stat_needed == 1 ) {

        # no file to play with so only updating the status, description, or both
        my $sql_cols;
        my $sql_vals;

        if ( $desc_needed == 1 ) {
            $sql_cols .= "description";
            $sql_vals .= "'$save{'description'}'";
        }
        if ( $stat_needed == 1 ) {
            $sql_cols .= "," if ( $sql_cols );
            $sql_vals .= "," if ( $sql_vals );
            $sql_cols .= "enabled";
            $sql_vals .= "'$save{'enabled'}'";
        }
        $sql_cols .= ",insertion,change";
        $sql_vals .= ",'$save{'insertion'}', CURRENT_TIMESTAMP";

        $sql = qq|UPDATE $tbl{ $type }
                  SET ( $sql_cols ) = ( $sql_vals )
                  WHERE id = ?|;

        unless ( $sth = $tftph->prepare( $sql ) ) {
            $LASTERROR = "Unable to prepare 'update' statement\n" .
                $tftph->errstr;
            return 1;
        }

        foreach my $id ( sort keys %id ) {
            print "update id $id\n" if $debug;
            unless ( $sth->execute( $id ) ) {
                $LASTERROR = "Unable to execute 'update' statement\n" .
                    $sth->err;
                return 1;
            }
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

=head2 update hardware <options and args>

Where <options and args> are

    --name id              Required unique id.

    --addcert <distro>     Supported distros for this hardware
    --rmcert  <distro>     List of distros no longer supported

The cert options may be specified multiple times.

=cut

sub update_hardware
{
    my $type = 'oscert';

    my %entry = (
                 'hardwareid'  => "",
           #     'hwdriver'    => "",
                 'addcert'     => "",
                 'rmcert'      => "",
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'hardwareid'},
             # 'hwdriver=s'     => \&multiarg_handler,
               'addcert=s'      => \&multiarg_handler,
               'rmcert=s'       => \&multiarg_handler,
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

  # multiarg creates hash entry with a space seperated list of unique values

  # $entry{'hwdriver'} =
  #     $multiarg{ 'hwdriver' } if (defined $multiarg{ 'hwdriver' });
    $entry{'addcert'} =
        $multiarg{ 'addcert' } if (defined $multiarg{ 'addcert' });

    $entry{'rmcert'} =
        $multiarg{ 'rmcert' } if (defined $multiarg{ 'rmcert' });

    unless ( $entry{'hardwareid'} ) {
        print "Required --name <name> not provided.\n";
        &help();
    }

    unless ( &check_hardware( $entry{'hardwareid'} ) ) {
        $LASTERROR = "Unable to update hardware, $entry{'hardwareid'} does not exist\n";
        return 1;
    }

    if (! $entry{'addcert'} eq "" ) {
        my $status = &update_cert($type, $entry{'hardwareid'}, "addcert", $entry{'addcert'});
    }

    if (! $entry{'rmcert'} eq "" ) {
        my $status = &update_cert($type, $entry{'hardwareid'}, "rmcert", $entry{'rmcert'});
    }

    return 0;
}



=head2 export E<lt>typeE<gt> <options and args>

Where <type> may be module, profile, or tftp.  Not hardware.

For similar functionality with hardware type it is suggested to simply redirect the 'detail <type>' output. With these types there is no actual 'data' portion and no related '--file' argument used to add them.

Where <options and args> are

    --name <name>          Data of named entry used. [ default <file> ].
    --file <path/file>     Create this new flie with db data contents.
    --version <ver>        Required specifier for module or profile types.

=cut

sub export
{
    my $type = shift;
    my $file = "";

    my %entry = (
                 'name'         => "",
                 'version'      => "",  # not used for tftp
                 'description'  => "",
                 );

    @ARGV = @_;
    GetOptions(
               'name=s'         => \$entry{'name'},
               'description=s'  => \$entry{'description'},
               'version=i'      => \$entry{'version'},
               'file=s'         => \$file,
               );

    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    unless ( $file ne "" ) {
        print "Required --file <path/file> not provided.\n";
        &help( "export" );
    }

    if ( -e $file ) {
        $LASTERROR = "Unwilling to overwrite existing <path/file>: $file\n";
        return 1;
    }

    if ( $entry{'version'} eq "" ) {
        unless ( $type eq "tftp" ) {
            $LASTERROR = "Required --version <ver> not provided.\n";
            return 1;
        }
    } elsif ( $type eq "tftp" ) {
        print "Ignoring unsupported --version specifier for type $type\n";
    }

    if ( $entry{'name'} eq "" ) {
        $entry{'name'} = $file;
        $entry{'name'} =~ s|.*/||;       # only the short name for the lookup
    }

    my $sql;
    my $db2use = $dbh;

    if ( $type eq "module" ) {
        $sql = qq|SELECT data
                  FROM $tbl{ $type }
                  WHERE moduleid = '| . $entry{'name'} . qq|'
                  AND version = '| . $entry{'version'} . qq|'|;
    } elsif ( $type eq "profile" ) {
        $sql = qq|SELECT data
                  FROM $tbl{ $type }
                  WHERE profileid = '| . $entry{'name'} . qq|'
                  AND version = '| . $entry{'version'} . qq|'|;
    } elsif ( $type eq "tftp" ) {
        $sql = qq|SELECT bin as data
                  FROM $tbl{ $type }
                  WHERE name = '| . $entry{'name'} . qq|'
                  ORDER BY id
                 |;
        $db2use = $tftph;
    } else {
        $LASTERROR = "Unsuported type $type for export command\n";
        return 1;
    }

    my $sth;
    my $href;

    unless ( $sth = $db2use->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'export' statement\n" . $db2use->errstr;
        return 1;
    }

    unless( $sth->execute( ) ) {
        $LASTERROR = "Unable to execute 'export' statement\n" . $sth->err;
        return 1;
    }

    open( my $fh, ">", $file ) or die "Unable to open $file: $!\n";

    my $rowcount = 0;
    my $row;
    while( $href = $sth->fetchrow_hashref( ) ) {
        $rowcount += 1;
        if ( $type ne "tftp" ) {
            $row = $href->{'data'};
        } else {
            $row = &bytea_decode ( $href->{'data'} );
        }
        print $fh $row;
    }
    close $fh;

    $sth->finish;
    undef $sth;

    return 0
}

=head2 detail E<lt>typeE<gt> E<lt>nameE<gt> [ --all | --version <ver> ]

Takes <type> and <name> as arguments.

Fetch and display the details about the entry in the type database.

Only the 'enabled' version is shown unless --all or --version specified. If option --all is used all module or profile versions are displayed.  Also, --version <ver> can be used to display on the desired version.

=cut

sub detail
{
    my $type = shift;
    my $name = shift;
    my $href;
    my $version = 0;

    @ARGV=@_;
    if ( ( $type eq "module" ) || ( $type eq "profile" ) ) {
        GetOptions(
                   'version=i'      => \$version,
                   );
    }
    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    if ( $version && $all ) {
        $LASTERROR = "Please use either --all _or_ --version <ver>. Not both.\n";
        return 1;
    }

    $type = lc $type;
    &check_type( $type );

    unless ( defined $name) {
        &help();
    }
    $name =~ s|.*/||;           # only the short name for the lookup

    my $sql_cols = lc get_cols( $type );
    my $sql = qq| SELECT $sql_cols FROM $tbl{ $type } |;
    my $sql_cert;
    my $sql_man;
    my $sql_chunks;

    my $db2use = $dbh;

    if ( $type eq "hardware" ) {
        $sql .= "WHERE hardwareid = ?";

       # $sql_cols = lc get_cols( 'oscert' );
        $sql_cert = qq|SELECT distroid
                       FROM $tbl{ 'oscert' }
                       WHERE hardwareid = '| . $name . qq|'|;
    } elsif ( $type eq "module" ) {
        $sql .= "WHERE moduleid = ?";
        $sql .= " AND version = $version" if ( $version );

        $sql_cert = qq|SELECT distroid
                       FROM $tbl{ 'modcert' }
                       WHERE moduleid = '| . $name . qq|'|;

        $sql_man = qq|SELECT distroid
                       FROM $tbl{ 'modcert' }
                       WHERE moduleid = '| . $name . qq|'
                       AND mandatory = 't'|;
    } elsif ( $type eq "profile" ) {
        $sql .= "WHERE profileid = ?";
        $sql .= " AND version = $version" if ( $version );
    } elsif ( $type eq "tftp" ) {
        $sql .= "WHERE name = ?";
        $sql .= " ORDER BY id";

        $sql_chunks = qq|SELECT bin
                         FROM $tbl{ $type }
                         WHERE name =  '| . $name .
                      qq|' ORDER BY id|;

        $db2use = $tftph;
    }

    my $sth;
    unless ( $sth = $db2use->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'detail' statement\n" . $db2use->errstr;
        return 1;
    }

    unless( $sth->execute( $name ) ) {
        $LASTERROR = "Unable to execute 'detail' statement\n" . $sth->err;
        return 1;
    }

    my $rowcount = 0;
    my $printcount = 0;
    my $tftpname = "";
    my $tftpdata;

    while( $href = $sth->fetchrow_hashref( ) ) {
        $rowcount += 1;
        if ( $type eq "module" ) {
            if ( $all ||
                 $href->{'status'} ||
                 $href->{'version'} == $version ) {
                print "\n# ba #####" if $all;
                unless ( $nolabels ) {
                    print  "# ba\n";
                    printf "# ba module: %s\n",      $href->{'moduleid'};
                    printf "# ba description: %s\n", $href->{'description'};
                   #printf "# ba interpreter: %s\n", $href->{'interpreter'};
                    printf "# ba enabled: %s\n",     $href->{'status'}
                        if ( $all || $version );
                    printf "# ba version: %s\n",     $href->{'version'};
                    print  "# ba\n";
                }

                my $modcert = "";
                my $certs = $db2use->selectall_arrayref( $sql_cert, { slice => {} } );
                if ( defined $certs ) {
                    foreach my $cert ( @{$certs} ) {
                        $modcert .= ":" if ( $modcert ne "" );
                        $modcert .= @{$cert}[0];
                    }
                }
                printf "# ba cert=%s\n", $modcert if ( defined $modcert );

                my $modman = "";
                my $mancerts = $db2use->selectall_arrayref( $sql_man, { slice => {} } );
                if ( defined $mancerts ) {
                    foreach my $mancert ( @{$mancerts} ) {
                        $modman .= ":" if ( $modman ne "" );
                        $modman .= @{$mancert}[0];
                    }
                }
                printf "# ba mandatory=%s\n", $modman if ( defined $modman );

                print  $href->{'data'};
                $printcount += 1;
            }
        }
        if ( $type eq "profile" ) {
            if ( $all ||
                 $href->{'status'} ||
                 $href->{'version'} == $version ) {
                print "\n# ba #####" if $all;
                unless ( $nolabels ) {
                    print  "# ba\n";
                    printf "# ba profile: %s\n",     $href->{'profileid'};
                    printf "# ba description: %s\n", $href->{'description'};
                    printf "# ba enabled: %s\n",     $href->{'status'}
                        if ( $all || $version );
                    printf "# ba version: %s\n",     $href->{'version'};
                    print  "# ba\n";
                }
                print  $href->{'data'};
                $printcount += 1;
            }
        }
        if ( $type eq "hardware" ) {
            printf "[%s]\n",            $href->{'hardwareid'} unless $nolabels;
            printf "description=%s\n",  $href->{'description'};
            printf "bootArgs=%s\n",     $href->{'bootargs'};
            printf "rootDisk=%s\n",     $href->{'rootdisk'};
            printf "rootPart=%s\n",     $href->{'rootpart'};
            printf "pxeTemplate=%s\n",  $href->{'pxetemplate'};
            printf "yastTemplate=%s\n", $href->{'yasttemplate'};
            printf "hwdriver=%s\n",     $href->{'hwdriver'};
            $printcount += 1;

            my $oscert = "";
            my $certs = $db2use->selectall_arrayref( $sql_cert, { slice => {} } );
            if ( defined $certs ) {
                foreach my $cert ( @{$certs} ) {
                    $oscert .= ":" if ( $oscert ne "" );
                    $oscert .= @{$cert}[0];
                }
            printf "oscert=%s\n", $oscert if ( defined $oscert );
            }
        }
        if ( $type eq "tftp" ) {
            # because tftp file data is stored in chunks
            # need to collect the chunks before output
            if ( $tftpname ne $name ) {
                $tftpname = $name;
                # first time for 'name' encountered - get chunks
                my $chunks = $db2use->selectall_arrayref($sql_chunks,{slice=>{}});
                if ( defined $chunks and ( $all or $href->{'enabled'} ) ) {

                    unless ( $nolabels ) {
                        print  "# ba\n";
                        printf "# ba name: %s\n",     $href->{'name'};
                        printf "# ba description: %s\n", $href->{'description'};
                        printf "# ba enabled: %s\n",     $href->{'enabled'};
                        printf "# ba inserted: %s\n",    $href->{'insertion'}
                            if $verbose;
                        printf "# ba modified: %s\n",    $href->{'change'}
                            if ( defined $href->{'change'} && $verbose );
                        print  "# ba\n";
                    }
                    foreach my $chunk ( @{$chunks} ) {
                        $tftpdata .= &bytea_decode( @{$chunk}[0] );
                    }
                    if ( ( length $tftpdata ) < 512 ) {
                        print $tftpdata;
                    } else {
                        print "\n# File content will not be displayed.\n";
                        print "# file is large and may be binary.\n";
                        print "# please use the 'export' command.\n";
                    }
                    $printcount += 1;
                }
            }
        }
    }

    $sth->finish;
    undef $sth;

    if ( $printcount == 0 ) {
        $LASTERROR = "No $type named $name";
        $LASTERROR .= " *enabled* entry" if ( $rowcount && ! $version );
        $LASTERROR .= " version $version" if ( $version );
        $LASTERROR .= " found in db\n";
        return 1;
    }

    return 0;
}

=head2 remove E<lt>typeE<gt> E<lt>nameE<gt> [--version <ver>]

Takes <type> and <name> as arguments.

Removes all versions of <name> specified from <type> database.

Option --version <ver> can be provided to remove only the version specified.

=cut

sub remove
{
    my $type = shift;
    my $name = shift;
    my $version;

    $type = lc $type;
    &check_type( $type );

    unless ( defined $name) {
        &help();
    }
    $name =~ s|.*/||;           # only the short name for the lookup

    @ARGV = @_;
    if ( ( $type eq "module" ) || ( $type eq "profile" ) ) {
        GetOptions(
                   'version=i' => \$version,
                   );
    }
    if ( scalar @ARGV ) {
        $LASTERROR = sprintf "\nUnknown arg(s): %s\n", join(" ", @ARGV);
        return 1;
    }

    my @sql;

    my $db2use = $dbh;

    if ( $type eq "hardware" ) {
        @sql = ( qq|DELETE FROM $tbl{ $type } WHERE hardwareid = ?| );
    } elsif ( $type eq "module" ) {
        my $check = &get_mandatory( $name, 'all' );
        if ( $check == 1 ) {
            $LASTERROR = "Cannot remove module marked as mandatory\n";
            return 1;
        }
        @sql = ( qq|DELETE FROM $tbl{ $type } WHERE moduleid = ?|, qq|DELETE FROM $tbl{ modcert } WHERE moduleid = ?| );
    } elsif ( $type eq "profile" ) {
        @sql = ( qq|DELETE FROM $tbl{ $type } WHERE profileid = ?| );
    } elsif ( $type eq "tftp" ) {
        @sql = ( qq|DELETE FROM $tbl{ $type } WHERE name = ?| );
        $db2use = $tftph;
    }

    foreach my $sql (@sql) {
        if ( defined $version ) {
            $sql .= " AND version = $version";
        }

        my $sth;
        unless ( $sth = $db2use->prepare( $sql ) ) {
            $LASTERROR = "Unable to prepare 'remove' statement\n" . $db2use->errstr;
            return 1;
        }

        unless ( $sth->execute( $name ) ) {
            $LASTERROR = "Unable to execute 'remove' statement\n" . $sth->err;
            return 1;
        }

        $sth->finish;
        undef $sth;
    }

    return 0;
}

###########################################################################

sub check_command
{
    my $command = shift;

    my $cmd_list = join ', ', (sort keys %cmds);
    unless ( defined $command ) {
        print "Requires <command> (e.g. $cmd_list)\n";
        &help();
    }

    unless ( defined $cmds{ $command } ) {
        print "Invalid <command> '$command' please use:  $cmd_list\n";
        exit 1;
    }
}

sub check_type
{
    my $type = shift;
    my $type_list = "hardware, module, profile, tftp";

    return $type_list if ( $type eq "all" );

    unless ( defined $type ) {
        print "requires <type> (e.g. $type_list)\n";
        exit 1;
    }
    unless ( defined $tbl{ $type } ) {
        print "invalid <type> '$type' please use: $type_list\n";
        exit 1;
    }
    if ( $type eq "distro" ) {
        print "invalid <type> '$type' please use: $type_list\n";
        exit 1;
    }
    return $type;
}

# find - simple lookup to see if entry already exists
# return count of entries found or undef on error

sub find
{
    my $type = shift;
    my $name = shift;

    my $sth = &list_start( $type, $name );

    unless( defined $sth ) {
        $LASTERROR .= "Failed in find\n" . $LASTERROR;
        return undef;
    }

    my $rowcount = 0;
    while ( &list_next( $sth ) ) {
        $rowcount += 1;
    }
    &list_finish( $sth );

    return $rowcount;
}

sub list_start
{
    my $type  = shift;
    my $name  = shift;

    my $sql;

    my $db2use = $dbh;

    if ( $type eq "hardware" ) {
        $sql = qq|SELECT hardwareid as name, description
                  FROM $tbl{ $type }
                  WHERE hardwareid LIKE ?
                  ORDER BY name
                 |;
    } elsif ( $type eq "module" ) {
        $sql = qq|SELECT moduleid as name, description, version, status
                  FROM $tbl{ $type }
                  WHERE moduleid LIKE ? ORDER BY moduleid, version
                 |;
    } elsif ( $type eq "profile" ) {
        $sql = qq|SELECT profileid as name, description, version, status
                  FROM $tbl{ $type }
                  WHERE profileid LIKE ? ORDER BY profileid, version
                 |;
    } elsif ( $type eq "tftp" ) {
        $sql = qq|SELECT name, description, COUNT( id ) as count, enabled
                  FROM $tbl{ $type }
                  WHERE name LIKE ?
                  GROUP BY name, description, enabled
                  ORDER BY name
                 |;
        $db2use = $tftph;
    }

    my $sth;
    unless ( $sth = $db2use->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'list' query\n" . $db2use->errstr;
        return undef;
    }

    if (defined $name) {
        $name =~ s|.*/||;       # only the short name for the lookup
        $name = "%" . $name . "%";
    } else {
        $name = "%";
    }

    unless( $sth->execute( $name ) ) {
        $LASTERROR = "Unable to execute 'list' query" . $sth->err;
        return undef;
    }

    return $sth;
}

sub list_next
{
    my $sth = shift;

    return $sth->fetchrow_hashref();
}

sub list_finish
{
    my $sth = shift;
    $sth->finish;
    undef $sth;
}

sub get_cols
{
    my $tbl = shift;
    my $baracustbls = BaracusSql::get_baracus_tables()->{ $tbl{ $tbl } };
    my $sqltftptbls = BaracusSql::get_sqltftp_tables()->{ $tbl{ $tbl } };
    if ( defined $baracustbls ) {
        return BaracusSql::keys2columns( $baracustbls );
    }
    elsif ( defined $sqltftptbls ) {
        return BaracusSql::keys2columns( $sqltftptbls );
    }
    else {
        die "Internal database table/name usage error.\n";
    }
}

# get_versions
#
# args: type (module, hardware, profile, tftp), $name, $version
# ret:  hash to entries found to specified, highest, enabled versions on match
#         or undef on error

sub get_versions
{
    my $type = shift;
    my $name = shift;
    my $vers = shift;

    my $sth;
    my $href;
    my $version_href;
    my $highest_href;
    my $enabled_href;

    $vers = 0 unless ( defined $vers );

    my $sql_cols = lc get_cols( $type );
    my $sql = qq| SELECT $sql_cols FROM $tbl{ $type } |;

    if ( $type eq "module" ) {
        $sql .= "WHERE moduleid = ?";
    }
    elsif ( $type eq "profile" ) {
        $sql .= "WHERE profileid = ?";
    }
    else {
        print "Expected 'module' or 'profile'\n";
        exit 1;
    }

    $sql .= " ORDER BY version;";

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'get_entry' statement\n" . $dbh->errstr;
        return ( undef, undef, undef );
    }

    unless( $sth->execute( $name ) ) {
        $LASTERROR = "Unable to execute 'get_entry' statement\n" . $sth->err;
        return ( undef, undef, undef );
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        $version_href = $href if ( $href->{'version'} == $vers);
        $highest_href = $href;
        $enabled_href = $href if ( $href->{'status'} == 1 );
    }

    $sth->finish;
    undef $sth;

    return ( $version_href, $highest_href, $enabled_href );
}

sub update_cert
{
    my $type = shift;
    my $id = shift;
    my $action = shift;
    my $cert = shift;
    my $mandatory = shift;
    my $sth;

    if ( $action eq "addcert" ) {
        my @cert_add = split( /\s/, $cert );
        foreach my $cert_in ( @cert_add ) {
            unless ( &check_cert( $type, $id, $cert_in ) ) {
                $LASTERROR = "Unable to update cert, $cert_in already exists\n";
                  return 1;
            }
        }

        foreach my $cert_in ( @cert_add ) {
            unless ( &check_distroid($cert_in) ) {
              $LASTERROR = "Unable to update cert: $cert_in does not exist\n";
                return 1;
            }
        }

        my $sql_cols = lc get_cols( $type );
        $sql_cols =~ s/[ \t]*//g;
        my @cols = split( /,/, $sql_cols );
        my $sql_vals = "?," x scalar @cols; chop $sql_vals;

        my $add_sql = qq|INSERT INTO $tbl{ $type }
                         ( $sql_cols )
                         VALUES ( $sql_vals )
                        |;

        unless ( $sth = $dbh->prepare( $add_sql ) ) {
            $LASTERROR = "Unable to prepare 'update' hardware statement\n" .
                $dbh->errstr;
            return 1;
        }

        my $success = 1;
        foreach my $cert_in (@cert_add) {
           if ( $type eq "oscert") {
               $sth->bind_param( "1", $cert_in );
               $sth->bind_param( "2", $id );
            }
            elsif ( $type eq "modcert" ) {
                $sth->bind_param( "1", $id );
                $sth->bind_param( "2", $cert_in );
                $sth->bind_param( "3", $mandatory );
            }
            $success &&= $sth->execute( );
        }

        unless ($success) {
            die "Unable to execute 'add' cert statement\n" .
                $sth->errstr;
            return 1;
        }

        $sth->finish;
        undef $sth;
    }

    if ( $action eq "rmcert" ) {

        my $rm_sql = qq|DELETE FROM $tbl{ $type }
                        WHERE distroid = ?
                       |;

        my @cert_rm = split( /\s/, $cert );

        unless ( $sth = $dbh->prepare( $rm_sql ) ) {
            $LASTERROR = "Unable to prepare 'update' cert statement\n" .
                $dbh->errstr;
            return 1;
        }

        my $success = 1;
        foreach my $cert_out (@cert_rm) {
            $success &&= $sth->execute( $cert_out );
        }

         unless ($success) {
            die "Unable to execute 'remove' cert statement\n" .
                $sth->errstr;
            return 1;
        }

        $sth->finish;
        undef $sth;
    }

    return 0;
}

sub check_enabled
{
    my $moduleid = shift;

    my $sth;
    my $href;

    my $sql = qq| SELECT status
                  FROM $tbl{ module }
                  WHERE moduleid = ?
                  AND version >= 1
                |;

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_enabled' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $moduleid ) ) {
        $LASTERROR =
            "Unable to execute 'check_enabled' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'status'}) {
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub check_mandatory
{
    my $moduleid = shift;

    my $sth;
    my $href;

    my $sql = qq| SELECT mandatory
                  FROM $tbl{ module }
                  WHERE moduleid = ?
                  AND version >= 1
                |;

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_mandatory' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $moduleid ) ) {
        $LASTERROR =
            "Unable to execute 'check_mandatory' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'mandatory'}) {
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub check_distroid
{
    my $distroid = shift;

    my $sth;
    my $href;

    my $sql = qq| SELECT distroid
                  FROM $tbl{ distro }
                  WHERE distroid = ?
                |;

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_distroid' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $distroid ) ) {
        $LASTERROR =
            "Unable to execute 'check_distroid' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'distroid'}) {
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub check_hardware
{
    my $hardwareid = shift;

    my $sth;
    my $href;

    my $sql = qq| SELECT hardwareid
                  FROM $tbl{ hardware }
                  WHERE hardwareid = ?
                |;

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_hardwareid' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $hardwareid ) ) {
        $LASTERROR =
            "Unable to execute 'check_hardware' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'hardwareid'}) {
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub check_module
{
    my $moduleid = shift;

    my $sth;
    my $href;

    my $sql = qq| SELECT moduleid
                  FROM $tbl{ module }
                  WHERE moduleid = ?
                |;

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_module' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $moduleid ) ) {
        $LASTERROR =
            "Unable to execute 'check_module' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'moduleid'}) {
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub check_cert
{

    my $type = shift;
    my $id = shift;
    my $cert_in = shift;

    my $sth;
    my $href;
    my $sql;

    if ( $type eq "oscert" ) {
        $sql = qq| SELECT distroid 
                      FROM $tbl{ $type }
                      WHERE hardwareid = '$id'
                      AND distroid = '$cert_in'
                    |;
    }
    elsif ( $type eq "modcert" ) {
        $sql = qq| SELECT distroid 
                      FROM $tbl{ $type }
                      WHERE moduleid = '$id'
                      AND distroid = '$cert_in'
                    |;
    }

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'check_cert' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute(  ) ) {
        $LASTERROR =
            "Unable to execute 'check_cert' statement\n" . $sth->err;
        return 0;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'distroid'}) {
            return 0;
        }
    }

    $sth->finish;
    undef $sth;

    return 1;
}

# rendundant_data
#
#   when possibly adding a new version we make sure that the
#   'data' is not already pressent in another entry. if it is
#   return 1 - with LASTERROR of the version already present.

sub redundant_data
{
    my $type = shift;
    my $name = shift;
    my $data = shift;

    my $sth;
    my $href;

    my $sql_cols = lc get_cols( $type );
    my $sql = qq| SELECT $sql_cols FROM $tbl{ $type } |;

    if ( $type eq "module" ) {
        $sql .= "WHERE moduleid = ?";
    }
    elsif ( $type eq "profile" ) {
        $sql .= "WHERE profileid = ?";
    }
    else {
        print "Expected 'module' or 'profile'\n";
        exit 1;
    }

    $sql .= " ORDER BY version;";

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR =
            "Unable to prepare 'redundant_data' statement\n" . $dbh->errstr;
        return 1;
    }

    unless( $sth->execute( $name ) ) {
        $LASTERROR =
            "Unable to execute 'redundant_data' statement\n" . $sth->err;
        return 1;
    }

    while( $href = $sth->fetchrow_hashref( ) ) {
        if ($href->{'data'} eq $data) {
            $LASTERROR =
                "Reject adding new version with content identical to this version: $href->{'version'}\n";
            return 1;
        }
    }

    $sth->finish;
    undef $sth;

    return 0;
}

sub change_status
{
    my $type = shift;
    my $stat = shift;
    my $href = shift;

    unless (defined $href && defined $href->{'status'} ) {
        $LASTERROR = "Unable to modify status without valid entry\n";
        return 1;
    }

    # don't change to what we already are
    return 0 if ( $href->{'status'} eq $stat );

    my $id;

    if ( $type eq "module" ) {
        $id = 'moduleid';       
        if ( $stat eq "f") {
            ## Verify that the module is not mandatory
            unless ( &check_mandatory( $href->{ '$id' } ) ) {
                $LASTERROR = "Unable to disable module set for mandatory.\n";
                return 1;
             } 
        }
    } elsif ( $type eq "profile" ) {
        $id = 'profileid';
    } else {
        print "Expected 'module' or 'profile'\n";
        exit 1;
    }

    my $sql = qq|UPDATE $tbl{ $type }
                 SET status = '$stat'
                 WHERE $id = '$href->{ $id }'
                 AND version = '$href->{'version'}'
                |;
    print $sql . "\n" if $debug;

    # update specified version
    my $sth;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'change_status' statement\n" .
            $dbh->errstr;
        return 1;
    }
    unless ( $sth->execute( ) ) {
        $LASTERROR = "Unable to execute 'change_status' statement\n" .
            $sth->err;
        return 1;
    }
    return 0;
}

sub get_mandatory
{
    my $moduleid = shift;
    my $cert = shift;

    my $sql = qq|SELECT mandatory
                 FROM $tbl{ modcert }
                 WHERE moduleid = ?
                |;

    if ( $cert eq "all" ) {
        $sql .= " AND distroid LIKE '%';";
    } else {
        $sql .= " AND distroid = '$cert';";
    }

    print $sql . "\n" if $debug;

    my $sth;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'get_mandatory' statement\n" .
            $dbh->errstr;
        return 1;
    }
    unless ( $sth->execute( $moduleid ) ) {
        $LASTERROR = "Unable to execute 'get_mandatory' statement\n" .
            $sth->err;
        return 1;
    }

    my $href = $sth->fetchrow_hashref();

    ## Return 3 if neither optional or mandatory
    ## 3 = new entry
    unless( defined $href->{'mandatory'} ) {
        $href->{'mandatory'} = 3;
    }

    $sth->finish;
    undef $sth;

    return  $href->{'mandatory'};
}

sub change_mandatory
{
    my $mandatory = shift;
    my $moduleid = shift;
    my $cert = shift;

    unless (defined $mandatory && defined $moduleid && defined $cert ) {
        $LASTERROR = "Unable to modify mandatory without valid entry\n";
        return 1;
    }

    my $sql = qq|UPDATE $tbl{ modcert }
                 SET mandatory = '$mandatory'
                 WHERE moduleid = '$moduleid'
                 AND distroid = '$cert'
                |;

    print $sql . "\n" if $debug;

    # update specified version
    my $sth;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'change_mandatory' statement\n" .
            $dbh->errstr;
        return 1;
    }
    unless ( $sth->execute( ) ) {
        $LASTERROR = "Unable to execute 'change_mandatory' statement\n" .
            $sth->err;
        return 1;
    }
    return 0;
}

sub change_description
{
    my $type = shift;
    my $desc = shift;
    my $href = shift;

    unless (defined $href && defined $href->{'description'} ) {
        $LASTERROR = "Unable to modify description without valid entry\n";
        return 1;
    }

    # don't change to what we already are
    return 0 if ( $href->{'description'} eq $desc );

    my $id;

    if ( $type eq "module" ) {
        $id = 'moduleid';
    } elsif ( $type eq "profile" ) {
        $id = 'profileid';
    } else {
        print "Expected 'module' or 'profile'\n";
        exit 1;
    }

    my $sql = qq|UPDATE $tbl{ $type }
                 SET description = '$desc'
                 WHERE $id = '$href->{ $id }'
                 AND version = '$href->{'version'}'
                |;
    print $sql . "\n" if $debug;

    # update specified version
    my $sth;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'change_status' statement\n" .
            $dbh->errstr;
        return 1;
    }
    unless ( $sth->execute( ) ) {
        $LASTERROR = "Unable to execute 'change_status' statement\n" .
            $sth->err;
        return 1;
    }
    return 0;
}

###########################################################################

# this arg handling will parse many variations
# --module=doOne,doTwo --module doThree --module "doFour,doFive doSix"
# --vars=doOne=hey,doTwo=there --vars "doThree=love,doFour=or doFive=not"
sub multiarg_handler() {
    my $option = $_[0];
    my $value  = $_[1];
    my @values;
    if ( $value ne '' ) {
        # arg specified - push into array
        @values = split(/[,\s*]/,$value);
    } else {
        # no value profided and no defaults
        # with '=s' should not get here
        # we could 'die("FINISH")'
        # but for now just return
        return;
    }
    foreach $value (@values) {
        if ( $option eq "vars" ) {
            # special check for key=value assignment syntax
            die("FINISH") if ( $value !~ m/=/ );
        }
        if (not defined $multiarg{ $option } ){
            # initialize
            $multiarg{ $option } = "$value";
        }
        elsif ( $multiarg{ $option } !~ m/$value/ ) {
            # append if not already present
            $multiarg{ $option } .= " $value";
        }
    }
}

die "ABSOLUTELY DOES NOT EXECUTE";

__END__

