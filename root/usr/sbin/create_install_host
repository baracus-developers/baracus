#!/usr/bin/perl -w

use strict;
use POSIX qw/strftime/;
use Term::ReadKey;
use Tie::IxHash;
use Config::General;
use Config::Simple;
use File::Temp qw/ tempdir /;
use XML::Simple;
use DBI;
use DBD::Pg qw(:pg_types);

use lib "/usr/share/baracus/perl";

use SqlFS;
use BaracusDB;

my $command;
my $subcommand;
my $arg;
my $hostname="";
my $ip="";
my $mac;
my $hardware="";
my $os="";
my $module="";
my $profile="";
my $vars;
my $add;
my $remove;
my $list;
my $verify;
my $help;
my $verbose;
my $debug;
my $moduledir="";
my $templatedir="";
my $confdir="";
my $dbname="";
my $dbargs={};
my $dbh={};
my $datadir="";
my $buildip="";
my $buildroot="";
my $baracusdir;
my %bdir;
my $type="";
my %multiarg;

sub get_usage() {

    print <<MARKER1;
Usage:
    create_install_host command [subcommand] [options]

Where command is one of

    add     <arg1 arg2 arg3> [etc.] : add a new build source
                                      for details use: 'add --help'
    remove  --hostname <x>          : delete a build template for host <x>
    verify  --hostname <x>          : verify build template for host <x> (TBD)
    list    <hardware>              : list hardware profiles
    list    <templates>             : list host templates
    list    <history>               : list build client template history

Options are

    -v|--verbose                    : verbose output
    -h|--help                       : this (help) message

MARKER1

    exit 1;
}

sub get_usage_add() {

    print <<MARKER2;
Usage:
    create_install_host add --hostname <x> --mac <y> --ip <z> [more...]

    Where

    --hostname <x>          : <x> intended name for the build client
    --ip <y>                : <y> client static, or dhcp bound, IP address
    --mac <z>               : <z> client network interface physical address

    Other required parameters, which may be specified in a profile are:

    --distro <base-arch>    : OS to install on build client - made ready with
                              'create_install_source add --distro <base-arch>'
    --hwtype <hwteplate>    : hardware template that describes the build client

    And further parameters include

    --profile <pfile>       : file with networking and other template parameters
                              there is a 'default' profile of that name here
                              /etc/baracus.d/profiles/default
    --module <mfile>        : yast autoinstall scripts to run on build complete
                              you can specify this option multipls times
    --vars <variable=value> : a method to specify a command line parameter
                              that will override those found in the config files
                              you can specify this option multipls times

MARKER2

    exit 1;
}

sub get_hexIP() {

    ## Determine IP in Hex
    ##
    my $ip = shift @_;

    my @hexIP = split(/\./, $ip);
    foreach (@hexIP) {
        $_ = sprintf("%02X", $_);
    }
    my $hexIP = join('',@hexIP,);

    return($hexIP);

}

sub get_uuid() {

    ## Generate a new UUID
    ##
    use Data::UUID;

    my $ug = new Data::UUID;

    return $ug->to_string( $ug->create() );
}

sub get_rundate() {

    ## Generate timestamp for run
    ##
    my $now = time;
    my $rundate=strftime "%Y-%m-%d %H:%M:%S", localtime($now);
    return $rundate;

}

sub list_db_history() {

    my $hostname = shift @_;
    $hostname =~ s/\*/\%/g;
    print "$hostname\n";

    my $sql = q|SELECT hostname,
                           ip,
                           iphex,
                           mac,
                           uuid,
                           state,
                           stateOLD,
                           cmdline,
                           creation,
                           change
                    FROM templateidhist
                    WHERE hostname LIKE ?|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute($hostname)
        or die "Cannot execute sth: ",$sth->errstr;

    return $sth->fetchall_arrayref();
}

sub add_db_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $sql = q|INSERT INTO templateid ( hostname,
                             ip,
                             iphex,
                             mac,
                             uuid,
                             state,
                                             cmdline,
                             creation,
                             change )
                VALUES ( ?, ?, ?, ?, ?, 1, ?, CURRENT_TIMESTAMP(2), CURRENT_TIMESTAMP(2) )|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->bind_param( 1,  $Hash{'hostname'}  );
    $sth->bind_param( 2,  $Hash{'ip'}        );
    $sth->bind_param( 3,  $Hash{'hexip'}     );
    $sth->bind_param( 4,  $Hash{'mac'}       );
    $sth->bind_param( 5,  $Hash{'uuid'}      );
    $sth->bind_param( 6,  $Hash{'cmdline'}   );

    $sth->execute()
        or die "Cannot execute sth: ", $sth->errstr;
}

sub get_db_host_entry() {

    my $hostname = shift @_;

    my $sql = q|SELECT hostname,
                   ip,
                   iphex,
                   mac,
                   uuid,
                   state,
                   creation,
                   change
                    FROM templateid
                    WHERE hostname = ? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute( $hostname )
        or die "Cannot execute sth: ",$sth->errstr;

    return $sth->fetchrow_hashref();
}

sub get_db_list_entry() {

    my $sql = q|SELECT hostname,
                           iphex,
                           mac
                    FROM templateid
            WHERE state <> '4'|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute()
        or die "Cannot execute sth: ",$sth->errstr;

    return $sth->fetchall_arrayref();

}

sub update_db_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $sql = q|UPDATE templateid SET ip=?,
                              iphex=?,
                          mac=?,
                          uuid=?,
                          state=5,
                          change=CURRENT_TIMESTAMP
                WHERE hostname=? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->bind_param( 1,  $Hash{'ip'}        );
    $sth->bind_param( 2,  $Hash{'hexip'}     );
    $sth->bind_param( 3,  $Hash{'mac'}       );
    $sth->bind_param( 4,  $Hash{'uuid'}      );
    $sth->bind_param( 5,  $Hash{'hostname'}  );

    $sth->execute()
        or die "Cannot execute sth: ",$sth->errstr;
}

sub remove_db_host_entry() {
    my $hostname = shift @_;

    #   my $sql = q|UPDATE templateid SET state=4,
    #                             change=CURRENT_TIMESTAMP
    #                   WHERE hostname=? |;

    my $sql = q|DELETE FROM templateid
                    WHERE hostname=? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute( $hostname )
        or die "Cannot execute sth: ",$sth->errstr;
}

sub add_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    ## Verify Mandatory parameters
    ##
    unless ($Hash{'hostname'}) {
        print "Missing  --hostname\n";
        &get_usage_add;
    }
    unless ($Hash{'ip'}) {
        print "Missing  --ip\n";
        &get_usage_add;
    }
    unless ($Hash{'mac'}) {
        print "Missing  --mac\n";
        &get_usage_add;
    }

    my $autoYastTemplate = join "/", $templatedir, $Hash{'os'}, $Hash{'arch'}, $Hash{'yastTemplate'};
    my $pxeTemplate      = join "/", $templatedir, $Hash{'os'}, $Hash{'arch'}, "pxetemplates", $Hash{'pxeTemplate'};

    if ($debug) {
        print "autoYastTemplate = $autoYastTemplate\n";
        print "pxeTemplate = $pxeTemplate\n";
    }

    if ((! -f $autoYastTemplate ) || (! -f $pxeTemplate )) {
        print "\nOne or both of the base template files for pxe and autoyast cannot be found here:\n";
        print "\n$autoYastTemplate\n$pxeTemplate\n";
        print "\nPlease refer to the README found in $templatedir/\n";
        exit 1;
    }

    ## Read in autoyast template
    ##
    open(TEMPLATE, "<$autoYastTemplate") or die "Can't open autoYastTemplate $autoYastTemplate : $!";
    my $yastfile = join '', <TEMPLATE>;
    close(TEMPLATE);

    open(TEMPLATE, "<$pxeTemplate") or die "Can't open pxeTemplate $pxeTemplate : $!";
    my $pxefile = join '', <TEMPLATE>;
    close(TEMPLATE);

    my $date = &get_rundate();
    my $bootmac = $Hash{'mac'};
    $bootmac =~ s/:/-/g;
    $bootmac = "01-".$bootmac;

    # get any existing db entry
    # if none exists add this new
    # if one exists
    #    and it is deleted we overwrite
    #    and it is not deleted we exit
    my $dbref = &get_db_host_entry( $Hash{'hostname'} );
    if (! defined $dbref ) {
        &add_db_host_entry( $HashRef );
    } elsif ( $dbref->{'state'} == 4 ) {
        &update_db_host_entry( $HashRef );
    } else {
        print "Attempt to add over a non-deleted entry for $Hash{'hostname'}\n";
        exit 1;
    }

    # add files to sqlfstable for sqltftpd server

    my $tdir = tempdir();
    my $dbname = "sqltftp";
    my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=$dbname",
                               'User' => "baracus")
        or die "Unable to create new instance of SqlFS\n";

    if ( $sqlfsOBJ->find("$Hash{'hexip'}") ) {
        print "$Hash{'hexip'} already exists\n";
    } else {
        while ( my ($key, $value) = each(%Hash) ) {
            $key =~ tr/a-z/A-Z/;
            $key = "__$key\__";
            $yastfile =~ s/$key/$value/g;
        }
        open(FILE, ">$tdir/$Hash{'hexip'}") || die "Cannot open file $Hash{'hexip'}: $!\n";
        print FILE $yastfile;
        print FILE "<!-- baracus.Hostname: $Hash{'hostname'} -->\n";
        print FILE "<!-- baracus.MAC: $Hash{'mac'}; -->\n";
        print FILE "<!-- baracus.Generated: $date -->\n";
        close(FILE);

        if ( $sqlfsOBJ->store( "$tdir/$Hash{'hexip'}" ) ) {
            warn "failed to store $tdir/$Hash{'hexip'} in sqlfs\n";
        }
        unlink "$tdir/$Hash{'hexip'}";

        if ($verbose) {
            print "Successfully stored $Hash{'hexip'} \n";
        }
    }

    if ( $sqlfsOBJ->find( "$bootmac" ) ) {
        print "$bootmac boot file already exists\n";
    } else {
        while ( my ($key, $value) = each(%Hash) ) {
            $key =~ tr/a-z/A-Z/;
            $key = "__$key\__";
            $pxefile =~ s/$key/$value/g;
        }
        open(FILE, ">$tdir/$bootmac") || die "Cannot open file $bootmac: $!\n";;
        print FILE $pxefile;
        close(FILE);

        if ( $sqlfsOBJ->store( "$tdir/$bootmac" ) ) {
            warn "failed to store $tdir/$bootmac in sqlfs\n";
        }
        unlink "$tdir/$bootmac";

        if ($verbose) {
            print "Successfully stored $Hash{'hexip'} \n";
        }
    }
    # disconnect and destroy
    $sqlfsOBJ->discard();
    rmdir $tdir;

    print "Added $Hash{'hostname'} template \n";
}

sub remove_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $dbref = &get_db_host_entry( $Hash{'hostname'} );

    if (! defined $dbref) {
        print "unable to find template for $Hash{'hostname'}\n";
        return;
    }

    my $mac = $dbref->{'mac'};
    $mac =~ s/:/-/g;
    $mac = "01-$mac";

    # remove files from sqlfstable for sqltftpd server

    my $dbname = "sqltftp";
    my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=$dbname",
                               'User' => "baracus")
        or die "Unable to create new instance of SqlFS\n";

    if ( $sqlfsOBJ->find( "$dbref->{'iphex'}" ) ) {
        if ( $sqlfsOBJ->remove( "$dbref->{'iphex'}" ) ) {
            warn "failed to remove $dbref->{'iphex'} from sqlfs\n";
        }
    }

    if ( $sqlfsOBJ->find( "$mac" ) ) {
        if ( $sqlfsOBJ->remove( "$mac" ) ) {
            warn "failed to remove $mac from sqlfs\n";
        }
    }
    # disconnect and destroy
    $sqlfsOBJ->discard();

    print "Removed: $Hash{'hostname'} [ $dbref->{'iphex'} ] $mac\n";

    # change state of entry to removed
    &remove_db_host_entry( $Hash{'hostname'} );
}

sub list() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;
    my %hardwareHash;
    my @modelArray;

    if ( ($subcommand ne "hardware")  and
         ($subcommand ne "templates") and
         ($subcommand ne "history") ) {
        print "Invalid subcommand for command 'list'\n";
        &get_usage();
    }

    if ($Hash{'subcommand'} eq "history") {

        if (! exists($Hash{'hostname'})) {
            $Hash{'hostname'} = "%";
        }
        my $dbref = &list_db_history($Hash{'hostname'});
        foreach ( @$dbref ) {
            print "$_->[0] $_->[1] $_->[3] $_->[4] $_->[5] $_->[6] $_->[8] $_->[9] \n";
        }
    }

    if ($Hash{'subcommand'} eq "hardware") {
        Config::Simple->import_from("$confdir/hardware.config", \%hardwareHash);
        while ( (my $key, my $value) = each(%hardwareHash) ) {
            (my $model, my $data) = split(/\./, $key);
            if ($data eq "model") {
                push(@modelArray, $model);
            }
        }
        @modelArray = sort(@modelArray);
        foreach my $item (@modelArray) {
            print "$item\t\t\[ $hardwareHash{\"$item.description\"} \]\n";
        }
    }

    if ($Hash{'subcommand'} eq "templates") {
        ## List all available build templates
        ##
        my $dbname = "sqltftp";
        my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=$dbname",
                                   'User' => "baracus")
            or die "Unable to create new instance of SqlFS\n";

        my $dbref = &get_db_list_entry();
        foreach ( @$dbref ) {
            my $autoinstallstring = "( missing)";
            my $pxehexfilestring  = "( missing)";
            my $iphex   = $_->[1];
            my $bootmac = $_->[2];
            $bootmac =~ s/:/-/g;
            $bootmac = "01-$bootmac";
            if ( $sqlfsOBJ->find( $iphex ) ) {
                $autoinstallstring = "(verified)";
            }
            if ( $sqlfsOBJ->find( $bootmac ) ) {
                $pxehexfilestring = "(verified)";
            }
            printf "%24s [ %s $autoinstallstring ] %s $pxehexfilestring\n",
                $_->[0], $iphex, $bootmac;
        }
        # disconnect and destroy
        $sqlfsOBJ->discard();
    }
}

sub verify() {

    my %profileHash = %{$_[0]};

    print "Verify $profileHash{ 'hostname'} ...comming soon. \n";
}


# this arg handling will parse many variations
# --module=doOne,doTwo --module doThree --module "doFour,doFive doSix"
# --vars=doOne=hey,doTwo=there --vars "doThree=love,doFour=or doFive=not"
sub multiarg_handler() {
    my $option = $_[0];
    my $value  = $_[1];
    my @values;
    if ( $value ne '' ) {
        # arg specified - push into array
        @values = split(/[,\s*]/,$value);
    } else {
        # no value profided and no defaults
        # with '=s' should not get here
        # we could 'die("FINISH")'
        # but for now just return
        return;
    }
    foreach $value (@values) {
        if ( $option eq "vars" ) {
            # special check for key=value assignment syntax
            die("FINISH") if ( $value !~ m/=/ );
        }
        if (not defined $multiarg{ $option } ){
            # initialize
            $multiarg{ $option } = "$value ";
        }
        elsif ( $multiarg{ $option } !~ m/$value/ ) {
            # append if not already present
            $multiarg{ $option } .= "$value ";
        }
    }
}

## Main
##

## Build command line for historical reference
## and point-in-time rebuilding
##
my $cmdline ='';
for (my $cnt = 0; $cnt <= $#ARGV; $cnt++) {
    $cmdline = $cmdline."::".$ARGV[$cnt];
}

## Parse out command before getopts::Long
##
if ($ARGV[0]) {
    $command = $ARGV[0];
    if ($command eq "list") {
        if ($ARGV[1]) {
            $subcommand = $ARGV[1];
        } else {
            print "Command 'list' requires a subcommand\n";
            &get_usage();
        }
    }
} else {
    &get_usage();
}

use Getopt::Long;
use AppConfig;

## Are standard variables set in /etc/sysconfig
##
my $sysconfigfile = '/etc/sysconfig/baracus';
my $sysconfig = AppConfig->new( {CREATE => 1} );
$sysconfig->define( 'baracusdir=s',
                    'buildtype=s',
                    'buildip=s',
                   );
$sysconfig->file( $sysconfigfile );
$baracusdir = $sysconfig->get( 'baracusdir' ); # ~baracus is default
$buildip    = $sysconfig->get( 'buildip'    );
$type       = $sysconfig->get( 'buildtype'  );

if ( $baracusdir =~ m|^~([^/]*)| ) {
    my $prepath="";
    if ( "$1" eq "" ) {
        $prepath = $ENV{HOME}
    } else {
        unless ($prepath = (getpwnam($1))[7]) {
            die "BARACUSDIR has bad use of ~ or non-existent user in $sysconfigfile\n";
        }
    }
    $baracusdir =~ s|^~([^/]*)|$prepath|;
}
# remove trailing slash or spaces
$baracusdir =~ s|/*\s*$||;

# store baracus well know directories in global hash 'bdir'
my @bdirs = qw( builds isos templates modules hooks logs );
%bdir = (
         'root' => "$baracusdir",
         'conf' => "/etc/baracus.d",
         'data' => "/usr/share/baracus",
         );
foreach my $bd (@bdirs) {
    $bdir{ $bd } = "$baracusdir/$bd";
}
if ($verbose) {
    print "Baracus directories:\n";
    while ( my ($key,$value) = each ( %bdir ) ) {
        print "\t$key => $value\n" if ( defined $value );
    }
}

$confdir     = $bdir{ 'conf' };
$moduledir   = $bdir{ 'modules' };
$templatedir = $bdir{ 'templates' };
$datadir     = $bdir{ 'data' };
$buildroot   = $bdir{ 'builds' };

GetOptions(
           'verbose|v!' => \$verbose,
           'debug|d!'   => \$debug,
           'help|h!'    => \$help,
           'hostname=s' => \$hostname,
           'ip=s'       => \$ip,
           'mac=s'      => \$mac,
           'distro=s'   => \$os,
           'hwtype=s'   => \$hardware,
           'profile=s'  => \$profile,
           'module=s'   => \&multiarg_handler,
           'vars=s'     => \&multiarg_handler,
           'add'        => \$add,    # command
           'remove'     => \$remove, # command
           'verify'     => \$verify, # command
           'list'       => \$list,   # command <subcommand>
           ) or die "Incorrect usage!\n";

$module = $multiarg{ 'module' } if (defined $multiarg{ 'module' });
$vars   = $multiarg{ 'vars'   } if (defined $multiarg{ 'vars'   });

&get_usage_add if (($command eq "add") and
                   ($help or (defined $ARGV[1] and( $ARGV[1] eq "help"))));
&get_usage if ($help or $command eq "help");

## Take main action argument and call corresponging Sub
#
my %action = (
              'add'     => \&add_host_entry,
              'remove'  => \&remove_host_entry,
              'list'    => \&list,
              'verify'  => \&verify,
              );

if (! defined $action{$command}) {
    print "Invalid command provided.\n";
    &get_usage();
}

unless ($buildip) {
    print "Please edit /etc/sysconfig/baracus and set BUILDIP=<server>\n";
    exit 1;
}

if ( ( $command eq "add" ) or
     ( $command eq "remove" ) or
     ( $command eq "verify" ) ) {
    unless ($hostname) {
        print "Please specify value for --hostname\n";
        exit 1;
    }
}

unless ($profile) {
    $profile = "default";
}

## Get variables set in a profile
##
my %profileHash;

if (($profile) && (-f "$confdir/profiles/$profile")) {
    my $conf = new Config::General("$confdir/profiles/$profile");
    %profileHash = $conf->getall;
    while ((my $key) = each(%profileHash)) {
        if (ref($profileHash{$key}) eq "ARRAY") {
            print "$key is an ARRAY\n";
            print "ARRAYs not yet supported\n";
            exit(1);
            #           foreach my $avalue (@{$profileHash{$key}}){
            #               print "$avalue\n";
            #           }
            next;
        }
    }
} else {
    print "valid profile required \n";
    exit(1);
}


$profileHash{'uuid'} = &get_uuid;
if ($hostname) {
    $profileHash{'hostname'} = $hostname;
}
if ($command eq "add") {
    ## Commandline options
    ## Mandatory: hostname ip mac
    ## Optional: hwtype distro profile module
    ##
    $profileHash{'cmdline'} = $cmdline;
    if ($type) {
        $profileHash{'type'} = $type;
    }
    if ($buildip) {
        $profileHash{'buildip'} = $buildip;
    }
    if ($buildroot) {
        $profileHash{'buildroot'} = $buildroot;
    }
    if ($ip) {
        $profileHash{'ip'} = $ip;
        $profileHash{'hexip'} = &get_hexIP($profileHash{'ip'});
    }
    if ($mac) {
        $profileHash{'mac'} = $mac;
    }
    if ($hardware) {
        $profileHash{'hardware'} = $hardware;
    }
    if ($os) {
        $profileHash{'os'} = $os;
    }
    if ($profile) {
        $profileHash{'profile'} = $profile;
    }
    if ($module) {
        my $modulefile="";
        foreach my $item (split(/ /, $module)) {
            # we should think about wraping the scripts
            # with the xml CDATA gunk ourselves here so
            # that the scripts can just be scripts.
            open(MODULE, "<$moduledir/$item");
            $modulefile = join '' ,$modulefile, <MODULE>;
            close(MODULE);
            $profileHash{'module'} = $modulefile;
        }
    }

    ## Get Vars from hardware.conf and os.conf
    ##
    my $osConfig = new Config::Simple("$confdir/os.config");
    my $hardwareConfig = new Config::Simple("$confdir/hardware.config");
    my $moduleConfig = new Config::Simple("$confdir/module.config");

    die "Need --distro via commandline or profile.\n"
        unless ($profileHash{'os'});

    die "Need --hwtype via commandline or profile.\n"
        unless ($profileHash{'hardware'});

    my $osRef = $osConfig->param(-block=>"$profileHash{'os'}");
    my $hardwareRef = $hardwareConfig->param(-block=>"$profileHash{'hardware'}");
    my %moduleHash = $moduleConfig->vars() if ( defined $moduleConfig );

    my %osHash = %$osRef;
    my %hardwareHash = %$hardwareRef;
    while ( my ($key, $value) = each(%osHash) ) {
        $profileHash{$key} = $value;
    }
    while ( my ($key, $value) = each(%hardwareHash) ) {
        $profileHash{$key} = $value;
    }

    ## If passed on command line via vars, then honor those
    ##
    if ($vars) {
        my @varray = split(/ /, $vars);
        foreach my $item (@varray) {
            (my $key, my $value) = split(/=/, $item);
            $profileHash{$key} = $value;
        }
    }
}

if ($subcommand) {
    $profileHash{'subcommand'} = $subcommand;
} else {
    $profileHash{'subcommand'} = "";
}

$dbname = "baracus";
my $dbrole = $dbname;

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

$dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

if ($debug) {
    print "profileHash:\n";
    foreach my $key ( sort ( keys %profileHash )) {
        print "\t$key => $profileHash{$key}\n";
    }
}

## execute command
##
$action{$command}(\%profileHash);

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );
