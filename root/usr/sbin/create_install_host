#!/usr/bin/perl -w

use strict;
use POSIX qw/strftime/;
use Term::ReadKey;
use Config::General;
use Config::Simple;
use File::Temp qw/ tempdir /;
use XML::Simple;
use DBI;
use DBD::Pg qw(:pg_types);

use lib "/usr/share/baracus/perl";

use SqlFS;
use BaracusDB;
use BaracusSql;

our $LASTERROR;

my $command;
my $subcommand;
my $arg;
my $hostname="";
my $ip="";
my $mac;
my $hardware="";
my $distro="";
my $module="";
my $profile="";
my $yasttemplate="";
my $vars;
my $add;
my $remove;
my $wipe;
my $list;
my $verify;
my $help;
my $verbose;
my $debug;
my $moduledir="";
my $templatedir="";
my $confdir="";
my $dbname="";
my $dbargs={};
my $dbh={};
my $datadir="";
my $buildip="";
my $buildroot="";
my $baracusdir;
my %bdir;
my $type="";
my %multiarg;

sub get_usage() {

    print <<MARKER1;
Usage:
    create_install_host command [subcommand] [options]

Where command is one of

    add     <arg1 arg2 arg3> [etc.] : add a new build source
                                      for details use: 'add --help'
    remove  --hostname <x>          : delete a build template for host <x>
    wipe    --hostname <x>          : mark host for decom on next pxe boot
    verify  --hostname <x>          : verify build template for host <x> (TBD)
    list    <templates>             : list host templates
    list    <history>               : list build client template history

Options are

    -v|--verbose                    : verbose output
    -h|--help                       : this (help) message

MARKER1

    exit 1;
}

sub get_usage_add() {

    print <<MARKER2;
Usage:
    create_install_host add --hostname <x> --mac <y> --ip <z> [more...]

    Where

    --hostname <x>          : <x> intended name for the build client
    --ip <y>                : <y> client static, or dhcp bound, IP address
    --mac <z>               : <z> client network interface physical address

    Other required parameters, which may be specified in a profile are:

    --distro <base-arch>    : OS to install on build client - made ready with
                              'create_install_source add --distro <base-arch>'
    --hardware <hwteplate>  : hardware template that describes the build client

    And further parameters include

    --profile <pfile>       : file with networking and other template parameters
                              there is a 'default' profile of that name visible
                              with the command: 'baconfig detail profile default'
    --module <mfile>        : yast autoinstall scripts to run on build complete
                              you can specify this option multipls times
    --vars <variable=value> : a method to specify a command line parameter
                              that will override those found in the config files
                              you can specify this option multipls times

MARKER2

    exit 1;
}

sub get_uuid() {

    ## Generate a new UUID
    ##
    use Data::UUID;

    my $ug = new Data::UUID;

    return $ug->to_string( $ug->create() );
}

sub get_rundate() {

    ## Generate timestamp for run
    ##
    my $now = time;
    my $rundate=strftime "%Y-%m-%d %H:%M:%S", localtime($now);
    return $rundate;

}

sub add_db_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $sql = q|INSERT INTO templateid ( hostname,
                                         ip,
                                         mac,
                                         uuid,
                                         state,
                                         cmdline,
                                         creation,
                                         change )
                VALUES ( ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP(0), CURRENT_TIMESTAMP(0) )|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->bind_param( 1, $Hash{'hostname'}    );
    $sth->bind_param( 2, $Hash{'ip'}          );
    $sth->bind_param( 3, $Hash{'mac'}         );
    $sth->bind_param( 4, $Hash{'uuid'}        );
    $sth->bind_param( 5, BaracusSql::BA_READY );
    $sth->bind_param( 6, $Hash{'cmdline'}     );

    $sth->execute()
        or die "Cannot execute sth: ", $sth->errstr;
}

sub get_db_host_entry() {

    my $hostname = shift @_;

    my $sql = q|SELECT hostname,
                       ip,
                       mac,
                       uuid,
                       state,
                       creation,
                       change
                FROM templateid
                WHERE hostname = ? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute( $hostname )
        or die "Cannot execute sth: ",$sth->errstr;

    return $sth->fetchrow_hashref();
}

sub update_db_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $sql = q|UPDATE templateid
                SET ip=?,
                    mac=?,
                    uuid=?,
                    state=?,
                    change=CURRENT_TIMESTAMP(0)
                WHERE hostname=? |;

    if ( $debug ) {
        print "$sql\n";
        while ( my ( $key, $value ) = each %Hash ) {
            print "update db: $key => $value\n";
        }
    }
    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->bind_param( 1,  $Hash{'ip'}        );
    $sth->bind_param( 2,  $Hash{'mac'}       );
    $sth->bind_param( 3,  $Hash{'uuid'}      );
    $sth->bind_param( 4,  $Hash{'state'}     );
    $sth->bind_param( 5,  $Hash{'hostname'}  );

    $sth->execute()
        or die "Cannot execute sth: ",$sth->errstr;
}

sub remove_db_host_entry() {
    my $hostname = shift @_;

    my $sql = q|DELETE FROM templateid WHERE hostname=?|;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare sth: ",$dbh->errstr;

    $sth->execute( $hostname )
        or die "Cannot execute sth: ",$sth->errstr;
}

sub add_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    ## Verify Mandatory parameters
    ##
    unless ($Hash{'hostname'}) {
        print "Missing  --hostname\n";
        &get_usage_add;
    }
    unless ($Hash{'ip'}) {
        print "Missing  --ip\n";
        &get_usage_add;
    }
    unless ($Hash{'mac'}) {
        print "Missing  --mac\n";
        &get_usage_add;
    }

    my $autoYastTemplate = join "/", $templatedir, $Hash{'os'}, $Hash{'arch'}, $Hash{'yasttemplate'};
    my $pxeTemplate      = join "/", $templatedir, $Hash{'os'}, $Hash{'arch'}, "pxetemplates", $Hash{'pxetemplate'};

    if ($debug) {
        print "autoYastTemplate = $autoYastTemplate\n";
        print "pxeTemplate = $pxeTemplate\n";
    }

    if ((! -f $autoYastTemplate ) || (! -f $pxeTemplate )) {
        print "\nOne or both of the base template files for pxe and autoyast cannot be found here:\n";
        print "\n$autoYastTemplate\n$pxeTemplate\n";
        print "\nPlease refer to the README found in $templatedir/\n";
        exit 1;
    }

    ## Read in autoyast template
    ##
    open(TEMPLATE, "<$autoYastTemplate") or die "Can't open autoYastTemplate $autoYastTemplate : $!";
    my $yastfile = join '', <TEMPLATE>;
    close(TEMPLATE);

    open(TEMPLATE, "<$pxeTemplate") or die "Can't open pxeTemplate $pxeTemplate : $!";
    my $pxefile = join '', <TEMPLATE>;
    close(TEMPLATE);

    my $date = &get_rundate();
    my $bootmac = $Hash{'mac'};
    $bootmac =~ s/:/-/g;
    my $automackey = "autoinst";
    my $automac = "02-".$bootmac;
    $bootmac = "01-".$bootmac;
    $Hash{ $automackey } = $automac;


    # get any existing db entry
    # if none exists add this new
    # if one exists
    #    and it is deleted we overwrite
    #    and it is not deleted we exit
    my $dbref = &get_db_host_entry( $Hash{'hostname'} );
    if ( ! defined $dbref ) {
        &add_db_host_entry( $HashRef );
    } else {
        print "Attempt to add over a non-deleted entry for $Hash{'hostname'}\n";
        exit 1;
    }

    # add files to sqlfstable for sqltftpd server

    my $tdir = tempdir();
    my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=sqltftp",
                               'User' => "baracus")
        or die "Unable to create new instance of SqlFS\n";

    if ( $sqlfsOBJ->find( $automac ) ) {
        print "$automac already exists\n";
    } else {
        while ( my ($key, $value) = each(%Hash) ) {
            $key =~ tr/a-z/A-Z/;
            $key = "__$key\__";
            $yastfile =~ s/$key/$value/g;
        }
        open(FILE, ">$tdir/$automac") || die "Cannot open file $automac: $!\n";
        print FILE $yastfile;
        print FILE "<!-- baracus.Hostname: $Hash{'hostname'} -->\n";
        print FILE "<!-- baracus.MAC: $Hash{'mac'}; -->\n";
        print FILE "<!-- baracus.Generated: $date -->\n";
        close(FILE);

        if ( $sqlfsOBJ->store( "$tdir/$automac",
                               "autoinst $Hash{'os'} $Hash{'sp'} $Hash{'arch'}" ) ) {
            warn "failed to store $tdir/$automac in sqlfs\n";
        }
        unlink "$tdir/$automac";

        if ($verbose) {
            print "Successfully stored $automac \n";
        }
    }

    if ( $sqlfsOBJ->find( "$bootmac" ) ) {
        print "$bootmac boot file already exists\n";
    } else {
        while ( my ($key, $value) = each(%Hash) ) {
            $key =~ tr/a-z/A-Z/;
            $key = "__$key\__";
            $pxefile =~ s/$key/$value/g;
        }
        open(FILE, ">$tdir/$bootmac") || die "Cannot open file $bootmac: $!\n";;
        print FILE $pxefile;
        close(FILE);

        if ( $sqlfsOBJ->store( "$tdir/$bootmac",
                               "pxeboot $Hash{'os'} $Hash{'sp'} $Hash{'arch'}" ) ) {
            warn "failed to store $tdir/$bootmac in sqlfs\n";
        }
        unlink "$tdir/$bootmac";

        if ($verbose) {
            print "Successfully stored $bootmac \n";
        }
    }
    # disconnect and destroy
    $sqlfsOBJ->discard();
    rmdir $tdir;

    print "Added $Hash{'hostname'} template \n";
}

sub wipe_host_disk() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $dbref = &get_db_host_entry( $Hash{'hostname'} );

    unless ( defined $dbref ) {
        print "Unable to find template for $Hash{'hostname'}\n";
        return;
    }

    my ($key, $val);
    while ( ($key, $val) = each %{$dbref} ) {
        print "dbref $key => " . $val eq "" ? "" : $val . "\n" if $debug;
    }

    my $mac = $dbref->{'mac'};
    $mac =~ s/:/-/g;
    $mac = "01-".$mac;

    # copy dban over mac template for host in sqltftpd server

    my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=sqltftp",
                               'User' => "baracus",
                               'debug' => $debug )
        or die "Unable to create new instance of SqlFS\n";

    # print coding example of 'constant' usage if debug
    print "$BaracusSql::baState{ BaracusSql::BA_DISKWIPE } = " .
        BaracusSql::BA_DISKWIPE . "\n" if $debug;

    # if state is already 'wipe' don't do it all again
    if ( $dbref->{'state'} == BaracusSql::BA_DISKWIPE ) {
        print "Host entry for $Hash{'hostname'} already set to wipe.\n";
        return;
    }

    if ( $sqlfsOBJ->internalDataCopy( "pxetemplate-auto.dban", $mac ) ) {
        die "Cannot update host to dban wipe\n" . $sqlfsOBJ->error();
    }

    if ( $sqlfsOBJ->update( { 'name' => $mac,
                              'enabled' => 1,  # boolean enable/disable
                              'description' =>
                              "wipe disk on next pxeboot" } ) ) {
        die "Unable to set status to enable for dban wipe\n" . $sqlfsOBJ->error();
    }

    $dbref->{'state'} = BaracusSql::BA_DISKWIPE;

    &update_db_host_entry( $dbref );

    $sqlfsOBJ->discard();

    print "Wipe of harddrive for $Hash{'hostname'} will occur on next pxeboot\n";
}

sub remove_host_entry() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $dbref = &get_db_host_entry( $Hash{'hostname'} );

    unless ( defined $dbref ) {
        print "Unable to find template for $Hash{'hostname'}\n";
        return;
    }

    my ($key, $val);
    while ( ($key, $val) = each %{$dbref} ) {
        print "dbref $key => " . $val eq "" ? "" : $val . "\n" if $debug;
    }

    my $bootmac = $dbref->{'mac'};
    $bootmac =~ s/:/-/g;
    my $automac = "02-".$bootmac;
    $bootmac = "01-".$bootmac;

    # remove files from sqlfstable for sqltftpd server

    my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=sqltftp",
                               'User' => "baracus")
        or die "Unable to create new instance of SqlFS\n";

    if ( $sqlfsOBJ->find( "$automac" ) ) {
        if ( $sqlfsOBJ->remove( "$automac" ) ) {
            warn "failed to remove $automac from sqlfs\n";
        }
    }

    if ( $sqlfsOBJ->find( "$bootmac" ) ) {
        if ( $sqlfsOBJ->remove( "$bootmac" ) ) {
            warn "failed to remove $bootmac from sqlfs\n";
        }
    }

    # disconnect and destroy
    $sqlfsOBJ->discard();

    print "Removed $Hash{'hostname'} template\n";

    # change state of entry to removed
    &remove_db_host_entry( $Hash{'hostname'} );
}

sub list() {

    my $HashRef = shift @_;
    my %Hash = %$HashRef;

    my $dbref;

    if ( ($subcommand ne "templates") and
         ($subcommand ne "history") ) {
        print "Invalid subcommand '$subcommand' for command 'list'\n";
        &get_usage();
    }

    if (! exists($Hash{'hostname'})) {
        $Hash{'hostname'} = "%";
    }

    my $sth = db_list_start ( $subcommand, $Hash{'hostname'} );

    unless( defined $sth ) {
        print $LASTERROR;
        return 1;
    }

    if ( $subcommand eq "history" ) {
        ## List history filtered by hostname if provided
        ##

        while ( $dbref = &db_list_next( $sth ) ) {
            #
            # hostname ip mac uuid state cmdline creation change
            printf "%-16s ", $dbref->{'hostname'} ;
            printf "%-16s ", $dbref->{'ip'} ;
            printf "%17s ", $dbref->{'mac'} ;
            printf "%-8s ", $BaracusSql::baState{ $dbref->{'state'} };
            print "$dbref->{'uuid'} " if $verbose;
            print "$dbref->{'creation'} " if $verbose;
            print "$dbref->{'change'}\n";
        }
    }
    elsif ( $subcommand eq "templates" ) {
        ## List all available build templates
        ##

        my $sqlfsOBJ = SqlFS->new( 'DataSource' => "DBI:Pg:dbname=sqltftp",
                                   'User' => "baracus")
            or die "Unable to create new instance of SqlFS\n";

        while ( $dbref = &db_list_next( $sth ) ) {
            my $autostate = "missing";
            my $pxestate  = "missing";
            my $bootmac = $dbref->{'mac'};
            $bootmac =~ s/:/-/g;
            my $automac = "02-$bootmac";
            $bootmac = "01-$bootmac";

            if ( $sqlfsOBJ->find( $bootmac ) ) {
                $pxestate = "ok";
            }
            if ( $sqlfsOBJ->find( $automac ) ) {
                $autostate = "ok";
            }

            # at some point we need logic for the state of the host entry
            # and the state of the related tftp files for 'verified' reporting.
            printf "%-16s %-8s  ", $dbref->{'hostname'},
                $BaracusSql::baState{ $dbref->{'state'} };
            if ( $verbose ) {
                printf "%s $pxestate  %s $autostate\n", $bootmac, $automac;
            } else {
                if ( $pxestate ne "ok" && $autostate ne "ok" ) {
                    print "error - tftp files missing\n";
                } elsif ( $pxestate ne "ok" ) {
                    printf "error - %s $pxestate\n", $bootmac;
                } elsif ( $autostate ne "ok" ) {
                    printf "error - %s $autostate\n", $automac;
                } else {
                    print "verified\n";
            }
            }
        }
        # disconnect and destroy
        $sqlfsOBJ->discard();
    }
    &db_list_finish( $sth );
}

# the db_list routines break up the db operations for better large db handling
# using 'fetchrow_hashref' vs 'fetchall_arrayref' so we have names vs indexing

sub db_list_start
{
    my $type  = shift;  # 'templates' or 'history'
    my $name  = shift;

    my $sql;
    my $sth;

    $name =~ s/\*/\%/g;
    print "db_list_start name: $name\n" if $debug;

    if ( $type eq "templates" ) {

        $sql = q|SELECT hostname,
                        mac,
                        state
                 FROM templateid
                 WHERE hostname LIKE ?
                 ORDER BY hostname|;

    } elsif ( $type eq "history" ) {

        $sql = q|SELECT hostname,
                        ip,
                        mac,
                        uuid,
                        state,
                        cmdline,
                        creation,
                        change
                 FROM templateidhist
                 WHERE hostname LIKE ?|;
    }

    unless ( $sth = $dbh->prepare( $sql ) ) {
        $LASTERROR = "Unable to prepare 'list' query\n" . $dbh->errstr;
        return undef;
    }

    unless ( $sth->execute( $name ) ) {
        $LASTERROR = "Unable to execute 'list' query" . $sth->err;
        return undef;
    }

    return $sth;
}

sub db_list_next
{
    my $sth = shift;

    return $sth->fetchrow_hashref();
}

sub db_list_finish
{
    my $sth = shift;
    $sth->finish;
    undef $sth;
}

sub verify() {

    my %profileHash = %{$_[0]};

    print "Verify $profileHash{ 'hostname'} ...comming soon. \n";
}


# this arg handling will parse many variations
# --module=doOne,doTwo --module doThree --module "doFour,doFive doSix"
# --vars=doOne=hey,doTwo=there --vars "doThree=love,doFour=or doFive=not"
sub multiarg_handler() {
    my $option = $_[0];
    my $value  = $_[1];
    my @values;
    if ( $value ne '' ) {
        # arg specified - push into array
        @values = split(/[,\s*]/,$value);
    } else {
        # no value profided and no defaults
        # with '=s' should not get here
        # we could 'die("FINISH")'
        # but for now just return
        return;
    }
    foreach $value (@values) {
        if ( $option eq "vars" ) {
            # special check for key=value assignment syntax
            die("FINISH") if ( $value !~ m/=/ );
        }
        if (not defined $multiarg{ $option } ){
            # initialize
            $multiarg{ $option } = "$value ";
        }
        elsif ( $multiarg{ $option } !~ m/$value/ ) {
            # append if not already present
            $multiarg{ $option } .= "$value ";
        }
    }
}

## Main
##

## Build command line for historical reference
## and point-in-time rebuilding
##
my $cmdline ='';
for (my $cnt = 0; $cnt <= $#ARGV; $cnt++) {
    $cmdline = $cmdline."::".$ARGV[$cnt];
}

## Parse out command before getopts::Long
##
if ($ARGV[0]) {
    $command = $ARGV[0];
    if ($command eq "list") {
        if ($ARGV[1]) {
            $subcommand = $ARGV[1];
        } else {
            print "Command 'list' requires a subcommand\n";
            &get_usage();
        }
    }
} else {
    &get_usage();
}

use Getopt::Long;
use AppConfig;

## Are standard variables set in /etc/sysconfig
##
my $sysconfigfile = '/etc/sysconfig/baracus';
my $sysconfig = AppConfig->new( {CREATE => 1} );
$sysconfig->define( 'baracusdir=s',
                    'buildtype=s',
                    'buildip=s',
                   );
$sysconfig->file( $sysconfigfile );
$baracusdir = $sysconfig->get( 'baracusdir' ); # ~baracus is default
$buildip    = $sysconfig->get( 'buildip'    );
$type       = $sysconfig->get( 'buildtype'  );

if ( $baracusdir =~ m|^~([^/]*)| ) {
    my $prepath="";
    if ( "$1" eq "" ) {
        $prepath = $ENV{HOME}
    } else {
        unless ($prepath = (getpwnam($1))[7]) {
            die "BARACUSDIR has bad use of ~ or non-existent user in $sysconfigfile\n";
        }
    }
    $baracusdir =~ s|^~([^/]*)|$prepath|;
}
# remove trailing slash or spaces
$baracusdir =~ s|/*\s*$||;

# store baracus well know directories in global hash 'bdir'
my @bdirs = qw( builds isos templates modules hooks logs );
%bdir = (
         'root' => "$baracusdir",
         'conf' => "/etc/baracus.d",
         'data' => "/usr/share/baracus",
         );
foreach my $bd (@bdirs) {
    $bdir{ $bd } = "$baracusdir/$bd";
}
if ($verbose) {
    print "Baracus directories:\n";
    while ( my ($key,$value) = each ( %bdir ) ) {
        print "\t$key => $value\n" if ( defined $value );
    }
}

$confdir     = $bdir{ 'conf' };
$moduledir   = $bdir{ 'modules' };
$templatedir = $bdir{ 'templates' };
$datadir     = $bdir{ 'data' };
$buildroot   = $bdir{ 'builds' };

GetOptions(
           'verbose|v!' => \$verbose,
           'debug|d!'   => \$debug,
           'help|h!'    => \$help,
           'hostname=s' => \$hostname,
           'ip=s'       => \$ip,
           'mac=s'      => \$mac,
           'distro=s'   => \$distro,
           'hardware=s' => \$hardware,
           'yasttemplate=s' => \$yasttemplate,
           'profile=s'  => \$profile,
           'module=s'   => \&multiarg_handler,
           'vars=s'     => \&multiarg_handler,
           'add'        => \$add,    # command
           'remove'     => \$remove, # command
           'wipe'       => \$wipe,   # command
           'verify'     => \$verify, # command
           'list'       => \$list,   # command <subcommand>
           ) or die "Incorrect usage!\n";

$module = $multiarg{ 'module' } if (defined $multiarg{ 'module' });
$vars   = $multiarg{ 'vars'   } if (defined $multiarg{ 'vars'   });

&get_usage_add if (($command eq "add") and
                   ($help or (defined $ARGV[1] and( $ARGV[1] eq "help"))));
&get_usage if ($help or $command eq "help");

## Take main action argument and call corresponging Sub
#
my %action = (
              'add'     => \&add_host_entry,
              'remove'  => \&remove_host_entry,
              'wipe'    => \&wipe_host_disk,
              'list'    => \&list,
              'verify'  => \&verify,
              );

if (! defined $action{$command}) {
    print "Invalid command provided.\n";
    &get_usage();
}

unless ($buildip) {
    print "Please edit /etc/sysconfig/baracus and set BUILDIP=<server>\n";
    exit 1;
}

if ( ( $command eq "add" ) or
     ( $command eq "remove" ) or
     ( $command eq "wipe" ) or
     ( $command eq "verify" ) ) {
    unless ($hostname) {
        print "Please specify value for --hostname\n";
        exit 1;
    }
}

## Get variables set in a profile
##
my %profileHash;

if ($hostname) {
    $profileHash{'hostname'} = $hostname;
}

$dbname = "baracus";
my $dbrole = $dbname;

my $uid = BaracusDB::su_user( $dbrole );
die BaracusDB::errstr unless ( defined $uid );

$dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

if ($command eq "add") {

    my $hashoftbls = BaracusSql::get_baracus_tables();
    my $sql_cols;
    my @cols;
    my $sql;
    my $sth;
    my $sel;
    my $rowcount;

    $profile = "default"
        unless ($profile);

    $profileHash{'profile'} = $profile;

    # incorporate the related profile entry information into profileHash
    $sql_cols = BaracusSql::keys2columns( $hashoftbls->{ 'profile_cfg' } );
    $sql_cols =~ s/[ \t]*//g;
    @cols = split(/,/, $sql_cols);
    $sql = qq|SELECT $sql_cols FROM profile_cfg
                 WHERE profileid = '| . $profile . qq|' ORDER BY version|;
    unless ( $sth = $dbh->prepare( $sql ) ) {
        die "Unable to prepare 'profile_cfg' statement\n" . $dbh->errstr;
    }
    unless( $sth->execute( ) ) {
        die "Unable to execute 'profile_cfg' statement\n" . $sth->err;
    }
#    $sel = $dbh->selectrow_hashref( $sql );
    $rowcount = 0;
    $sel = undef;
    while( my $href = $sth->fetchrow_hashref( ) ) {
        $rowcount += 1;
        $sel = $href if ($href->{'status'});
    }
    die "Unable to find profile entry for $profile.\n"
        unless ( $rowcount );
    die "Unable to find *enabled* profile entry for $profile.\n"
        unless ( defined $sel );
    print $sel . "\n" if $debug;

    # getall is a destructive assignment - so use tmp
    my $conf = new Config::General( -String => $sel->{'data'} );
    my %tmpHash = $conf->getall;

    while ( my ($key, $value) = each ( %tmpHash ) ) {
        if (ref($value) eq "ARRAY") {
            print "$key is an ARRAY\n";
            print "ARRAYs not yet supported\n";
            exit(1);
            #           foreach my $avalue (@{$profileHash{$key}}){
            #               print "$avalue\n";
            #           }
            next;
        }
        if (defined $value) {
            print "profile: $key => $value\n" if $debug;
            $profileHash{$key} = $value;
        } else {
            print "profile: $key => ''\n" if $debug;
            $profileHash{$key} = "";
        }
    }

    # distro file may be in profile *and* on command line

    # command line wins over profile entry
    $profileHash{'distro'} = $distro if ($distro);

    die "Need --distro via commandline or distro= in profile.\n"
        unless ($profileHash{'distro'});

    # incorporate the related distro entry information into profileHash
    $sql_cols = BaracusSql::keys2columns( $hashoftbls->{ 'distro_cfg' } );
    $sql_cols =~ s/[ \t]*//g;
    @cols = split(/,/, $sql_cols);
    $sql = qq|SELECT $sql_cols FROM distro_cfg
                 WHERE distroid = '| . $profileHash{'distro'} . qq|'|;;
    $sel = $dbh->selectrow_hashref( $sql );
    die "Unable to find distro entry for $profileHash{'distro'}.\n"
        unless ( defined $sel );
    print $sel . "\n" if $debug;
    while ( my ($key, $value) = each( %$sel ) ) {
        if (defined $value) {
            print "distro: $key => $value\n" if $debug;
            $profileHash{$key} = $value;
        } else {
            print "distro: $key => ''\n" if $debug;
            $profileHash{$key} = "";
        }
    }

    # hardware file may be in profile *and* on command line

    # command line wins over profile entry
    $profileHash{'hardware'}= $hardware if ($hardware);

    die "Need --hardware via commandline or hardware= in profile.\n"
        unless ($profileHash{'hardware'});

    # incorporate the related hardware entry information into profileHash
    $sql_cols = BaracusSql::keys2columns( $hashoftbls->{ 'hardware_cfg' } );
    $sql = qq|SELECT $sql_cols FROM hardware_cfg
                 WHERE hardwareid = '| . $profileHash{'hardware'} . qq|'|;
    $sel = $dbh->selectrow_hashref( $sql );
    die "Unable to find hardware entry for $profileHash{'hardware'}.\n"
        unless ( defined $sel );
    print $sel . "\n" if $debug;
    while ( my ($key, $value) = each( %$sel ) ) {
        if (defined $value) {
            print "hware: $key => $value\n" if $debug;
            $profileHash{$key} = $value;
        } else {
            print "hware: $key => ''\n" if $debug;
            $profileHash{$key} = "";
        }
    }

    # module file may be in profile *and* on command line

    # command line wins over profile entry
    $tmpHash{'module'}= $module if ($module);

    # if profileHash{'module'} was set by reading a profile module= line
    # we need to clear it from %profileHash as that is for the yast xml
    # the module value should still be in %tmpHash from 'getall' invocation

    $profileHash{'module'}='';

    # incorporate any modules passed into autoinstall formated xml
    if (defined $tmpHash{'module'} && $tmpHash{'module'}) {
        my $modulefile;
#        $profileHash{'module'} = "    <init-scripts config:type="list">\n";
        foreach my $item (split(/ /, $tmpHash{'module'})) {

            $sql_cols = BaracusSql::keys2columns( $hashoftbls->{ 'module_cfg' } );
            $sql_cols =~ s/[ \t]*//g;
            @cols = split(/,/, $sql_cols);
            $sql = qq|SELECT $sql_cols FROM module_cfg
                 WHERE moduleid = '| . $item . qq|' ORDER BY version|;
            unless ( $sth = $dbh->prepare( $sql ) ) {
                die "Unable to prepare 'module_cfg' statement\n" . $dbh->errstr;
            }
            unless( $sth->execute( ) ) {
                die "Unable to execute 'module_cfg' statement\n" . $sth->err;
            }
#            $sel = $dbh->selectrow_hashref( $sql );
            $rowcount = 0;
            $sel = undef;
            while ( my $href = $sth->fetchrow_hashref( ) ) {
                $rowcount += 1;
                $sel = $href if ($href->{'status'});
            }
            die "Unable to find module entry for $item.\n"
                unless ( $rowcount );
            die "Unable to find *enabled* module entry for $item.\n"
                unless ( defined $sel );
            print $sel . "\n" if $debug;

            $modulefile="<script>
        <filename>$sel->{'moduleid'}</filename>
        <source><![CDATA[";
            $modulefile .= $sel->{'data'};
            $modulefile .="]]>\n        </source>\n      </script>";
            $profileHash{'module'} .= $modulefile;
        }
#        $profileHash{'module'} .= "\n    </init-scripts>"
    }

    ## Commandline options
    ##   - comes after reading profile
    ##   - harware, distro override profile values
    ##   - cmdline values override any file values
    ##   - --vars overrides everything else
    ## Mandatory: hostname ip mac
    ##

    $profileHash{'uuid'} = &get_uuid;

    $profileHash{'cmdline'} = $cmdline;

    if ($type) {
        $profileHash{'type'} = $type;
    }
    if ($buildip) {
        $profileHash{'buildip'} = $buildip;
    }
    if ($buildroot) {
        $profileHash{'buildroot'} = $buildroot;
    }
    if ($ip) {
        $ip = lc $ip;
        # check for ip format or 'dhcp' string
        if ( $ip =~ m/(\d+).(\d+).(\d+).(\d+)/ ) {
            # check for valid ip address range values
            if ( ( $1 < 1 or $1 > 254 or $1 == 127 ) ||
                 ( $2 < 0 or $2 > 254 ) ||
                 ( $3 < 0 or $3 > 254 ) ||
                 ( $4 < 1 or $4 > 254 ) ) {
                print "Invalid IP address value given: $ip\n";
                exit 1;
            }
        }
        elsif ( $ip ne "dhcp" ) {
            print "Invalid IPv4 address format or missing 'dhcp' string.\n";
            exit 1;
        }
        $profileHash{'ip'} = $ip;
    }
    if ($mac) {
        $profileHash{'mac'} = uc $mac;
    }
    if ($yasttemplate) {
        $profileHash{'yasttemplate'} = $yasttemplate;
    }

    ## If passed on command line via vars, then honor those
    ##
    if ($vars) {
        my @varray = split(/ /, $vars);
        foreach my $item (@varray) {
            (my $key, my $value) = split(/=/, $item);
            $profileHash{$key} = $value;
        }
    }
}

if ($subcommand) {
    $profileHash{'subcommand'} = $subcommand;
} else {
    $profileHash{'subcommand'} = "";
}

if ($debug) {
    print "profileHash:\n";
    foreach my $key ( sort ( keys %profileHash )) {
        print "\t$key => $profileHash{$key}\n";
    }
}

## execute command
##
$action{$command}(\%profileHash);

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );
