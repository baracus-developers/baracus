#!/usr/bin/perl -w

use strict;
use warnings;

use CGI;
use Apache::DBI ();
use DBI ();

use lib "/usr/share/baracus/perl";

use BaracusSql qw( :vars );
use BaracusState qw( :vars :subs :admin :actions :events );
use BaracusConfig qw( :vars );
use BaracusCgi qw( :subs );
use BaracusCore qw( :subs );
use BaracusAux qw( :subs );
use BaracusHost qw( :subs );

use lib '/var/spool/baracus/www/modules';
use BATools qw( :standard );

my $cgi = new CGI;

my $input = {};  # for CGI args or PUT cookie

my $built   = "$baDir{hooks}/verify_client_build_passed";
my $spoofed = "$baDir{hooks}/verify_client_build_failed";

my $dbh = DBI->connect
    ("DBI:Pg:dbname=baracus;port=5162",
     "wwwrun",
     "",
     {
      PrintError => 1,          # warn() on errors
      RaiseError => 0,          # don't die on error
      AutoCommit => 1,          # commit executes
      # immediately
      }
     );

my $tftph = DBI->connect
    ("DBI:Pg:dbname=sqltftp;port=5162",
     "wwwrun",
     "",
     {
      PrintError => 1,          # warn() on errors
      RaiseError => 0,          # don't die on error
      AutoCommit => 1,          # commit executes
      # immediately
      }
     );

my $state = 0;
my $pxenext = 0;
my $admin = 0;

my %values = ();
my @fields = ();
my $fields = "";
my $values = "";
my $sql = "";
my $sth = 0;

my $href    = {};
my $macref  = {};
my $actref  = {};
my $distref = {};
my $hardref = {};
my $filename = "";
my $output = "";


if ( $ENV{REQUEST_METHOD} eq "PUT" ) {

    ##
    ## Handle the uploading of files via "http PUT"
    ##
    ##   curl -b "mac=<mac>;status=<status>" -T <file> \
    ##       http://$baVar{serverip}/ba/inventory
    ##

    foreach my $key ( $cgi->cookie() ) {
        $input->{$key} = $cgi->cookie($key);
    }

    if ( $ENV{REQUEST_URI} =~ m|^\s*/ba/inventory\s*$| ) {

        ##
        ## REGISTER - STORE INVENTORY
        ##

        die "Missing 'mac=' in HTTP_COOKIE\n" unless ( defined $input->{mac} );

        print STDERR "$input->{mac} - host inventory received\n";

        $input->{mac} = &check_mac($input->{mac});
        $filename = $input->{mac} . ".inventory";

        $macref = &get_db_mac( $dbh, $input->{mac} );
        unless ( $macref ) {
            # user deleted entry while system was doing what baracus told it
            $state = BA_EVENT_FOUND;
            &add_db_mac( $dbh, $input->{mac}, $state );
            $macref = &get_db_mac( $dbh, $input->{mac} );
        }

        $href = &get_tftpfile( $tftph, $filename );

        # hum... always want the new inventory...
        # so we know we have to remove the old entry first
        if (defined $href and ($href->{name} eq $filename)) {
            &delete_tftpfile( $tftph, $filename );
        }

        $fields = "name,bin,description,enabled,insertion";
        $values = qq|'$filename',?,'lshw xml','1',CURRENT_TIMESTAMP(0)|;
        $sql = qq|INSERT INTO sqlfstable ( $fields ) VALUES ( $values )|;
        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );

        my $bin;
        my $bytes = 1;
        while ( $bytes ) {
            read( STDIN, $bytes, BA_DBMAXLEN ); # $ENV{CONTENT_LENGTH}
            if ( $bytes ) {
                $bin = pack( 'u', $bytes );
                unless ( $sth->execute( $bin ) ) {
                    print STDERR $sth->err;
                    exit 0;
                }
            }
        }
        $sth->finish();
        $output = "upload success\n";

        $state = BA_EVENT_REGISTER;

        my $chkref = &get_db_action( $dbh, $input->{mac} );
        $actref = $chkref if ( defined $chkref );
        $actref->{cmdline} = "# inventory uploaded";
        &event_state_change( $dbh, $state, $macref, $actref );
        &update_db_mac_state( $dbh, $input->{mac}, $state );
        if ( defined $chkref ) {
            &update_db_action( $dbh, $actref );
        } else {
            $actref->{mac} = $input->{mac};
            &add_db_action( $dbh, $actref );
        }

    } elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/wipe\s*$| ) {

        ##
        ## WIPE - ERASE DISK COMPLETION HOOK - STORE LOG
        ##

        die "Missing 'mac=' in COOKIE\n" unless ( defined $input->{mac} );
        die "Missing 'status=' in COOKIE\n" unless ( defined $input->{status} );

        print STDERR "$input->{mac} - wipe log received\n";

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );
        unless ( $macref ) {
            # user deleted entry while system was doing what baracus told it
            $state = BA_EVENT_FOUND;
            &add_db_mac( $dbh, $input->{mac}, $state );
            $macref = &get_db_mac( $dbh, $input->{mac} );
        }

        $filename = $input->{mac} . ".wipelog";
        $href = &get_tftpfile( $tftph, $filename );

        # hum... always want the new log...
        # so we know we have to remove the old entry first
        if (defined $href and ($href->{name} eq $filename)) {
            &delete_tftpfile( $tftph, $filename );
        }

        $fields = "name,bin,description,enabled,insertion";
        $values = qq|'$filename',?,'dban wipe log','1',CURRENT_TIMESTAMP(0)|;
        $sql = qq|INSERT INTO sqlfstable ( $fields ) VALUES ( $values )|;
        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );

        my $bin;
        my $bytes = 1;
        while ( $bytes ) {
            read( STDIN, $bytes, BA_DBMAXLEN ); # $ENV{CONTENT_LENGTH}
            if ( $bytes ) {
                $bin = pack( 'u', $bytes );
                unless ( $sth->execute( $bin ) ) {
                    print STDERR $sth->err;
                    exit 0;
                }
            }
        }
        $sth->finish();
        $output = "upload success\n";

        if ($input->{status} eq "pass") {
            $state = BA_EVENT_WIPED;
        } else {
            $state = BA_EVENT_WIPEFAIL;
        }

        my $chkref = &get_db_action( $dbh, $input->{mac} );
        $actref = $chkref if ( defined $chkref );
        $actref->{cmdline} = "# wipe log uploaded";
        &event_state_change( $dbh, $state, $macref, $actref );
        &update_db_mac_state( $dbh, $input->{mac}, $state );
        if ( defined $chkref ) {
            &update_db_action( $dbh, $actref );
        } else {
            $actref->{mac} = $input->{mac};
            &add_db_action( $dbh, $actref );
        }

    } else {

        ##
        ## NO OTHER HTTP PUT ALLOWED
        ##

        $output = "permission denied\n";
        print $cgi->header( -type => "text/plain",
                            -content_length => length
                            ($output)
                           ), $output;
        exit 0;
    }
}
elsif ( $ENV{REQUEST_METHOD} eq "GET" )
{
    ##
    ## Handle HTTP GET requests with or without CGI parameters
    ##
    ##   curl -s -o /tmp/pxemenu \
    ##       http://$baVar{serverip}/ba/boot?mac=<mac>&ip=<ip>
    ##

    foreach my $key ( $cgi->param() ) {
        $input->{$key} = $cgi->param($key);
    }

    if ( $ENV{REQUEST_URI} =~ m|^\s*/ba/env.*\s*$| ) {

        $output .= "CGI URL INPUT\n";
        foreach my $env ( keys %{$input} ) {

            $output .= "$env => $input->{ $env }\n";
        }

        $output .= "\n";
        $output .= "ENVIRONMENT\n";
        foreach my $env ( keys %ENV ) {
            $output .= "$env => $ENV{ $env }\n";
        }
    }
    elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/boot\?.*\s*$| ) {

        ##
        ## PXE - DIRECT TO INVENTORY, LOCALBOOT, INSTALL, WIPE
        ##

        die "Missing 'mac=' in URL\n" unless ( defined $input->{mac} );

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );
        $actref = &get_db_action( $dbh, $input->{mac} );
        if ( not defined $macref or
             not defined $actref
            )
        {
            ##
            ## INVENTORY - missing 'mac' or 'action' entry (or entries)
            ##

            print STDERR "$input->{mac} - found and need inventory\n";

            # add the mac entry as found... if it's the one missing
            unless ( defined $macref ) {
                $state = BA_EVENT_FOUND;
                &add_db_mac( $dbh, $input->{mac}, $state );
                $macref = &get_db_mac( $dbh, $input->{mac} );
            }
            # set the check if we already have an action entry
            my $chkref = $actref if ( defined $actref );

            $actref->{cmdline} = "# pxeboot found";

            # this is where a state is first created by a trigger
            # and that trigger has to show movement to the next state
            # because we serve the inventory pxe now
            $state = BA_ACTION_INVENTORY;
            &action_state_change( $dbh, $state, $macref, $actref );

            &update_db_mac_state( $dbh, $input->{mac}, $state );
            if ( defined $chkref ) {
                # should never be the case that we have
                # action w/o mac first... but this don't hurt
                &update_db_action( $dbh, $actref );
            } else {
                $actref->{mac} = $input->{mac};
                &add_db_action( $dbh, $actref );
            }

            &get_inventory( $cgi, \%baVar, $input ); # routine exits
        }

        # found a mac and action entry - get the pxenext
        $pxenext = $actref->{pxenext};

        # if admin is DISABLED or IGNORED then
        # do not care about serving anything
        $admin = $actref->{admin};

        # don't do list
        #
        # bahost remove - no mac will be found again
        # bado empty    - removes action entry, will be found again
        #
        # ignored, none ( also pxe auto disabled )
        # disabled, pxewait ( wiped, wipefail - push next action to pxewait )

        if ( $admin eq BA_ADMIN_IGNORED or
             $pxenext eq BA_ACTION_NONE or
             $actref->{autopxeoff}
            ) {
            # we shouldn't be here - we've already fed host pxe info...
            print STDERR "$input->{mac} - bad tftp daemon, bad.\n";
            exit 1;
        }

        if ( $admin eq BA_ADMIN_DISABLED or
             $pxenext eq BA_ACTION_PXEWAIT
            ) {

            print STDERR "$input->{mac} - serving pxewait\n";
            &do_pxewait( $cgi );
            # do_pxewait call exits
        }

        if ( $pxenext eq BA_ACTION_NETBOOT ) {

            print STDERR "$input->{mac} - netboot $actref->{netbootip} $actref->{netboot}\n";
            &update_db_mac_state( $dbh, $macref->{mac}, $pxenext );
            if ( $actref->{oper} ne $pxenext or
                 $actref->{pxecurr} ne $pxenext
                ) {
                $actref->{oper} = $pxenext;
                $actref->{pxecurr} = $pxenext;
                $actref->{cmdline} = "# pxeboot network image";
                &update_db_action( $dbh, $actref );
            }

            &do_netboot( $cgi, $actref, $baVar{serverip} );
            # do_netboot exits
        }

        if ( $pxenext eq BA_ACTION_RESCUE ) {

            print STDERR "$input->{mac} - rescue mode\n";

            $distref = &get_distro( $dbh, $actref );
            $hardref = &get_hardware( $dbh, $actref );

            unless ( defined $distref and defined $hardref ) {
                print STDERR "$input->{mac} - missing distro or hardware in db\n";
                exit 1;
            }

            &update_db_mac_state( $dbh, $macref->{mac}, $pxenext );
            if ( $actref->{oper} ne $pxenext or
                 $actref->{pxecurr} ne $pxenext
                ) {
                $actref->{oper} = $pxenext;
                $actref->{pxecurr} = $pxenext;
                $actref->{cmdline} = "# pxeboot rescue mode";
                &update_db_action( $dbh, $actref );
            }

            my $args;
            my $rescue;

            if ( $distref->{os} eq "opensuse" or
                 $distref->{os} eq "sles"     or
                 $distref->{os} eq "sled"   ) {
                $rescue = qq|rescue=$distref->{sharetype}://$distref->{shareip}$distref->{basepath} rescue=1 textmode=1 |;

            } elsif ( $distref->{os} eq "fedora" or
                      $distref->{os} eq "centos" or
                      $distref->{os} eq "rhel" ) {
                $rescue = qq|text rescue ks=http://$baVar{serverip}/ba/auto?mac=$input->{mac}|;
            }

            $args = "$hardref->{bootargs} $actref->{raccess} $actref->{loghost}";

            &do_rescue( $cgi, $input->{mac}, $baVar{serverip}, "$args $rescue" );
            # do_rescue exits
        }

        # have we been directed to fetch inventory
        # or is it missing ? if so - get it now.

        $filename = $input->{mac} . ".inventory";
        $href = &get_tftpfile( $tftph, $filename );
        if ( $pxenext eq BA_ACTION_INVENTORY
             or
             (not defined $href
              or $href->{name} ne $filename
              or not defined $macref->{register}
              or $macref->{register} eq ""
              )
            ) {
            ##
            ## INVENTORY - have 'mac' but still missing inventory
            ##
            my $args = "";

            $args = $actref->{raccess};

            print STDERR "$input->{mac} - get inventory from host\n";

            &update_db_mac_state( $dbh, $macref->{mac}, $pxenext );
            if ( $actref->{oper} ne $pxenext or
                 $actref->{pxecurr} ne $pxenext
                ) {
                $actref->{oper} = $pxenext;
                $actref->{pxecurr} = $pxenext;
                $actref->{cmdline} = "# pxeboot inventory request";
                &update_db_action( $dbh, $actref );
            }

            &get_inventory( $cgi, \%baVar, $input, $args );
            # get_inventory call exits
        }

        if ( $pxenext eq BA_ACTION_LOCALBOOT )
        {
            ##
            ## LOCALBOOT - host built so just have it boot from localdisk
            ##

            print STDERR "$input->{mac} - building, built, localboot\n";

            &update_db_mac_state( $dbh, $macref->{mac}, $pxenext );
            if ( $actref->{oper} ne $pxenext or
                 $actref->{pxecurr} ne $pxenext
                ) {
                $actref->{oper} = $pxenext;
                $actref->{pxecurr} = $pxenext;
                $actref->{cmdline} = "# pxeboot directing to localdisk";
                &update_db_action( $dbh, $actref );
            }

            &do_localboot( $cgi );
            # do_localboot exits
        }

        if ( $pxenext eq BA_ACTION_BUILD )
        {
            ##
            ## BUILD
            ##

            print STDERR "$input->{mac} - building\n";

            $state = BA_EVENT_BUILDING;

            &event_state_change( $dbh, $state, $macref, $actref );
            &update_db_mac_state( $dbh, $macref->{mac}, $state );
            $actref->{cmdline} = "# pxeboot directing to network install";
            &update_db_action( $dbh, $actref );

            my $args;

            $distref = &get_distro( $dbh, $actref );
#            while ( my ($key, $val) = each %{$distref} ) {
#                print STDERR "dist $key => " . $val eq "" ? "" : $val . "\n";
#            }

            $hardref = &get_hardware( $dbh, $actref );
#            while ( my ($key, $val) = each %{$hardref} ) {
#                print STDERR "hard $key => " . $val eq "" ? "" : $val . "\n";
#            }

            if ( $distref->{os} eq "opensuse" or
                 $distref->{os} eq "sles"     or
                 $distref->{os} eq "sled"   ) {
#                $args = qq|textmode=1 install=$distref->{sharetype}://$distref->{shareip}$distref->{basepath} netsetup=1 WithISCSI=1|;
                $args = qq|textmode=1 install=$distref->{sharetype}://$distref->{shareip}$distref->{basepath} autoyast=http://$baVar{serverip}/ba/auto?mac=$input->{mac}|;


            } elsif ( $distref->{os} eq "fedora" or
                      $distref->{os} eq "centos" or
                      $distref->{os} eq "rhel" ) {
                $args = qq|text ks=http://$baVar{serverip}/ba/auto?mac=$input->{mac}|;
            }

            $output =
                qq|DEFAULT label_$actref->{hostname}
PROMPT 0
TIMEOUT 0

LABEL label_$actref->{hostname}
    kernel http://$baVar{serverip}/ba/linux?mac=$input->{mac}
    append initrd=http://$baVar{serverip}/ba/initrd?mac=$input->{mac} $hardref->{bootargs} $actref->{raccess} $args $actref->{loghost}
|;

        }

        if ( $pxenext eq BA_ACTION_DISKWIPE )
        {
            ##
            ## WIPE
            ##

            print STDERR "$input->{mac} - wiping\n";

            $state = BA_EVENT_WIPING;

            &event_state_change( $dbh, $state, $macref, $actref );
            &update_db_mac_state( $dbh, $macref->{mac}, $pxenext );
            if ( $actref->{oper} ne $state ) {
                $actref->{cmdline} = "# pxeboot directing to wipe disk";
                &update_db_action( $dbh, $actref );
            }

            my $autonuke = "";
            $autonuke = " --autonuke" if ( $actref->{autonuke} );
            $output =
                qq|DEFAULT wipe
PROMPT 0
TIMEOUT 0

LABEL wipe
        kernel http://$baVar{serverip}/ba/linux.baracus
        append initrd=http://$baVar{serverip}/ba/initrd.baracus root=/dev/ram0 install=exec:/usr/bin/baracus.dban nuke="dwipe${autonuke}" baracus=$baVar{serverip} mac=$input->{mac}
|;

        }

    }
    elsif ( $ENV{REQUEST_URI} =~ m{^\s*/ba/(linux|initrd|auto)\?.*\s*$} ) {

        my $file = $1;

        ##
        ## KERNEL OR INITRD OR AUTOBUILD FILE
        ##

        die "Missing 'mac=' in URL\n" unless ( defined $input->{mac} );

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );
        if ( not defined $macref ) {
            $output = "$input->{mac} - user vs cgi... missing db mac entry\n";
            print STDERR $output;
            print $cgi->header( -type => "text/plain",
                                -content_length => length
                                ($output)
                               ), $output;
            exit 0;
        }

        $actref = &get_db_action( $dbh, $input->{mac} );
        if (not defined $actref ) {
            $output = "$input->{mac} - user vs cgi... missing db action entry\n";
            print STDERR $output;
            print $cgi->header( -type => "text/plain",
                                -content_length => length
                                ($output)
                               ), $output;
            exit 0;
        }

        if ( $file eq "auto" ) {
            $file = $input->{mac};
            $file =~ s|:|-|g;
            $file = "02-" . $file;
        } else {
            $file = "$file.$actref->{distro}";
        }

        print STDERR "$input->{mac} - serving $file\n";

        $sql = qq|SELECT bin FROM sqlfstable WHERE name = '$file'|;

        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );
        die "$!$sth->err\n" unless ( $sth->execute( ) );

        while ( $href = $sth->fetchrow_hashref( ) ) {
            $output .= unpack( 'u', $href->{'bin'} );
        }
        $sth->finish();

    }
    elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/built\?.*\s*$| ) {

        my $hostname = $input->{ hostname };
        my $uuid = $input->{ uuid };
        my $ip = $ENV{ REMOTE_ADDR };

        # hash with a hostname
        $actref = &get_db_action_by_hostname( $dbh, $input->{hostname} );
        unless ( defined $actref ) {
            $output = "$input->{hostname} - build callback unable to find $hostname\n";
            print STDERR $output;
            print $cgi->header( -type => "text/plain",
                                -content_length => length
                                ($output)
                               ), $output;
            exit 0;
        }
        $input->{mac} = $actref->{ mac };
        $macref = &get_db_mac( $dbh, $input->{mac} );

        # check for spoofing of url access
        if (( "$uuid" ne "$actref->{'uuid'}" ) or
            (( "$ip"  ne "$actref->{'ip'}"  ) and
             ( "dhcp" ne "$actref->{'ip'}"  ))) {

            $state = BA_EVENT_SPOOFED;
            $actref->{cmdline} = "# build complete callback spoofed";

            print STDERR "$input->{mac} - $hostname $actref->{cmdline}\n";
            $output = "build spoofed - spoof hook called\n";

            if ( -f $spoofed ) {
                my $cmd = "$spoofed $hostname $ip $uuid $input->{mac}";
#                print STDERR $cmd;
#                system($cmd);
                my $rfile = BATools::generate_random_string();
                $cmd = "sudo $BATools::baPath/modules/pfork.bin ".$cmd." $rfile";
                my $output = `$cmd`;
            }
        }
        else {
            $state = BA_EVENT_BUILT;
            $actref->{cmdline} = "# build complete callback verified";
            print STDERR "$input->{mac} - $hostname $actref->{cmdline}\n";
            $output = "build verified - verify hook called\n";

            if ( -f $built ) {
                my $cmd = "$built $hostname $ip $uuid $input->{mac}";
#                print STDERR $cmd;
#                system($cmd);
                my $rfile = BATools::generate_random_string();
                $cmd = "sudo $BATools::baPath/modules/pfork.bin ".$cmd." $rfile";
                my $output = `$cmd`;
            }
        }

        &event_state_change( $dbh, $state, $macref, $actref );
        &update_db_mac_state( $dbh, $input->{mac}, $state );
        &update_db_action( $dbh, $actref );
    }

    ##
    ## kernel and initrd for inventory and dban
    ##

    elsif ( $ENV{REQUEST_URI} =~ m{^\s*/ba/(linux.baracus|initrd.baracus)\s*$} ) {

        $sql = qq|SELECT bin FROM sqlfstable WHERE name = '$1'|;
        die "$!" unless ( $sth = $tftph->prepare( $sql ) );
        die "$!" unless ( $sth->execute( ) );

        while ( $href = $sth->fetchrow_hashref( ) ) {
            $output .= unpack( 'u', $href->{'bin'} );
        }
    }

    else {
        # shoudld be some 401 or something
        $output = "invalid URL";
    }
}
else
{
    die "unsupported HTTP method:  $ENV{REQUEST_METHOD}\n";
}

print $cgi->header( -type => "text/plain", -content_length => length ($output)), $output;

exit 0;


1;
