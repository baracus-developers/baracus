#!/usr/bin/perl -w

use strict;
use warnings;

use CGI;
use Apache::DBI ();
use DBI ();

use lib "/usr/share/baracus/perl";

use BaracusSql qw( :vars :states );
use BaracusConfig qw( :vars );
use BaracusCgi qw( :subs );
use BaracusAux qw( :subs );
use BaracusHost qw( :subs :events );



my $cgi = new CGI;

my $input = {};  # for CGI args or PUT cookie

my $built   = "$baDir{hooks}/verify_client_build_passed";
my $spoofed = "$baDir{hooks}/verify_client_build_failed";

my $dbh = DBI->connect
    ("DBI:Pg:dbname=baracus;port=5162",
     "wwwrun",
     "",
     {
      PrintError => 1,          # warn() on errors
      RaiseError => 0,          # don't die on error
      AutoCommit => 1,          # commit executes
      # immediately
      }
     );

my $tftph = DBI->connect
    ("DBI:Pg:dbname=sqltftp;port=5162",
     "wwwrun",
     "",
     {
      PrintError => 1,          # warn() on errors
      RaiseError => 0,          # don't die on error
      AutoCommit => 1,          # commit executes
      # immediately
      }
     );

my $sth;
my $key;
my $state;
my %values;
my @fields;
my $fields;
my $values;
my $sql;
my $href;
my $bref;
my $macref;
my $hostref;
my $distref;
my $hardref;
my $filename;
my $output = "";


if ( $ENV{REQUEST_METHOD} eq "PUT" ) {

    ##
    ## Handle the uploading of files via "http PUT"
    ##
    ##   curl -b "mac=<mac>;status=<status>" -T <file> \
    ##       http://$baVar{serverip}/ba/inventory
    ##

    foreach my $key ( $cgi->cookie() ) {
        $input->{$key} = $cgi->cookie($key);
    }

    if ( $ENV{REQUEST_URI} =~ m|^\s*/ba/inventory\s*$| ) {

        ##
        ## REGISTER - STORE INVENTORY
        ##

        die "Missing 'mac=' in HTTP_COOKIE\n" unless ( defined $input->{mac} );

        print STDERR "$input->{mac} - host inventory received\n";

        $input->{mac} = &check_mac($input->{mac});
        $filename = $input->{mac} . ".inventory";

        $macref = &get_db_mac( $dbh, $input->{mac} );

        $href = &get_tftpfile( $tftph, $filename );

        # hum... always want the new inventory...
        # so we know we have to remove the old entry first
        if (defined $href and ($href->{name} eq $filename)) {
            &delete_tftpfile( $tftph, $filename );
        }

        $fields = "name,bin,description,enabled,insertion";
        $values = qq|'$filename',?,'lshw xml','1',CURRENT_TIMESTAMP(0)|;
        $sql = qq|INSERT INTO sqlfstable ( $fields ) VALUES ( $values )|;
        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );

        my $bin;
        my $bytes = 1;
        while ( $bytes ) {
            read( STDIN, $bytes, BA_DBMAXLEN ); # $ENV{CONTENT_LENGTH}
            if ( $bytes ) {
                $bin = pack( 'u', $bytes );
                unless ( $sth->execute( $bin ) ) {
                    print STDERR $sth->err;
                    exit 0;
                }
            }
        }
        $sth->finish();
        $output = "upload success\n";

        $state = BA_REGISTER;
        $hostref = &get_db_host_by_mac( $dbh, $input->{mac} );
        manage_host_states( $dbh, BA_EVENT_REGISTER, $macref, $hostref );
        if ( defined $hostref and $hostref->{hostname} ne "" ) {
            &update_db_host_entry( $dbh, $hostref );
        }

    } elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/wipe\s*$| ) {

        ##
        ## WIPE - ERASE DISK COMPLETION HOOK - STORE LOG
        ##

        die "Missing 'mac=' in COOKIE\n" unless ( defined $input->{mac} );
        die "Missing 'status=' in COOKIE\n" unless ( defined $input->{status} );

        print STDERR "$input->{mac} - wipe log received\n";

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );

        $filename = $input->{mac} . ".wipelog";
        $href = &get_tftpfile( $tftph, $filename );

        # hum... always want the new log...
        # so we know we have to remove the old entry first
        if (defined $href and ($href->{name} eq $filename)) {
            &delete_tftpfile( $tftph, $filename );
        }

        $fields = "name,bin,description,enabled,insertion";
        $values = qq|'$filename',?,'dban wipe log','1',CURRENT_TIMESTAMP(0)|;
        $sql = qq|INSERT INTO sqlfstable ( $fields ) VALUES ( $values )|;
        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );

        my $bin;
        my $bytes = 1;
        while ( $bytes ) {
            read( STDIN, $bytes, BA_DBMAXLEN ); # $ENV{CONTENT_LENGTH}
            if ( $bytes ) {
                $bin = pack( 'u', $bytes );
                unless ( $sth->execute( $bin ) ) {
                    print STDERR $sth->err;
                    exit 0;
                }
            }
        }
        $sth->finish();
        $output = "upload success\n";

        $hostref = &get_db_host_by_mac( $dbh, $input->{mac} );

        if ($input->{status} eq "pass") {
            $state = BA_WIPED;
            manage_host_states( $dbh, BA_EVENT_WIPED, $macref, $hostref );
        } else {
            $state = BA_WIPEFAIL;
            manage_host_states( $dbh, BA_EVENT_WIPEFAIL, $macref, $hostref );
        }

        if ( defined $hostref and $hostref->{hostname} ne "" ) {
            &update_db_host_entry( $dbh, $hostref );
        }

    } else {

        ##
        ## NO OTHER HTTP PUT ALLOWED
        ##

        $output = "permission denied\n";
        print $cgi->header( -type => "text/plain",
                            -content_length => length
                            ($output)
                           ), $output;
        exit 0;
    }
}
elsif ( $ENV{REQUEST_METHOD} eq "GET" )
{
    ##
    ## Handle HTTP GET requests with or without CGI parameters
    ##
    ##   curl -s -o /tmp/pxemenu \
    ##       http://$baVar{serverip}/ba/boot?mac=<mac>&ip=<ip>
    ##

    foreach my $key ( $cgi->param() ) {
        $input->{$key} = $cgi->param($key);
    }

    if ( $ENV{REQUEST_URI} =~ m|^\s*/ba/env.*\s*$| ) {

        $output .= "CGI URL INPUT\n";
        foreach my $env ( keys %{$input} ) {

            $output .= "$env => $input->{ $env }\n";
        }

        $output .= "\n";
        $output .= "ENVIRONMENT\n";
        foreach my $env ( keys %ENV ) {
            $output .= "$env => $ENV{ $env }\n";
        }
    }
    elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/boot\?.*\s*$| ) {

        ##
        ## PXE - DIRECT TO INVENTORY, LOCALBOOT, INSTALL, WIPE
        ##

        die "Missing 'mac=' in URL\n" unless ( defined $input->{mac} );

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );
        if ( not defined $macref ) {

            ##
            ## INVENTORY
            ##

            print STDERR "$input->{mac} - found and need inventory\n";

            $state = BA_FOUND;

            &add_db_mac( $dbh, $input->{mac}, $state, $baState{$state} );

            &get_inventory( $cgi, \%baVar, $input );  # exits

        }

        $filename = $input->{mac} . ".inventory";
        $href = &get_tftpfile( $tftph, $filename );
        if ( not defined $href or
             $href->{name} ne $filename or
             not defined $macref->{register} or
             $macref->{register} eq "" )
        {
            ##
            ## INVENTORY
            ##

            print STDERR "$input->{mac} - get missing inventory file\n";

            &get_inventory( $cgi, \%baVar, $input );  # exits
        }

        $bref = &get_build( $dbh, $input );
        if (not defined $bref ) {

            ##
            ## LOCALBOOT
            ##

            print STDERR "$input->{mac} - need bahost to describe build params\n";

            &do_localboot( $cgi );  # exits
        }

        $hostref = &get_db_host_entry( $dbh, $bref->{hostname} );
        $state = $macref->{state};

        if ( $hostref->{admin} eq BA_DISABLED or
             $state eq BA_NOPXE    or
             $state eq BA_DELETED  or
             $state eq BA_DISABLED ) {
            # use 'bahost enable' for READY rebuild

            ##
            ## LOCALBOOT
            ##

            print STDERR "$input->{mac} - pxe disabled\n";

            exit 0;
            # &do_localboot( $cgi );  # exits
        }

        $state = $macref->{state};

        if ( $state eq BA_BUILDING or   # BUILDING has 2nd stage reboot
             $state eq BA_BUILT    or   # don't re-build forever
             $state eq BA_LOCALBOOT ) {

            ##
            ## LOCALBOOT
            ##

            print STDERR "$input->{mac} - bahost entry building or built\n";

            &do_localboot( $cgi );  # exits
        }

        $distref = &get_distro( $dbh, $bref );

        $hardref = &get_hardware( $dbh, $bref );

        if ( $state eq BA_FOUND    or
             $state eq BA_ADDED    or
             $state eq BA_READY    or
             $state eq BA_SPOOFED  or
             $state eq BA_UPDATED  or
             $state eq BA_REGISTER ) {

            ##
            ## BUILD
            ##

            print STDERR "$input->{mac} - building\n";

            $state = BA_BUILDING;

            manage_host_states( $dbh, BA_EVENT_BUILDING, $macref, $hostref );
            $hostref->{cmdline} = "building";
            &update_db_host_entry( $dbh, $hostref );

            my $args;

            if ( $distref->{os} eq "opensuse" or
                 $distref->{os} eq "sles"     or
                 $distref->{os} eq "sled"   ) {
                $args = qq|textmode=1 install=$distref->{sharetype}://$distref->{shareip}$distref->{basepath} autoyast=http://$baVar{serverip}/ba/auto?mac=$input->{mac}|;


            } elsif ( $distref->{os} eq "fedora" or
                      $distref->{os} eq "centos" or
                      $distref->{os} eq "rhel" ) {
                $args = qq|text ks=http://$baVar{serverip}/ba/auto?mac=$input->{mac}|;
            }

            $output =
                qq|DEFAULT $bref->{hostname}
PROMPT 0
TIMEOUT 0

LABEL $bref->{hostname}
    kernel http://$baVar{serverip}/ba/linux?mac=$input->{mac}
    append initrd=http://$baVar{serverip}/ba/initrd?mac=$input->{mac} $hardref->{bootargs} $hostref->{raccess} $hostref->{loghost} $args
|;

        }

        if ( $state eq BA_DISKWIPE or
             $state eq BA_WIPING   or
             $state eq BA_WIPEFAIL or
             $state eq BA_WIPED ) {

            ##
            ## WIPE
            ##

            print STDERR "$input->{mac} - wiping\n";

            $state = BA_WIPING;

            manage_host_states( $dbh, BA_EVENT_WIPING, $macref, $hostref );
            $hostref->{cmdline} = "wiping";
            &update_db_host_entry( $dbh, $hostref );

            my $autonuke = "";
            $autonuke = " --autonuke" if ( $hostref->{autonuke} );
            $output =
                qq|DEFAULT wipe
PROMPT 0
TIMEOUT 0

LABEL wipe
        kernel http://$baVar{serverip}/ba/linux.baracus
        append initrd=http://$baVar{serverip}/ba/initrd.baracus root=/dev/ram0 install=exec:/usr/bin/baracus.dban nuke="dwipe${autonuke}" baracus=$baVar{serverip} mac=$input->{mac}
|;

        }

    }
    elsif ( $ENV{REQUEST_URI} =~ m{^\s*/ba/(linux|initrd|auto)\?.*\s*$} ) {

        my $file = $1;

        ##
        ## KERNEL OR INITRD OR AUTOBUILD FILE
        ##

        die "Missing 'mac=' in URL\n" unless ( defined $input->{mac} );

        $input->{mac} = &check_mac($input->{mac});
        $macref = &get_db_mac( $dbh, $input->{mac} );
        if ( not defined $macref ) {
            $output = "$input->{mac} - race... missing mac entry in build\n";
            print STDERR $output;
            print $cgi->header( -type => "text/plain",
                                -content_length => length
                                ($output)
                               ), $output;
            exit 0;
        }

        $bref = &get_build( $dbh, $input );
        if (not defined $bref ) {
            $output = "$input->{mac} - race... missing build entry in build\n";
            print STDERR $output;
            print $cgi->header( -type => "text/plain",
                                -content_length => length
                                ($output)
                               ), $output;
            exit 0;
        }

        if ( $file eq "auto" ) {
            $file = $input->{mac};
            $file =~ s|:|-|g;
            $file = "02-" . $file;
        } else {
            $file = "$file.$bref->{distroid}";
        }

        print STDERR "$input->{mac} - serving $file\n";

        $sql = qq|SELECT bin FROM sqlfstable WHERE name = '$file'|;

        die "$!\n$tftph->errstr" unless ( $sth = $tftph->prepare( $sql ) );
        die "$!$sth->err\n" unless ( $sth->execute( ) );

        while ( $href = $sth->fetchrow_hashref( ) ) {
            $output .= unpack( 'u', $href->{'bin'} );
        }
        $sth->finish();

    }
    elsif ( $ENV{REQUEST_URI} =~ m|^\s*/ba/built\?.*\s*$| ) {

        my $hostname = $input->{ hostname };
        my $uuid = $input->{ uuid };
        my $ip = $ENV{ REMOTE_ADDR };

        # hash with a hostname
        $hostref = &get_db_host_entry( $dbh, $input->{hostname} );
        $input->{mac} = $hostref->{ mac };

        # check for spoofing of url access
        if (( "$uuid" ne "$hostref->{'uuid'}" ) or
            (( "$ip"  ne "$hostref->{'ip'}"  ) and
             ( "dhcp" ne "$hostref->{'ip'}"  ))) {

            $state = BA_SPOOFED;
            $hostref->{cmdline} = "spoofed";
            &manage_host_states( $dbh, BA_EVENT_SPOOFED, $macref, $hostref );
            print STDERR "$input->{mac} - $hostname build complete callback spoofed\n";
            $output .= "build spoofed - spoof hook called\n";
            system( "$spoofed $hostname $ip $uuid $input->{mac} &" ) if ( -f $spoofed );
        }
        else {
            $state = BA_BUILT;
            $hostref->{cmdline} = "built";
            manage_host_states( $dbh, BA_EVENT_BUILT, $macref, $hostref );
            print STDERR "$input->{mac} - $hostname build complete callback verified\n";
            $output .= "build verified - verify hook called\n";
            system( "$built $hostname $ip $uuid $input->{mac} &" ) if ( -f $built );
        }

        &update_db_host_entry( $dbh, $hostref );
    }

    ##
    ## kernel and initrd for inventory and dban
    ##

    elsif ( $ENV{REQUEST_URI} =~ m{^\s*/ba/(linux.baracus|initrd.baracus)\s*$} ) {

        $sql = qq|SELECT bin FROM sqlfstable WHERE name = '$1'|;
        die "$!" unless ( $sth = $tftph->prepare( $sql ) );
        die "$!" unless ( $sth->execute( ) );

        while ( $href = $sth->fetchrow_hashref( ) ) {
            $output .= unpack( 'u', $href->{'bin'} );
        }
    }
    else {
        # shoudld be some 401 or something
        $output = "invalid URL";
    }
}
else
{
    die "unsupported HTTP method:  $ENV{REQUEST_METHOD}\n";
}

print $cgi->header( -type => "text/plain", -content_length => length ($output)), $output;

exit 0;


1;
