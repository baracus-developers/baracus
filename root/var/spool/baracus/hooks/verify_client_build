#!/usr/bin/perl -w

use strict;

use lib "/usr/share/baracus/perl";

use BaracusDB;
use BaracusSql;

my $debug = 0;

if (@ARGV != 3) {
  print "usage built_updatedb <hostname> <ip> <uuid>\n\n";
  exit 1;
}

my $hostname = shift @ARGV;
my $ip       = shift @ARGV;
my $uuid     = shift @ARGV;

my $dbname = "baracus";
my $dbrole = $dbname;

my $tblname = "templateid";

# only needed when run from command line as root
if ($> == 0) {
    my $uid = BaracusDB::su_user( $dbrole );
    die BaracusDB::errstr unless ( defined $uid );
}

my $dbh = BaracusDB::connect_db( $dbname, $dbrole );
die BaracusDB::errstr unless( $dbh );

# get host template entry if any
my $dbref = &get_db_host_entry( $dbh, $tblname, $hostname );
unless( defined $dbref ) {
    print "unable to find template for $hostname ip $ip\n";
    exit 1;
}

# check that ip and uuid match or state is 3:spoofed
my $state = 2;
# check for spoofing of url access
if (( "$uuid" ne "$dbref->{'uuid'}" ) or
    ( "$ip"   ne "$dbref->{'ip'}"   )) {
    $state = 3;
}

# check that the last change time greater than delta
my $minutes = 8;
my $delta = 60 * $minutes;
if ( ( &less_than_delta( $dbref->{'change'}, $delta ) ) and
     ( $dbref->{'state'} == $state ) ) {
    exit 2;
}

$dbref->{'state'} = $state;

# update the host template entry
&update_db_host_entry( $dbh, $tblname, $dbref );

die BaracusDB::errstr unless BaracusDB::disconnect_db( $dbh );

unless ( $state == 2 ) {
  exit 1;
}
exit 0;

die "does not execute";

sub get_db_host_entry() {
    my $dbh = shift;
    my $tblname = shift;
    my $hostname = shift;

    my $tablehash = BaracusSql::get_baracus_tables();
    my $cols = BaracusSql::keys2columns( $tablehash->{ $tblname } );

    my $sql = qq|SELECT $cols FROM $tblname WHERE hostname = ? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare select statement\n" . $dbh->errstr;
    $sth->execute( $hostname )
        or die "Cannot execute select statement\n" . $sth->err;

    return $sth->fetchrow_hashref();
}

sub update_db_host_entry() {
    my $dbh = shift;
    my $tblname = shift;
    my %hash = %{$_[0]};

    my $sql = qq|UPDATE $tblname SET
                 state=?,
                 change=CURRENT_TIMESTAMP(2)
                 WHERE hostname=? |;

    my $sth = $dbh->prepare( $sql )
        or die "Cannot prepare update statement\n" . $dbh->errstr;

    $sth->bind_param( 1,  $hash{'state'}    );
    $sth->bind_param( 2,  $hash{'hostname'} );

    $sth->execute()
        or die "Cannot execute update statement\n" . $sth->err;
}

sub less_than_delta {

    use Time::Local;

    my $change = shift;   # string like 2009-05-13 14:01:02.08 _localtime_
    my $delta  = shift;
    my $now    = time();  # UTC... gah

    # remove fractions of seconds
    $change =~ s|\..*||;
    my @emit = split( /[-:\s]+/, $change);
    # rebase month for '0' offset from january
    --$emit[1];

    my $then = timelocal( reverse( @emit ));

    $change = $now - $then;
    return ( $change < $delta ) ? 1 : 0;
}
